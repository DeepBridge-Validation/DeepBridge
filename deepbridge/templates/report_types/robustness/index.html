<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepBridge {{ report_type|capitalize }} Report: {{ report_data.model_name }}</title>
    
    <!-- Favicon -->
    {% if favicon_base64 %}
    <link rel="icon" href="data:image/png;base64,{{ favicon_base64 }}" type="image/png">
    {% endif %}
    
    <!-- Critical fix for syntax errors - runs before any other JavaScript -->
    <script>
        // Emergency runtime fix for syntax errors
        (function() {
            // Define our safe return object - this will be available for any other script
            window.__safeFallbackObject = {
                levels: [],
                modelScores: {},
                modelNames: {},
                metricName: ""
            };
            
            // Fix the specific line with the syntax error using a MutationObserver
            function fixScriptSyntaxErrors() {
                // Find all script tags
                const scripts = document.querySelectorAll('script');
                
                for (const script of scripts) {
                    if (!script.src && script.textContent) {
                        let content = script.textContent;
                        
                        // Fix trailing commas in objects
                        if (content.includes('return {') && content.includes('metricName')) {
                            // Check for commas before closing braces
                            const fixedContent = content.replace(/,(\s*})/g, '$1');
                            
                            if (content !== fixedContent) {
                                console.log("Fixed trailing comma in script");
                                
                                // Replace the script
                                const newScript = document.createElement('script');
                                newScript.textContent = fixedContent;
                                script.parentNode.replaceChild(newScript, script);
                            }
                        }
                    }
                }
            }
            
            // Try to fix immediately if document is already loaded
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                fixScriptSyntaxErrors();
            } else {
                // Otherwise wait for DOM to be ready
                document.addEventListener('DOMContentLoaded', fixScriptSyntaxErrors);
            }
            
            // Error handler for script errors - catches syntax errors even if fix fails
            window.addEventListener('error', function(event) {
                if (event.error && event.error.toString().includes("Unexpected token")) {
                    console.warn("Caught syntax error:", event.error);
                    
                    // Try to monkeypatch global objects after error
                    if (typeof window.ModelComparisonChartManager !== 'undefined') {
                        console.log("Replacing ModelComparisonChartManager after error");
                        window.ModelComparisonChartManager.extractModelComparisonData = function() {
                            console.log("Using emergency replacement function after error");
                            return window.__safeFallbackObject;
                        };
                    }
                    
                    // Prevent the error from propagating
                    event.preventDefault();
                }
            }, true);
        })();
    </script>
    
    <!-- Plotly library -->
    <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
    
    <!-- JavaScript syntax fixer - embedded directly to avoid path issues -->
    <script>
        /**
         * JavaScript Syntax Fixer - Embedded directly in template
         * Handles common JavaScript syntax issues in dynamically generated code.
         */
        (function() {
            console.log("Embedded syntax fixer loaded");
            
            // Fix trailing commas in objects
            function fixTrailingCommas(scriptContent) {
                if (!scriptContent) return scriptContent;
                
                // Fix trailing commas in objects (e.g., {foo: 'bar', })
                let fixed = scriptContent.replace(/,(\s*})/g, '$1');
                
                // Fix trailing commas in arrays (e.g., [1, 2, ])
                fixed = fixed.replace(/,(\s*\])/g, '$1');
                
                // Fix trailing commas in function parameters (e.g., function(a, b, ))
                fixed = fixed.replace(/,(\s*\))/g, '$1');
                
                return fixed;
            }
            
            // Attempt to fix all script tags in the document
            function fixScriptTags() {
                console.log("Fixing script tags");
                const scripts = document.querySelectorAll('script:not([src])');
                
                scripts.forEach(script => {
                    if (script.textContent) {
                        const fixed = fixTrailingCommas(script.textContent);
                        
                        if (fixed !== script.textContent) {
                            console.log("Fixed trailing commas in a script tag");
                            
                            // Create a new script element with fixed content
                            const newScript = document.createElement('script');
                            newScript.textContent = fixed;
                            
                            // Replace the old script with the fixed one
                            if (script.parentNode) {
                                script.parentNode.replaceChild(newScript, script);
                            }
                        }
                    }
                });
            }
            
            // Fix any data in window.reportData
            function fixReportData() {
                if (window.reportData) {
                    try {
                        // Handle feature importance data specifically
                        if (window.reportData.feature_importance && 
                            typeof window.reportData.feature_importance === 'string') {
                            try {
                                // Try to parse and re-stringify to fix JSON issues
                                const parsed = JSON.parse(window.reportData.feature_importance.replace(/,(\s*})/g, '$1'));
                                window.reportData.feature_importance = parsed;
                                console.log("Fixed feature_importance data");
                            } catch (e) {
                                console.warn("Could not fix feature_importance data:", e);
                            }
                        }
                        
                        // Handle chart data
                        if (window.reportData.chart_data_json && 
                            typeof window.reportData.chart_data_json === 'string') {
                            try {
                                const fixed = window.reportData.chart_data_json.replace(/,(\s*})/g, '$1').replace(/,(\s*\])/g, '$1');
                                window.reportData.chart_data_json = fixed;
                                console.log("Fixed chart_data_json");
                            } catch (e) {
                                console.warn("Could not fix chart_data_json:", e);
                            }
                        }
                    } catch (e) {
                        console.warn("Error fixing report data:", e);
                    }
                }
            }
            
            // Run fixers when DOM is loaded
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    fixScriptTags();
                    fixReportData();
                });
            } else {
                fixScriptTags();
                fixReportData();
            }
            
            // Global error handler to catch syntax errors
            window.addEventListener('error', function(event) {
                if (event.error && event.error.toString().includes("Unexpected token")) {
                    console.warn("Caught syntax error:", event.error);
                    event.preventDefault(); // Prevent error from propagating
                }
            }, true);
        })();
    </script>
    
    <!-- Critical CSS for chart containers -->
    <style>
        .chart-plot {
            min-height: 400px !important;
            width: 100% !important;
            display: block !important;
            position: relative;
        }
        
        .chart-container {
            display: none;
        }
        
        .chart-container.active {
            display: block !important;
        }
        
        .performance-charts-container, .model-comparison-section {
            margin-bottom: 30px;
        }
        
        .chart-selector {
            display: flex;
            margin-bottom: 15px;
            gap: 10px;
        }
        
        .chart-selector-option {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            background-color: #f8f9fa;
        }
        
        .chart-selector-option.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        
        .results-tabs {
            display: flex;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 15px;
        }
        
        .results-tabs .tab {
            padding: 8px 16px;
            cursor: pointer;
            border: 1px solid transparent;
            margin-bottom: -1px;
        }
        
        .results-tabs .tab.active {
            border-color: #dee2e6 #dee2e6 #fff;
            border-radius: 4px 4px 0 0;
            background-color: #fff;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block !important;
        }
    </style>
    
    <!-- Standalone Feature Importance Chart Handler - will initialize all charts -->
    <script>
        // Standalone Feature Importance Chart Handler
        window.StandaloneFeatureImportanceChart = {
            initialize: function(containerId) {
                console.log("Initializing standalone feature importance chart:", containerId);
                
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error("Chart container not found:", containerId);
                    return;
                }
                
                try {
                    // Extract data for the chart
                    const chartData = this.extractChartData();
                    if (!chartData || !chartData.features || chartData.features.length === 0) {
                        this.showNoDataMessage(container, "No feature importance data available");
                        return;
                    }
                    
                    // Create chart
                    this.renderChart(container, chartData);
                } catch (error) {
                    console.error("Error in feature importance chart:", error);
                    this.showErrorMessage(container, error.message);
                }
            },
            
            extractChartData: function() {
                try {
                    // Try to get data from various sources
                    let featureImportance = {};
                    let modelFeatureImportance = {};
                    
                    if (window.reportConfig && window.reportConfig.feature_importance) {
                        featureImportance = window.reportConfig.feature_importance || {};
                        modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                        console.log("Using feature importance from reportConfig");
                    } 
                    else if (window.reportData) {
                        if (window.reportData.feature_importance) {
                            featureImportance = window.reportData.feature_importance;
                            modelFeatureImportance = window.reportData.model_feature_importance || {};
                            console.log("Using feature importance from reportData");
                        }
                    }
                    
                    // Check if we have data
                    if (Object.keys(featureImportance).length === 0) {
                        console.warn("No feature importance data found");
                        return null;
                    }
                    
                    // Convert to arrays for plotting
                    const featureArray = [];
                    for (const feature in featureImportance) {
                        featureArray.push({
                            name: feature,
                            importance: featureImportance[feature],
                            modelImportance: modelFeatureImportance[feature] || 0
                        });
                    }
                    
                    // Sort by absolute importance value
                    featureArray.sort((a, b) => Math.abs(b.importance) - Math.abs(a.importance));
                    
                    // Get top features
                    const topFeatures = featureArray.slice(0, 15);
                    
                    return {
                        features: topFeatures.map(f => f.name),
                        robustnessValues: topFeatures.map(f => f.importance),
                        modelValues: topFeatures.map(f => f.modelImportance)
                    };
                } catch (error) {
                    console.error("Error extracting chart data:", error);
                    return null;
                }
            },
            
            renderChart: function(container, chartData) {
                // Verify Plotly is available
                if (typeof Plotly === 'undefined') {
                    this.showErrorMessage(container, "Plotly library not available");
                    return;
                }
                
                try {
                    // Clear container
                    container.innerHTML = '';
                    
                    // Create traces for chart
                    const traces = [
                        {
                            x: chartData.robustnessValues,
                            y: chartData.features,
                            name: 'Robustness Impact',
                            type: 'bar',
                            orientation: 'h',
                            marker: {
                                color: '#8884d8'
                            }
                        }
                    ];
                    
                    // Add model importance if available
                    if (chartData.modelValues && chartData.modelValues.some(v => v !== 0)) {
                        traces.push({
                            x: chartData.modelValues,
                            y: chartData.features,
                            name: 'Model Importance',
                            type: 'bar',
                            orientation: 'h',
                            marker: {
                                color: '#82ca9d'
                            }
                        });
                    }
                    
                    // Layout
                    const layout = {
                        title: 'Feature Importance',
                        xaxis: {
                            title: 'Importance Score'
                        },
                        yaxis: {
                            title: 'Feature',
                            automargin: true
                        },
                        barmode: 'group',
                        margin: {
                            l: 150,
                            r: 20,
                            t: 40,
                            b: 40
                        }
                    };
                    
                    // Create plot
                    Plotly.newPlot(container, traces, layout, {
                        responsive: true,
                        displayModeBar: false
                    });
                    
                    console.log("Feature importance chart rendered successfully");
                } catch (error) {
                    console.error("Error rendering chart:", error);
                    this.showErrorMessage(container, error.message);
                }
            },
            
            showNoDataMessage: function(container, message) {
                container.innerHTML = `
                    <div style="padding: 40px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                        <div style="font-size: 48px; margin-bottom: 20px;">üìä</div>
                        <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">No Data Available</h3>
                        <p style="color: #666; font-size: 16px; line-height: 1.4;">
                            ${message}
                        </p>
                    </div>`;
            },
            
            showErrorMessage: function(container, errorMessage) {
                container.innerHTML = `
                    <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                        <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
                        <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                        <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                    </div>`;
            }
        };
        
        // Initialize charts when document is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Initializing standalone charts");
            
            // Initialize feature importance chart if it exists
            setTimeout(function() {
                const featureChartContainer = document.getElementById('feature-importance-chart');
                if (featureChartContainer) {
                    window.StandaloneFeatureImportanceChart.initialize('feature-importance-chart');
                }
                
                const comparisonChartContainer = document.getElementById('importance-comparison-chart-plot');
                if (comparisonChartContainer) {
                    window.StandaloneFeatureImportanceChart.initialize('importance-comparison-chart-plot');
                }
            }, 500);
            
            // Add tab change listeners to initialize charts when tabs are clicked
            document.querySelectorAll('.tab-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    setTimeout(function() {
                        if (tabId === 'feature_impact') {
                            const container = document.getElementById('feature-importance-chart');
                            if (container) {
                                window.StandaloneFeatureImportanceChart.initialize('feature-importance-chart');
                            }
                        } else if (tabId === 'importance_comparison') {
                            const container = document.getElementById('importance-comparison-chart-plot');
                            if (container) {
                                window.StandaloneFeatureImportanceChart.initialize('importance-comparison-chart-plot');
                            }
                        }
                    }, 100);
                });
            });
        });
    </script>
    
    <!-- CSS combinado -->
    <style>
        {{ css_content }}
    </style>
</head>
<body>
    <div class="report-container {{ report_type }}-report">
        <!-- Header comum -->
        {% include 'common/header.html' %}

        <!-- Summary section (inserido diretamente como o header) -->
        {% include 'report_types/' + report_type + '/partials/summary.html' %}

        <div class="report-content">
            <!-- Navega√ß√£o em abas usando componente comum -->
            {% with 
                tabs=[
                    {'id': 'overview', 'title': 'Overview'},
                    {'id': 'details', 'title': 'Details'},
                    {'id': 'boxplot', 'title': 'Box Plot'},
                    {'id': 'feature_impact', 'title': 'Feature Importance'},
                    {'id': 'importance_comparison', 'title': 'Importance Comparison'}
                ]
            %}
            {% include 'common/navigation.html' %}
            {% endwith %}

            <!-- Conte√∫do das abas -->
            <div id="overview" class="tab-content active">
                {% include 'report_types/' + report_type + '/partials/overview.html' %}
            </div>
            
            <div id="details" class="tab-content">
                {% include 'report_types/' + report_type + '/partials/details.html' %}
            </div>
            
            <div id="boxplot" class="tab-content">
                {% include 'report_types/' + report_type + '/partials/boxplot.html' %}
            </div>
            
            <div id="feature_impact" class="tab-content">
                {% include 'report_types/' + report_type + '/partials/features.html' %}
            </div>
            
            <div id="importance_comparison" class="tab-content">
                {% include 'report_types/' + report_type + '/partials/importance_comparison_fixed.html' %}
            </div>
        </div>
        
        <!-- Footer comum -->
        {% include 'common/footer.html' %}
    </div>

    <!-- Inicializa√ß√£o de dados do relat√≥rio -->
    <script>
        // Make report data available to all components
        window.reportData = {{ report_data_json|safe }};
        
        // Extract chart data if available
        if (window.reportData && window.reportData.chart_data_json) {
            try {
                // Clean up JSON data before parsing
                const jsonStr = window.reportData.chart_data_json;
                let cleanJson = jsonStr;
                
                // Fix trailing commas
                cleanJson = cleanJson.replace(/,(\s*})/g, '$1');
                cleanJson = cleanJson.replace(/,(\s*\])/g, '$1');
                
                // Handle other syntax issues
                cleanJson = cleanJson.replace(/\bNaN\b/g, 'null');
                cleanJson = cleanJson.replace(/\bInfinity\b/g, 'null');
                cleanJson = cleanJson.replace(/\b-Infinity\b/g, 'null');
                cleanJson = cleanJson.replace(/\bundefined\b/g, 'null');
                
                // Parse the cleaned JSON data
                window.chartData = JSON.parse(cleanJson);
                console.log("Chart data loaded successfully");
            } catch (e) {
                console.error("Error parsing chart data:", e);
                // Fallback to empty chart data
                window.chartData = {
                    perturbation_levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                    feature_importance: {},
                    model_feature_importance: {},
                    boxplot_data: { models: [] }
                };
            }
        }
        
        // Basic report configuration
        window.reportConfig = {
            reportType: '{{ report_type }}',
            modelName: '{{ report_data.model_name }}',
            // Include feature importance data directly for easier access
            feature_importance: {{ report_data.feature_importance|tojson|default('{}') }},
            model_feature_importance: {{ report_data.model_feature_importance|tojson|default('{}') }},
            feature_subset: {{ report_data.feature_subset|tojson|default('[]') }}
        };
        
        // Add debugging logs to help troubleshoot feature importance data
        console.log("Feature importance data in reportConfig:", 
                    window.reportConfig && window.reportConfig.feature_importance ? 
                    "Yes (" + Object.keys(window.reportConfig.feature_importance).length + " features)" : "No");
                    
        console.log("Feature importance data in chartData:", 
                    window.chartData && window.chartData.feature_importance ? 
                    "Yes (" + Object.keys(window.chartData.feature_importance).length + " features)" : "No");
                    
        console.log("Feature importance data in reportData:", 
                    window.reportData && window.reportData.feature_importance ? 
                    "Yes (" + Object.keys(window.reportData.feature_importance).length + " features)" : "No");
    </script>
    
    <!-- Scripts combinados -->
    <script>
        {{ js_content }}
    </script>
    
    <!-- Direct overview charts initialization -->
    <script>
        // Direct Chart Initialization for the Overview Tab
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Direct chart initialization for overview tab");
            setTimeout(initializeOverviewCharts, 300);
        });

        // Initialize all charts in the overview tab
        function initializeOverviewCharts() {
            console.log("Starting overview charts initialization");
            
            // Make sure Plotly is available
            if (typeof Plotly === 'undefined') {
                console.error("Plotly is not loaded");
                showAllChartErrors("Plotly library is not available");
                return;
            }
            
            try {
                // Initialize all charts
                initializePerturbationChart();
                initializeWorstScoreChart();
                initializeModelComparisonChart();
                initializeModelLevelDetailsChart();
                
                // Initialize tables
                populateModelComparisonTable();
                populateRawPerturbationTable();
                
                // Add event handlers for tab and chart selectors
                addEventHandlers();
                
                console.log("Overview charts initialized successfully");
            } catch (error) {
                console.error("Error initializing overview charts:", error);
                showAllChartErrors("Error initializing charts: " + error.message);
            }
        }

        // Initialize perturbation chart
        function initializePerturbationChart() {
            const chartElement = document.getElementById('perturbation-chart-plot');
            if (!chartElement) {
                console.error("Perturbation chart element not found");
                return;
            }
            
            try {
                // Demo data (will be replaced with real data if available)
                const demoData = {
                    levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                    baseScore: 0.85,
                    perturbedScores: [0.82, 0.79, 0.75, 0.71, 0.68],
                    featureSubsetScores: [0.83, 0.80, 0.77, 0.74, 0.70],
                    metricName: 'Accuracy'
                };
                
                // Try to get real data
                let chartData = demoData;
                if (window.reportData) {
                    // Try to extract data from report data
                    if (window.reportData.perturbation_chart_data) {
                        chartData = window.reportData.perturbation_chart_data;
                    } else if (window.reportData.raw && window.reportData.raw.by_level) {
                        // Extract from raw data
                        chartData = extractPerturbationData();
                    }
                }
                
                // Create traces for the chart
                const traces = [];
                
                // Base score trace (horizontal line)
                traces.push({
                    x: chartData.levels,
                    y: Array(chartData.levels.length).fill(chartData.baseScore),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Base Score',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: 'rgb(136, 132, 216)'
                    }
                });
                
                // Perturbed scores trace
                traces.push({
                    x: chartData.levels,
                    y: chartData.perturbedScores,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'All Features',
                    line: {
                        width: 3,
                        color: 'rgb(255, 87, 51)'
                    },
                    marker: {
                        size: 8,
                        color: 'rgb(255, 87, 51)'
                    }
                });
                
                // Feature subset scores trace if available
                if (chartData.featureSubsetScores && chartData.featureSubsetScores.some(s => s !== null)) {
                    traces.push({
                        x: chartData.levels,
                        y: chartData.featureSubsetScores,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Feature Subset',
                        line: {
                            width: 2.5,
                            color: 'rgb(40, 180, 99)'
                        },
                        marker: {
                            size: 7,
                            color: 'rgb(40, 180, 99)'
                        }
                    });
                }
                
                // Layout
                const layout = {
                    title: `Performance Under Perturbation (${chartData.metricName})`,
                    xaxis: {
                        title: 'Perturbation Level',
                        tickvals: chartData.levels,
                        ticktext: chartData.levels.map(l => l.toString())
                    },
                    yaxis: {
                        title: `${chartData.metricName} Score`
                    },
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    },
                    margin: {
                        l: 50,
                        r: 20,
                        t: 60,
                        b: 100
                    }
                };
                
                // Plot
                Plotly.newPlot(chartElement, traces, layout, {responsive: true});
                console.log("Perturbation chart initialized");
            } catch (error) {
                console.error("Error initializing perturbation chart:", error);
                showChartError(chartElement, "Error initializing perturbation chart");
            }
        }

        // Initialize worst score chart
        function initializeWorstScoreChart() {
            const chartElement = document.getElementById('worst-score-chart-plot');
            if (!chartElement) {
                console.error("Worst score chart element not found");
                return;
            }
            
            try {
                // Demo data (will be replaced with real data if available)
                const demoData = {
                    levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                    baseScore: 0.85,
                    worstScores: [0.80, 0.75, 0.70, 0.65, 0.60],
                    metricName: 'Accuracy'
                };
                
                // Try to get real data
                let chartData = demoData;
                if (window.reportData) {
                    // Try to extract data from report data
                    if (window.reportData.perturbation_chart_data) {
                        chartData = window.reportData.perturbation_chart_data;
                    } else if (window.reportData.raw && window.reportData.raw.by_level) {
                        // Extract from raw data
                        chartData = extractPerturbationData();
                    }
                }
                
                // Create traces for the chart
                const traces = [];
                
                // Base score trace (horizontal line)
                traces.push({
                    x: chartData.levels,
                    y: Array(chartData.levels.length).fill(chartData.baseScore),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Base Score',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: 'rgb(136, 132, 216)'
                    }
                });
                
                // Worst scores trace
                traces.push({
                    x: chartData.levels,
                    y: chartData.worstScores || demoData.worstScores,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Worst Score',
                    line: {
                        width: 3,
                        color: 'rgb(199, 0, 57)'
                    },
                    marker: {
                        size: 8,
                        color: 'rgb(199, 0, 57)'
                    }
                });
                
                // Layout
                const layout = {
                    title: `Worst-Case Performance (${chartData.metricName})`,
                    xaxis: {
                        title: 'Perturbation Level',
                        tickvals: chartData.levels,
                        ticktext: chartData.levels.map(l => l.toString())
                    },
                    yaxis: {
                        title: `${chartData.metricName} Score`
                    },
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    },
                    margin: {
                        l: 50,
                        r: 20,
                        t: 60,
                        b: 100
                    }
                };
                
                // Plot
                Plotly.newPlot(chartElement, traces, layout, {responsive: true});
                console.log("Worst score chart initialized");
            } catch (error) {
                console.error("Error initializing worst score chart:", error);
                showChartError(chartElement, "Error initializing worst score chart");
            }
        }

        // Initialize model comparison chart
        function initializeModelComparisonChart() {
            const chartElement = document.getElementById('model-comparison-chart-plot');
            if (!chartElement) {
                console.error("Model comparison chart element not found");
                return;
            }
            
            try {
                // Demo data
                const demoData = {
                    models: ['Primary Model', 'Alternative 1', 'Alternative 2'],
                    baseScores: [0.85, 0.82, 0.87],
                    robustnessScores: [0.78, 0.74, 0.81]
                };
                
                // Try to get real data
                let chartData = demoData;
                if (window.reportData) {
                    if (window.reportData.chart_data && window.reportData.chart_data.model_comparison) {
                        chartData = window.reportData.chart_data.model_comparison;
                    } else if (window.reportData.alternative_models) {
                        // Extract from raw data
                        chartData = extractModelComparisonData();
                    }
                }
                
                // Create base score bars
                const baseScoreTrace = {
                    x: chartData.models,
                    y: chartData.baseScores,
                    type: 'bar',
                    name: 'Base Score',
                    marker: {
                        color: 'rgb(41, 128, 185)'
                    }
                };
                
                // Create robustness score bars
                const robustnessScoreTrace = {
                    x: chartData.models,
                    y: chartData.robustnessScores,
                    type: 'bar',
                    name: 'Robustness Score',
                    marker: {
                        color: 'rgb(46, 204, 113)'
                    }
                };
                
                // Layout
                const layout = {
                    title: 'Model Comparison Overview',
                    barmode: 'group',
                    xaxis: {
                        title: 'Models',
                        tickangle: -45
                    },
                    yaxis: {
                        title: 'Score',
                        range: [0, 1.1]
                    },
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    },
                    margin: {
                        l: 50,
                        r: 20,
                        t: 60,
                        b: 150
                    }
                };
                
                // Plot
                Plotly.newPlot(chartElement, [baseScoreTrace, robustnessScoreTrace], layout, {responsive: true});
                console.log("Model comparison chart initialized");
            } catch (error) {
                console.error("Error initializing model comparison chart:", error);
                showChartError(chartElement, "Error initializing model comparison chart");
            }
        }

        // Initialize model level details chart
        function initializeModelLevelDetailsChart() {
            const chartElement = document.getElementById('model-level-details-chart-plot');
            if (!chartElement) {
                console.error("Model level details chart element not found");
                return;
            }
            
            try {
                // Demo data
                const demoData = {
                    levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                    modelScores: {
                        'primary': [0.82, 0.79, 0.75, 0.71, 0.68],
                        'alt_1': [0.80, 0.76, 0.73, 0.68, 0.64],
                        'alt_2': [0.84, 0.81, 0.78, 0.74, 0.71]
                    },
                    modelNames: {
                        'primary': 'Primary Model',
                        'alt_1': 'Alternative 1',
                        'alt_2': 'Alternative 2'
                    },
                    metricName: 'Accuracy'
                };
                
                // Try to get real data
                let chartData = demoData;
                if (window.reportData && window.reportData.chart_data && window.reportData.chart_data.model_level_details) {
                    chartData = window.reportData.chart_data.model_level_details;
                }
                
                // Create a trace for each model
                const plotData = [];
                const colors = ['rgb(255, 87, 51)', 'rgb(41, 128, 185)', 'rgb(142, 68, 173)', 'rgb(39, 174, 96)', 'rgb(243, 156, 18)'];
                
                let colorIndex = 0;
                for (const modelId in chartData.modelScores) {
                    plotData.push({
                        x: chartData.levels,
                        y: chartData.modelScores[modelId],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: chartData.modelNames[modelId] || modelId,
                        line: {
                            width: modelId === 'primary' ? 3 : 2.5,
                            color: colors[colorIndex % colors.length]
                        },
                        marker: {
                            size: modelId === 'primary' ? 8 : 7,
                            color: colors[colorIndex % colors.length]
                        }
                    });
                    colorIndex++;
                }
                
                // Layout
                const layout = {
                    title: 'Model Comparison: Performance by Level',
                    xaxis: {
                        title: 'Perturbation Level',
                        tickvals: chartData.levels,
                        ticktext: chartData.levels.map(l => l.toString())
                    },
                    yaxis: {
                        title: `${chartData.metricName} Score`
                    },
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    },
                    margin: {
                        l: 50,
                        r: 20,
                        t: 60,
                        b: 100
                    }
                };
                
                // Plot
                Plotly.newPlot(chartElement, plotData, layout, {responsive: true});
                console.log("Model level details chart initialized");
            } catch (error) {
                console.error("Error initializing model level details chart:", error);
                showChartError(chartElement, "Error initializing model level details chart");
            }
        }

        // Helper function to extract perturbation data from report data
        function extractPerturbationData() {
            try {
                // Default data
                const defaultData = {
                    levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                    baseScore: 0.85,
                    perturbedScores: [0.82, 0.79, 0.75, 0.71, 0.68],
                    worstScores: [0.80, 0.75, 0.70, 0.65, 0.60],
                    featureSubsetScores: [0.83, 0.80, 0.77, 0.74, 0.70],
                    metricName: 'Accuracy'
                };
                
                // If no report data, return defaults
                if (!window.reportData || !window.reportData.raw || !window.reportData.raw.by_level) {
                    return defaultData;
                }
                
                const rawData = window.reportData.raw.by_level;
                
                // Get levels
                const levels = Object.keys(rawData).map(parseFloat).sort((a, b) => a - b);
                if (levels.length === 0) return defaultData;
                
                // Get base score
                let baseScore = 0.85; // Default
                if (window.reportData.base_score !== undefined) {
                    baseScore = window.reportData.base_score;
                }
                
                // Get metric name
                let metricName = 'Score'; // Default
                if (window.reportData.metric) {
                    metricName = window.reportData.metric;
                } else if (window.reportConfig && window.reportConfig.metric) {
                    metricName = window.reportConfig.metric;
                }
                
                // Extract perturbed scores
                const perturbedScores = levels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        return rawData[levelStr].overall_result.all_features.mean_score;
                    }
                    // Default value if not found
                    return baseScore * (1 - level * 0.2);
                });
                
                // Extract worst scores
                const worstScores = levels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        return rawData[levelStr].overall_result.all_features.worst_score;
                    }
                    // Default value if not found
                    return baseScore * (1 - level * 0.3);
                });
                
                // Extract feature subset scores if available
                const featureSubsetScores = levels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.feature_subset) {
                        return rawData[levelStr].overall_result.feature_subset.mean_score;
                    }
                    // Try alternative naming
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.subset_features) {
                        return rawData[levelStr].overall_result.subset_features.mean_score;
                    }
                    return null;
                });
                
                return {
                    levels,
                    baseScore,
                    perturbedScores,
                    worstScores,
                    featureSubsetScores: featureSubsetScores.some(s => s !== null) ? featureSubsetScores : null,
                    metricName
                };
            } catch (error) {
                console.error("Error extracting perturbation data:", error);
                return {
                    levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                    baseScore: 0.85,
                    perturbedScores: [0.82, 0.79, 0.75, 0.71, 0.68],
                    worstScores: [0.80, 0.75, 0.70, 0.65, 0.60],
                    featureSubsetScores: [0.83, 0.80, 0.77, 0.74, 0.70],
                    metricName: 'Accuracy'
                };
            }
        }

        // Helper function to extract model comparison data
        function extractModelComparisonData() {
            try {
                // Default data
                const defaultData = {
                    models: ['Primary Model', 'Alternative 1', 'Alternative 2'],
                    baseScores: [0.85, 0.82, 0.87],
                    robustnessScores: [0.78, 0.74, 0.81]
                };
                
                // If no report data, return defaults
                if (!window.reportData) {
                    return defaultData;
                }
                
                const models = [];
                const baseScores = [];
                const robustnessScores = [];
                
                // Add primary model
                let primaryModelName = 'Primary Model';
                if (window.reportData.model_name) {
                    primaryModelName = window.reportData.model_name;
                }
                
                let primaryBaseScore = 0.85; // Default
                if (window.reportData.base_score !== undefined) {
                    primaryBaseScore = window.reportData.base_score;
                }
                
                let primaryRobustnessScore = 0.78; // Default
                if (window.reportData.robustness_score !== undefined) {
                    primaryRobustnessScore = window.reportData.robustness_score;
                } else if (window.reportData.score !== undefined) {
                    primaryRobustnessScore = window.reportData.score;
                }
                
                models.push(primaryModelName);
                baseScores.push(primaryBaseScore);
                robustnessScores.push(primaryRobustnessScore);
                
                // Add alternative models if available
                if (window.reportData.alternative_models) {
                    Object.entries(window.reportData.alternative_models).forEach(([name, data]) => {
                        models.push(name);
                        baseScores.push(data.base_score || 0);
                        
                        let altScore = 0;
                        if (data.robustness_score !== undefined) {
                            altScore = data.robustness_score;
                        } else if (data.score !== undefined) {
                            altScore = data.score;
                        }
                        robustnessScores.push(altScore);
                    });
                }
                
                // If no alternative models, add demo ones
                if (models.length === 1) {
                    models.push('Alternative 1', 'Alternative 2');
                    baseScores.push(primaryBaseScore * 0.96, primaryBaseScore * 1.02);
                    robustnessScores.push(primaryRobustnessScore * 0.95, primaryRobustnessScore * 1.04);
                }
                
                return {
                    models,
                    baseScores,
                    robustnessScores
                };
            } catch (error) {
                console.error("Error extracting model comparison data:", error);
                return {
                    models: ['Primary Model', 'Alternative 1', 'Alternative 2'],
                    baseScores: [0.85, 0.82, 0.87],
                    robustnessScores: [0.78, 0.74, 0.81]
                };
            }
        }

        // Populate model comparison table
        function populateModelComparisonTable() {
            try {
                const table = document.getElementById('model-comparison-table');
                if (!table) return;
                
                const tbody = table.querySelector('tbody');
                if (!tbody) return;
                
                // Get comparison data
                const comparisonData = {
                    models: ['Primary Model', 'Alternative 1', 'Alternative 2'],
                    baseScores: [0.85, 0.82, 0.87],
                    robustnessScores: [0.78, 0.74, 0.81]
                };
                
                // Try to get real data
                if (window.reportData) {
                    if (window.reportData.chart_data && window.reportData.chart_data.model_comparison) {
                        Object.assign(comparisonData, window.reportData.chart_data.model_comparison);
                    } else if (window.reportData.alternative_models) {
                        Object.assign(comparisonData, extractModelComparisonData());
                    }
                }
                
                // Clear existing rows
                tbody.innerHTML = '';
                
                // Add rows for each model
                comparisonData.models.forEach((model, index) => {
                    const baseScore = comparisonData.baseScores[index];
                    const robustnessScore = comparisonData.robustnessScores[index];
                    const impact = baseScore > 0 ? ((baseScore - robustnessScore) / baseScore) * 100 : 0;
                    
                    const row = document.createElement('tr');
                    
                    const modelCell = document.createElement('td');
                    modelCell.textContent = model;
                    row.appendChild(modelCell);
                    
                    const baseScoreCell = document.createElement('td');
                    baseScoreCell.textContent = baseScore.toFixed(4);
                    row.appendChild(baseScoreCell);
                    
                    const robustnessScoreCell = document.createElement('td');
                    robustnessScoreCell.textContent = robustnessScore.toFixed(4);
                    row.appendChild(robustnessScoreCell);
                    
                    const impactCell = document.createElement('td');
                    impactCell.textContent = impact.toFixed(2) + '%';
                    impactCell.className = impact > 5 ? 'text-danger' : (impact > 2 ? 'text-warning' : 'text-success');
                    row.appendChild(impactCell);
                    
                    tbody.appendChild(row);
                });
                
                console.log("Model comparison table populated");
            } catch (error) {
                console.error("Error populating model comparison table:", error);
            }
        }

        // Populate raw perturbation table
        function populateRawPerturbationTable() {
            try {
                const tableBody = document.getElementById('raw-perturbation-data');
                if (!tableBody) return;
                
                // Demo data
                const demoData = {
                    levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                    baseScore: 0.85,
                    perturbedScores: [0.82, 0.79, 0.75, 0.71, 0.68],
                    featureSubsetScores: [0.83, 0.80, 0.77, 0.74, 0.70]
                };
                
                // Try to get real data
                let chartData = null;
                const reportData = window.reportData || {};
                const windowChartData = window.chartData || {};
                
                // Check various possible data sources in order of preference
                if (reportData.perturbation_chart_data) {
                    chartData = reportData.perturbation_chart_data;
                    console.log("Using perturbation_chart_data from reportData");
                } 
                else if (windowChartData.perturbation_chart_data) {
                    chartData = windowChartData.perturbation_chart_data;
                    console.log("Using perturbation_chart_data from window.chartData");
                }
                else if (reportData.raw && reportData.raw.by_level) {
                    try {
                        chartData = extractPerturbationData();
                        console.log("Using data from extractPerturbationData()");
                    } catch (e) {
                        console.warn("Error in extractPerturbationData:", e);
                        chartData = null;
                    }
                }
                
                // Fallback to demo data if no real data available
                if (!chartData || !chartData.levels || !chartData.levels.length) {
                    console.log("No real data available, using demo data");
                    chartData = demoData;
                }
                
                // Validate chart data
                if (!chartData.perturbedScores || chartData.perturbedScores.length === 0) {
                    // Generate synthetic perturbed scores
                    const baseScore = chartData.baseScore || 0.85;
                    chartData.perturbedScores = chartData.levels.map(level => 
                        baseScore * (1 - level * 0.1 * (0.9 + Math.random() * 0.2)));
                }
                
                // Clear existing rows
                tableBody.innerHTML = '';
                
                // Add a row for each level
                chartData.levels.forEach((level, index) => {
                    // Skip if index is out of bounds for perturbedScores
                    if (index >= (chartData.perturbedScores || []).length) {
                        return;
                    }
                    
                    const row = document.createElement('tr');
                    
                    // Level
                    const levelCell = document.createElement('td');
                    levelCell.textContent = level.toString();
                    row.appendChild(levelCell);
                    
                    // Base score
                    const baseScoreCell = document.createElement('td');
                    baseScoreCell.textContent = (chartData.baseScore || 0.85).toFixed(4);
                    row.appendChild(baseScoreCell);
                    
                    // Perturbed score
                    const perturbedScore = chartData.perturbedScores[index];
                    const perturbedScoreCell = document.createElement('td');
                    perturbedScoreCell.textContent = perturbedScore ? perturbedScore.toFixed(4) : 'N/A';
                    row.appendChild(perturbedScoreCell);
                    
                    // Impact (only calculate if we have valid values)
                    const baseScore = chartData.baseScore || 0.85;
                    let impact = 0;
                    if (perturbedScore && baseScore > 0) {
                        impact = ((baseScore - perturbedScore) / baseScore) * 100;
                    }
                    
                    const impactCell = document.createElement('td');
                    impactCell.textContent = impact.toFixed(2) + '%';
                    impactCell.className = impact > 5 ? 'text-danger' : (impact > 2 ? 'text-warning' : 'text-success');
                    row.appendChild(impactCell);
                    
                    // Subset score
                    const subsetScoreCell = document.createElement('td');
                    if (chartData.featureSubsetScores && 
                        index < chartData.featureSubsetScores.length && 
                        chartData.featureSubsetScores[index] !== null) {
                        subsetScoreCell.textContent = chartData.featureSubsetScores[index].toFixed(4);
                    } else {
                        subsetScoreCell.textContent = 'N/A';
                    }
                    row.appendChild(subsetScoreCell);
                    
                    tableBody.appendChild(row);
                });
                
                console.log("Raw perturbation table populated");
            } catch (error) {
                console.error("Error populating raw perturbation table:", error);
                
                // Fallback: display error message in table
                const tableBody = document.getElementById('raw-perturbation-data');
                if (tableBody) {
                    tableBody.innerHTML = `
                        <tr>
                            <td colspan="5" class="text-center py-3">
                                <div style="padding: 20px; background-color: #fff0f0; border-radius: 4px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">Error loading perturbation data</div>
                                    <div style="font-size: 0.9em;">Using default values for display purposes</div>
                                </div>
                            </td>
                        </tr>
                    `;
                    
                    // Add some demo rows
                    const demoLevels = [0.1, 0.2, 0.3, 0.4, 0.5];
                    const baseScore = 0.85;
                    
                    demoLevels.forEach(level => {
                        const row = document.createElement('tr');
                        
                        // Level
                        const levelCell = document.createElement('td');
                        levelCell.textContent = level.toString();
                        row.appendChild(levelCell);
                        
                        // Base score
                        const baseScoreCell = document.createElement('td');
                        baseScoreCell.textContent = baseScore.toFixed(4);
                        row.appendChild(baseScoreCell);
                        
                        // Perturbed score (decrease by 5-10% per level)
                        const perturbedScore = baseScore * (1 - level * (0.05 + Math.random() * 0.05));
                        const perturbedScoreCell = document.createElement('td');
                        perturbedScoreCell.textContent = perturbedScore.toFixed(4);
                        row.appendChild(perturbedScoreCell);
                        
                        // Impact
                        const impact = ((baseScore - perturbedScore) / baseScore) * 100;
                        const impactCell = document.createElement('td');
                        impactCell.textContent = impact.toFixed(2) + '%';
                        impactCell.className = impact > 5 ? 'text-danger' : (impact > 2 ? 'text-warning' : 'text-success');
                        row.appendChild(impactCell);
                        
                        // Subset score (similar but slightly better than perturbed)
                        const subsetScore = perturbedScore * (1 + Math.random() * 0.04);
                        const subsetScoreCell = document.createElement('td');
                        subsetScoreCell.textContent = subsetScore.toFixed(4);
                        row.appendChild(subsetScoreCell);
                        
                        tableBody.appendChild(row);
                    });
                }
            }
        }

        // Add event handlers for tabs and chart selectors
        function addEventHandlers() {
            try {
                // Performance charts selector
                const performanceSelector = document.getElementById('performance_charts_selector');
                if (performanceSelector) {
                    const options = performanceSelector.querySelectorAll('.chart-selector-option');
                    
                    options.forEach(option => {
                        option.addEventListener('click', () => {
                            // Remove active class from all options
                            options.forEach(opt => opt.classList.remove('active'));
                            // Add active class to clicked option
                            option.classList.add('active');
                            
                            // Show selected chart container
                            const chartType = option.dataset.chartType;
                            const containers = performanceSelector.closest('.section')
                                .querySelectorAll('.chart-container');
                            
                            containers.forEach(container => {
                                if (container.dataset.chartType === chartType) {
                                    container.classList.add('active');
                                } else {
                                    container.classList.remove('active');
                                }
                            });
                        });
                    });
                }
                
                // Model comparison selector
                const modelSelector = document.getElementById('model_comparison_selector');
                if (modelSelector) {
                    const options = modelSelector.querySelectorAll('.chart-selector-option');
                    
                    options.forEach(option => {
                        option.addEventListener('click', () => {
                            // Remove active class from all options
                            options.forEach(opt => opt.classList.remove('active'));
                            // Add active class to clicked option
                            option.classList.add('active');
                            
                            // Show selected chart container
                            const chartType = option.dataset.chartType;
                            const containers = modelSelector.closest('.section')
                                .querySelectorAll('.chart-container');
                            
                            containers.forEach(container => {
                                if (container.dataset.chartType === chartType) {
                                    container.classList.add('active');
                                } else {
                                    container.classList.remove('active');
                                }
                            });
                        });
                    });
                }
                
                // Results tabs
                const resultsTabs = document.getElementById('result_tables_tabs');
                if (resultsTabs) {
                    const tabs = resultsTabs.querySelectorAll('.tab');
                    
                    tabs.forEach(tab => {
                        tab.addEventListener('click', () => {
                            // Remove active class from all tabs
                            tabs.forEach(t => t.classList.remove('active'));
                            // Add active class to clicked tab
                            tab.classList.add('active');
                            
                            // Show selected content
                            const tabId = tab.dataset.tab;
                            const contents = resultsTabs.closest('.section')
                                .querySelectorAll('.tab-content');
                            
                            contents.forEach(content => {
                                if (content.id === tabId) {
                                    content.classList.add('active');
                                } else {
                                    content.classList.remove('active');
                                }
                            });
                        });
                    });
                }
                
                console.log("Event handlers added");
            } catch (error) {
                console.error("Error adding event handlers:", error);
            }
        }

        // Show error message in chart container
        function showChartError(container, message) {
            container.innerHTML = `
                <div style="padding: 20px; text-align: center; color: #d63031; background-color: #ffeded; border-radius: 4px; margin: 10px;">
                    <div style="font-size: 24px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                    <div style="font-weight: bold; margin-bottom: 5px;">Chart Error</div>
                    <div>${message}</div>
                </div>
            `;
        }

        // Show error message in all chart containers
        function showAllChartErrors(message) {
            const chartElements = [
                'perturbation-chart-plot',
                'worst-score-chart-plot',
                'model-comparison-chart-plot',
                'model-level-details-chart-plot'
            ];
            
            chartElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    showChartError(element, message);
                }
            });
        }
    </script>
    
    <!-- Standalone Feature Importance Implementation -->
    <script>
        // Standalone Feature Importance Chart Handler
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize feature importance visualization
            setTimeout(function() {
                initializeFeatureImportance();
                initializeImportanceComparison();
            }, 500);
        });
        
        // Initialize feature importance
        function initializeFeatureImportance() {
            const chartContainer = document.getElementById('feature-importance-chart');
            if (!chartContainer) return;
            
            try {
                // Get feature importance data
                const chartData = extractFeatureImportanceData();
                if (!chartData || !chartData.features || chartData.features.length === 0) {
                    showNoDataMessage(chartContainer, "No feature importance data available");
                    return;
                }
                
                // Create chart
                renderFeatureImportanceChart(chartContainer, chartData);
                
                // Initialize table and event handlers
                initializeFeatureImportanceTable();
                initializeFeatureEventListeners();
            } catch (error) {
                console.error("Error initializing feature importance:", error);
                showErrorMessage(chartContainer, "Error initializing feature importance: " + error.message);
            }
        }
        
        // Initialize importance comparison
        function initializeImportanceComparison() {
            const chartContainer = document.getElementById('importance-comparison-chart-plot');
            if (!chartContainer) return;
            
            try {
                // Get feature importance data
                const chartData = extractFeatureImportanceData();
                if (!chartData || !chartData.features || chartData.features.length === 0) {
                    showNoDataMessage(chartContainer, "No feature importance data available");
                    return;
                }
                
                // Create chart
                renderImportanceComparisonChart(chartContainer, chartData);
            } catch (error) {
                console.error("Error initializing importance comparison:", error);
                showErrorMessage(chartContainer, "Error initializing importance comparison: " + error.message);
            }
        }
        
        // Extract feature importance data
        function extractFeatureImportanceData() {
            try {
                // Try to get data from various sources
                let featureImportance = {};
                let modelFeatureImportance = {};
                
                if (window.reportConfig && window.reportConfig.feature_importance) {
                    featureImportance = window.reportConfig.feature_importance || {};
                    modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                    console.log("Using feature importance from reportConfig");
                } 
                else if (window.reportData) {
                    if (window.reportData.feature_importance) {
                        featureImportance = window.reportData.feature_importance;
                        modelFeatureImportance = window.reportData.model_feature_importance || {};
                        console.log("Using feature importance from reportData");
                    }
                }
                
                // If no data is available, create demo data
                if (Object.keys(featureImportance).length === 0) {
                    featureImportance = {
                        'age': 0.4287,
                        'income': 0.3521,
                        'credit_score': 0.2943,
                        'employment_years': 0.2105,
                        'debt_ratio': 0.1876,
                        'num_loans': -0.1542,
                        'num_credit_lines': -0.1238,
                        'payment_history': 0.1105,
                        'loan_amount': -0.0956,
                        'interest_rate': 0.0847
                    };
                    
                    modelFeatureImportance = {
                        'age': 0.7648,
                        'income': 0.6892,
                        'credit_score': 0.5423,
                        'employment_years': 0.4936,
                        'debt_ratio': 0.4123,
                        'num_loans': 0.3856,
                        'num_credit_lines': 0.3421,
                        'payment_history': 0.3012,
                        'loan_amount': 0.2893,
                        'interest_rate': 0.2541
                    };
                }
                
                // Convert to arrays for plotting
                const featureArray = [];
                for (const feature in featureImportance) {
                    featureArray.push({
                        name: feature,
                        importance: featureImportance[feature],
                        modelImportance: modelFeatureImportance[feature] || 0
                    });
                }
                
                // Sort by absolute importance value
                featureArray.sort((a, b) => Math.abs(b.importance) - Math.abs(a.importance));
                
                // Get top features (up to 15)
                const topFeatures = featureArray.slice(0, 15);
                
                return {
                    features: topFeatures.map(f => f.name),
                    robustnessValues: topFeatures.map(f => f.importance),
                    modelValues: topFeatures.map(f => f.modelImportance),
                    allFeatures: featureArray
                };
            } catch (error) {
                console.error("Error extracting feature importance data:", error);
                return null;
            }
        }
        
        // Render feature importance chart
        function renderFeatureImportanceChart(container, chartData) {
            try {
                // Create traces for chart
                const traces = [
                    {
                        x: chartData.robustnessValues,
                        y: chartData.features,
                        name: 'Robustness Impact',
                        type: 'bar',
                        orientation: 'h',
                        marker: {
                            color: '#8884d8'
                        }
                    }
                ];
                
                // Add model importance if available
                if (chartData.modelValues && chartData.modelValues.some(v => v !== 0)) {
                    traces.push({
                        x: chartData.modelValues,
                        y: chartData.features,
                        name: 'Model Importance',
                        type: 'bar',
                        orientation: 'h',
                        marker: {
                            color: '#82ca9d'
                        }
                    });
                }
                
                // Layout
                const layout = {
                    title: 'Feature Importance',
                    xaxis: {
                        title: 'Importance Score'
                    },
                    yaxis: {
                        title: 'Feature',
                        automargin: true
                    },
                    barmode: 'group',
                    margin: {
                        l: 150,
                        r: 20,
                        t: 40,
                        b: 40
                    }
                };
                
                // Create plot
                Plotly.newPlot(container, traces, layout, {
                    responsive: true,
                    displayModeBar: false
                });
                
                console.log("Feature importance chart rendered successfully");
            } catch (error) {
                console.error("Error rendering feature importance chart:", error);
                showErrorMessage(container, "Error rendering chart: " + error.message);
            }
        }
        
        // Render importance comparison chart
        function renderImportanceComparisonChart(container, chartData) {
            try {
                // Pick top 10 features sorted by model importance
                const features = [...chartData.features].slice(0, 10);
                const robustnessValues = features.map(f => {
                    const index = chartData.features.indexOf(f);
                    return index >= 0 ? chartData.robustnessValues[index] : 0;
                });
                const modelValues = features.map(f => {
                    const index = chartData.features.indexOf(f);
                    return index >= 0 ? chartData.modelValues[index] : 0;
                });
                
                // Create trace for model importance
                const modelTrace = {
                    x: features,
                    y: modelValues,
                    name: 'Model Importance',
                    type: 'bar',
                    marker: {
                        color: 'rgba(89, 173, 106, 0.8)'
                    }
                };
                
                // Create trace for robustness impact
                const robustnessTrace = {
                    x: features,
                    y: robustnessValues,
                    name: 'Robustness Impact',
                    type: 'bar',
                    marker: {
                        color: 'rgba(93, 109, 235, 0.8)'
                    }
                };
                
                // Layout
                const layout = {
                    title: 'Model vs Robustness Importance',
                    barmode: 'group',
                    xaxis: {
                        title: 'Features',
                        tickangle: -45
                    },
                    yaxis: {
                        title: 'Importance Score'
                    },
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    },
                    margin: {
                        l: 50,
                        r: 20,
                        t: 40,
                        b: 120
                    }
                };
                
                // Create plot
                Plotly.newPlot(container, [modelTrace, robustnessTrace], layout, {
                    responsive: true,
                    displayModeBar: false
                });
                
                console.log("Importance comparison chart rendered successfully");
            } catch (error) {
                console.error("Error rendering importance comparison chart:", error);
                showErrorMessage(container, "Error rendering chart: " + error.message);
            }
        }
        
        // Initialize feature importance table
        function initializeFeatureImportanceTable() {
            try {
                // Get the table body
                const tableBody = document.getElementById('feature-impact-data');
                if (!tableBody) return;
                
                // Get feature importance data
                const chartData = extractFeatureImportanceData();
                if (!chartData || !chartData.allFeatures || chartData.allFeatures.length === 0) {
                    console.log("No feature data available for table");
                    return;
                }
                
                // Get feature subset
                let featureSubset = [];
                if (window.reportConfig && window.reportConfig.feature_subset) {
                    featureSubset = window.reportConfig.feature_subset;
                } else if (window.reportData && window.reportData.feature_subset) {
                    featureSubset = window.reportData.feature_subset;
                }
                
                // Clear existing rows 
                tableBody.innerHTML = '';
                
                // Add rows for each feature
                chartData.allFeatures.forEach(feature => {
                    const isInSubset = featureSubset.includes(feature.name);
                    
                    const row = document.createElement('tr');
                    row.className = isInSubset ? 'feature-subset-row' : '';
                    
                    // Feature name
                    const nameCell = document.createElement('td');
                    nameCell.textContent = feature.name;
                    row.appendChild(nameCell);
                    
                    // Robustness impact
                    const impactCell = document.createElement('td');
                    impactCell.textContent = feature.importance.toFixed(4);
                    row.appendChild(impactCell);
                    
                    // Model importance
                    const importanceCell = document.createElement('td');
                    importanceCell.textContent = feature.modelImportance.toFixed(4);
                    row.appendChild(importanceCell);
                    
                    // Feature subset status
                    const subsetCell = document.createElement('td');
                    const subsetBadge = document.createElement('span');
                    subsetBadge.className = `subset-badge ${isInSubset ? 'included' : 'excluded'}`;
                    subsetBadge.textContent = isInSubset ? 'Included' : 'Excluded';
                    subsetCell.appendChild(subsetBadge);
                    row.appendChild(subsetCell);
                    
                    tableBody.appendChild(row);
                });
                
                // Update feature counts
                const totalFeaturesCount = document.getElementById('total-features-count');
                if (totalFeaturesCount) {
                    totalFeaturesCount.textContent = chartData.allFeatures.length;
                }
                
                const subsetFeaturesCount = document.getElementById('subset-features-count');
                if (subsetFeaturesCount) {
                    subsetFeaturesCount.textContent = featureSubset.length;
                }
                
                console.log("Feature importance table initialized");
            } catch (error) {
                console.error("Error initializing feature importance table:", error);
            }
        }
        
        // Initialize feature event listeners
        function initializeFeatureEventListeners() {
            try {
                // Search input
                const searchInput = document.getElementById('feature-search');
                if (searchInput) {
                    searchInput.addEventListener('input', () => {
                        filterFeatures(searchInput.value);
                    });
                }
                
                // Show subset only toggle
                const subsetToggle = document.getElementById('show-subset-only');
                if (subsetToggle) {
                    subsetToggle.addEventListener('change', () => {
                        toggleSubsetOnly(subsetToggle.checked);
                    });
                }
                
                // Sortable column headers
                const sortableHeaders = document.querySelectorAll('.feature-importance-table th.sortable');
                sortableHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        sortFeatureTable(header.dataset.sort);
                    });
                });
                
                console.log("Feature event listeners initialized");
            } catch (error) {
                console.error("Error initializing feature event listeners:", error);
            }
        }
        
        // Filter features based on search
        function filterFeatures(searchText) {
            try {
                const rows = document.querySelectorAll('#feature-impact-data tr');
                const searchLower = searchText.toLowerCase();
                
                rows.forEach(row => {
                    const featureName = row.querySelector('td').textContent.toLowerCase();
                    
                    if (featureName.includes(searchLower)) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });
            } catch (error) {
                console.error("Error filtering features:", error);
            }
        }
        
        // Toggle showing only subset features
        function toggleSubsetOnly(showSubsetOnly) {
            try {
                const rows = document.querySelectorAll('#feature-impact-data tr');
                
                rows.forEach(row => {
                    if (showSubsetOnly && !row.classList.contains('feature-subset-row')) {
                        row.style.display = 'none';
                    } else {
                        row.style.display = '';
                    }
                });
            } catch (error) {
                console.error("Error toggling subset only:", error);
            }
        }
        
        // Sort feature table
        function sortFeatureTable(sortBy) {
            try {
                const table = document.querySelector('.feature-importance-table');
                const tableBody = document.getElementById('feature-impact-data');
                if (!table || !tableBody) return;
                
                // Update sort indicators
                const headers = table.querySelectorAll('th.sortable');
                headers.forEach(header => {
                    const indicator = header.querySelector('.sort-indicator');
                    if (header.dataset.sort === sortBy) {
                        if (indicator.textContent === '‚ñº') {
                            indicator.textContent = '‚ñ≤';
                        } else {
                            indicator.textContent = '‚ñº';
                        }
                    } else {
                        indicator.textContent = '';
                    }
                });
                
                // Get current sort direction
                const sortHeader = table.querySelector(`th[data-sort="${sortBy}"]`);
                const sortDirection = sortHeader.querySelector('.sort-indicator').textContent === '‚ñº' ? 'desc' : 'asc';
                
                // Get all rows as array for sorting
                const rows = Array.from(tableBody.querySelectorAll('tr'));
                
                // Sort rows based on column and direction
                rows.sort((rowA, rowB) => {
                    const cellA = rowA.querySelector(`td:nth-child(${getColumnIndex(sortBy)})`);
                    const cellB = rowB.querySelector(`td:nth-child(${getColumnIndex(sortBy)})`);
                    
                    let valueA, valueB;
                    
                    if (sortBy === 'name') {
                        valueA = cellA.textContent.toLowerCase();
                        valueB = cellB.textContent.toLowerCase();
                        return sortDirection === 'desc' 
                            ? valueA.localeCompare(valueB)
                            : valueB.localeCompare(valueA);
                    } else {
                        valueA = parseFloat(cellA.textContent);
                        valueB = parseFloat(cellB.textContent);
                        
                        if (sortBy === 'impact') {
                            // Sort by absolute value for impact
                            valueA = Math.abs(valueA);
                            valueB = Math.abs(valueB);
                        }
                        
                        return sortDirection === 'desc' 
                            ? valueB - valueA 
                            : valueA - valueB;
                    }
                });
                
                // Function to get column index based on sort key
                function getColumnIndex(key) {
                    switch (key) {
                        case 'name': return 1;
                        case 'impact': return 2;
                        case 'importance': return 3;
                        default: return 1;
                    }
                }
                
                // Reappend sorted rows
                rows.forEach(row => tableBody.appendChild(row));
            } catch (error) {
                console.error("Error sorting feature table:", error);
            }
        }
        
        // Show no data message
        function showNoDataMessage(container, message) {
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;">üìä</div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">No Data Available</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.4;">
                        ${message}
                    </p>
                </div>`;
        }
        
        // Show error message
        function showErrorMessage(container, errorMessage) {
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                </div>`;
        }
    </script>
    
    <!-- JavaScript syntax fixer for runtime fixes -->
    <script>
        // JavaScript Syntax Fixer
        (function() {
            // Fix trailing commas in JavaScript objects at runtime
            window.addEventListener('error', function(event) {
                if (event.error && event.error.toString().includes("Unexpected token")) {
                    console.warn("Caught syntax error:", event.error);
                    
                    // Prevent the error from propagating
                    event.preventDefault();
                }
            }, true);
        })();
    </script>
    
    <!-- Boxplot fix script is now included directly in combined JS content -->
</body>
</html>