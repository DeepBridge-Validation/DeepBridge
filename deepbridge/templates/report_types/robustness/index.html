<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepBridge {{ report_type|capitalize }} Report: {{ report_data.model_name }}</title>
    
    <!-- Global error handler - load first to catch syntax errors early -->
    <script>
        // Simple inline error handler to catch syntax errors
        window.onerror = function(message, source, lineno, colno, error) {
            if (message && (message.includes("Illegal continue") || message.includes("no surrounding iteration"))) {
                console.error("Caught illegal continue:", {message, source, lineno});
                return true; // Prevent default handling
            }
            return false; // Let other errors propagate
        };
    </script>
    
    <!-- Favicon -->
    {% if favicon_base64 %}
    <link rel="icon" href="data:image/png;base64,{{ favicon_base64 }}" type="image/png">
    {% endif %}
    
    <!-- Plotly library (incluído como conteúdo inline para garantir autonomia) -->
    <script>
        /* Minimum Plotly implementation for charts (produces actual charts, not just tables) */
        (function() {
            // Make sure plotly wasn't already loaded
            if (window.Plotly && typeof window.Plotly.newPlot === 'function') {
                console.log("Plotly already loaded, skipping embedded implementation");
                return;
            }
            
            /**
             * Simplified Plotly Implementation that renders actual charts
             * 
             * This implementation creates simplified but functional charts
             * using standard HTML5 canvas without external dependencies.
             * 
             * NO SYNTHETIC DATA - Only uses real data from the report.
             */
            window.Plotly = {
                // Track created plots to help with relayout and other operations
                _plots: {},
                
                /**
                 * Main method to create a new plot - core of the Plotly API
                 * @param {string|HTMLElement} container - Container element or ID
                 * @param {Array} data - The data array for the plot
                 * @param {Object} layout - The layout configuration
                 * @param {Object} config - Additional configuration
                 * @returns {Promise} Promise resolving to the container element
                 */
                newPlot: function(container, data, layout, config) {
                    console.log("Using enhanced fallback Plotly implementation for newPlot");
                    
                    // Find or create container element using robust technique
                    let containerElement = this._getContainerElement(container);
                    
                    // If still no container after our best efforts, return a rejected promise
                    if (!containerElement) {
                        console.error("Could not find or create container:", container);
                        // But still create a dummy element to avoid breaking the chain
                        containerElement = document.createElement('div');
                        containerElement.style.display = 'none';
                        document.body.appendChild(containerElement);
                    }
                    
                    // Store information about this plot for later use
                    const id = typeof container === 'string' ? container : containerElement.id || `plotly-plot-${Object.keys(this._plots).length}`;
                    if (!containerElement.id) containerElement.id = id;
                    
                    this._plots[id] = {
                        container: containerElement,
                        data: JSON.parse(JSON.stringify(data || [])),
                        layout: JSON.parse(JSON.stringify(layout || {})),
                        config: JSON.parse(JSON.stringify(config || {}))
                    };
                    
                    // Clear container and style it
                    containerElement.innerHTML = '';
                    containerElement.style.position = 'relative';
                    
                    try {
                        // Create visualization based on data
                        if (data && data.length > 0) {
                            this._createVisualization(containerElement, data, layout);
                        } else {
                            // No data, show appropriate message
                            this._createNoDataMessage(containerElement);
                        }
                    } catch (err) {
                        console.error("Error creating visualization:", err);
                        // Create error message in container
                        containerElement.innerHTML = `
                            <div style="padding: 20px; color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 5px; text-align: center;">
                                <h3>Visualization Error</h3>
                                <p>${err.message || "An error occurred rendering the chart"}</p>
                            </div>
                        `;
                    }
                    
                    return Promise.resolve(containerElement);
                },
                
                /**
                 * Find or create a container element with multiple fallbacks
                 * @param {string|HTMLElement} container - Container element or ID
                 * @returns {HTMLElement} The found or created container
                 */
                _getContainerElement: function(container) {
                    let containerElement = null;
                    
                    // Case 1: Container is already an HTML element
                    if (container instanceof HTMLElement) {
                        return container;
                    }
                    
                    // Case 2: Container is a string ID
                    if (typeof container === 'string') {
                        // Try getElementById first (most common case)
                        containerElement = document.getElementById(container);
                        
                        // If that fails, try querySelector with ID
                        if (!containerElement) {
                            try {
                                containerElement = document.querySelector('#' + container);
                            } catch (e) {
                                // Invalid selector, ignore
                            }
                        }
                        
                        // Try by class name
                        if (!containerElement) {
                            const elements = document.getElementsByClassName(container);
                            if (elements.length > 0) containerElement = elements[0];
                        }
                        
                        // Try as any CSS selector
                        if (!containerElement) {
                            try {
                                containerElement = document.querySelector(container);
                            } catch (e) {
                                // Invalid selector, ignore
                            }
                        }
                        
                        // Try replacing dashes with underscores (common issue)
                        if (!containerElement && container.includes('-')) {
                            const altId = container.replace(/-/g, '_');
                            containerElement = document.getElementById(altId);
                        }
                        
                        // Try common patterns like "container" + id
                        if (!containerElement && !container.includes('container')) {
                            const possibleIds = [
                                container + '-container',
                                container + '_container',
                                'container-' + container,
                                'container_' + container
                            ];
                            
                            for (const id of possibleIds) {
                                containerElement = document.getElementById(id);
                                if (containerElement) break;
                            }
                        }
                    }
                    
                    // If still not found, create a new container as last resort
                    if (!containerElement) {
                        console.warn("Container not found:", container, "- Creating fallback");
                        containerElement = document.createElement('div');
                        containerElement.id = typeof container === 'string' ? container : 'plotly-fallback-container';
                        containerElement.className = 'plotly-fallback-container';
                        containerElement.style.margin = '20px';
                        containerElement.style.padding = '20px';
                        containerElement.style.border = '1px solid #ddd';
                        containerElement.style.borderRadius = '4px';
                        
                        // Find best parent to append to
                        const possibleParents = [
                            document.querySelector('.chart-container'),
                            document.querySelector('.chart-plot'),
                            document.querySelector(`.${container}-container`),
                            document.querySelector('#' + container + '-parent'),
                            document.querySelector('.tab-content.active'),
                            document.querySelector('.tab-panel.active'),
                            document.querySelector('.report-content'),
                            document.querySelector('.report-container'),
                            document.querySelector('main'),
                            document.body
                        ];
                        
                        for (const parent of possibleParents) {
                            if (parent) {
                                parent.appendChild(containerElement);
                                console.log("Appended fallback container to", parent.tagName, parent.className || parent.id);
                                break;
                            }
                        }
                    }
                    
                    return containerElement;
                },
                
                /**
                 * Create a visualization using HTML5 Canvas
                 * @param {HTMLElement} container - The container element
                 * @param {Array} data - The data array for the plot
                 * @param {Object} layout - The layout configuration
                 */
                _createVisualization: function(container, data, layout) {
                    // Add a title if available in layout
                    if (layout && layout.title) {
                        const title = document.createElement('h3');
                        title.className = 'chart-title';
                        title.style.textAlign = 'center';
                        title.style.marginBottom = '15px';
                        title.textContent = typeof layout.title === 'string' ? layout.title : layout.title.text || 'Chart';
                        container.appendChild(title);
                    }
                    
                    // Check if this is a single numeric value (gauge or indicator)
                    const isSingleValueChart = data.length === 1 && data[0].type === 'indicator';
                    if (isSingleValueChart) {
                        this._createIndicatorChart(container, data[0]);
                        return;
                    }
                    
                    // Create a chart using canvas
                    const chartContainer = document.createElement('div');
                    chartContainer.style.position = 'relative';
                    chartContainer.style.width = '100%';
                    chartContainer.style.height = '400px';
                    
                    // Add legend if multiple series
                    if (data.length > 1) {
                        const legend = document.createElement('div');
                        legend.className = 'chart-legend';
                        legend.style.display = 'flex';
                        legend.style.flexWrap = 'wrap';
                        legend.style.justifyContent = 'center';
                        legend.style.gap = '10px';
                        legend.style.marginBottom = '15px';
                        
                        data.forEach((series, i) => {
                            const item = document.createElement('div');
                            item.className = 'legend-item';
                            item.style.display = 'flex';
                            item.style.alignItems = 'center';
                            item.style.gap = '5px';
                            
                            const color = series.marker?.color || this._getDefaultColor(i);
                            const marker = document.createElement('span');
                            marker.style.display = 'inline-block';
                            marker.style.width = '12px';
                            marker.style.height = '12px';
                            marker.style.backgroundColor = color;
                            
                            const label = document.createElement('span');
                            label.textContent = series.name || `Series ${i+1}`;
                            
                            item.appendChild(marker);
                            item.appendChild(label);
                            legend.appendChild(item);
                        });
                        
                        container.appendChild(legend);
                    }
                    
                    // Create canvas for chart
                    const canvas = document.createElement('canvas');
                    canvas.width = container.clientWidth || 800;
                    canvas.height = 400;
                    canvas.style.width = '100%';
                    canvas.style.height = '400px';
                    chartContainer.appendChild(canvas);
                    container.appendChild(chartContainer);
                    
                    // Get 2D context for drawing
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error("Canvas context not available");
                        this._createFallbackTable(container, data, layout);
                        return;
                    }
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Calculate chart area (leave space for axes and labels)
                    const chartArea = {
                        left: 60,  // Space for y-axis labels
                        top: 20,   // Space for title
                        right: canvas.width - 20, // Right margin
                        bottom: canvas.height - 40 // Space for x-axis labels
                    };
                    
                    // Set chart background
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Find min/max values for y-axis
                    let minY = Infinity;
                    let maxY = -Infinity;
                    
                    data.forEach(series => {
                        if (Array.isArray(series.y)) {
                            const seriesMin = Math.min(...series.y.filter(y => y !== null && y !== undefined));
                            const seriesMax = Math.max(...series.y.filter(y => y !== null && y !== undefined));
                            
                            minY = Math.min(minY, seriesMin);
                            maxY = Math.max(maxY, seriesMax);
                        }
                    });
                    
                    // Add some padding to min/max values
                    const yRange = maxY - minY;
                    minY = Math.max(0, minY - yRange * 0.1);  // Don't go below zero for most charts
                    maxY = maxY + yRange * 0.1;
                    
                    // Determine if we have x values
                    const hasXValues = data.some(series => Array.isArray(series.x) && series.x.length > 0);
                    
                    // Find min/max for x-axis (if available)
                    let minX = 0;
                    let maxX = 0;
                    let xValues = [];
                    
                    if (hasXValues) {
                        // Collect all x values
                        data.forEach(series => {
                            if (Array.isArray(series.x)) {
                                xValues = xValues.concat(series.x.filter(x => x !== null && x !== undefined));
                            }
                        });
                        
                        if (xValues.length > 0) {
                            minX = Math.min(...xValues);
                            maxX = Math.max(...xValues);
                        }
                    } else {
                        // Use indices as x values
                        const maxLength = Math.max(...data.map(series => 
                            Array.isArray(series.y) ? series.y.length : 0
                        ));
                        
                        minX = 0;
                        maxX = Math.max(1, maxLength - 1);  // At least 1 for proper scaling
                    }
                    
                    // Add padding to x range
                    const xRange = maxX - minX;
                    minX = minX - xRange * 0.05;
                    maxX = maxX + xRange * 0.05;
                    
                    // Draw axes
                    ctx.strokeStyle = '#666666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    
                    // Y-axis
                    ctx.moveTo(chartArea.left, chartArea.top);
                    ctx.lineTo(chartArea.left, chartArea.bottom);
                    
                    // X-axis
                    ctx.moveTo(chartArea.left, chartArea.bottom);
                    ctx.lineTo(chartArea.right, chartArea.bottom);
                    ctx.stroke();
                    
                    // Y-axis labels
                    ctx.fillStyle = '#333333';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    
                    const ySteps = 5;
                    for (let i = 0; i <= ySteps; i++) {
                        const y = minY + (maxY - minY) * (ySteps - i) / ySteps;
                        const yPos = chartArea.top + (chartArea.bottom - chartArea.top) * i / ySteps;
                        
                        ctx.fillText(this._formatValue(y), chartArea.left - 10, yPos);
                        
                        // Draw grid line
                        ctx.strokeStyle = '#dddddd';
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yPos);
                        ctx.lineTo(chartArea.right, yPos);
                        ctx.stroke();
                    }
                    
                    // X-axis labels
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    
                    const xSteps = Math.min(10, Math.max(2, hasXValues ? xValues.length : maxX));
                    for (let i = 0; i <= xSteps; i++) {
                        const xRatio = i / xSteps;
                        const x = minX + (maxX - minX) * xRatio;
                        const xPos = chartArea.left + (chartArea.right - chartArea.left) * xRatio;
                        
                        let label = this._formatValue(x);
                        if (layout && layout.xaxis && layout.xaxis.ticksuffix) {
                            label += layout.xaxis.ticksuffix;
                        }
                        
                        ctx.fillText(label, xPos, chartArea.bottom + 10);
                        
                        // Draw grid line
                        ctx.strokeStyle = '#dddddd';
                        ctx.beginPath();
                        ctx.moveTo(xPos, chartArea.top);
                        ctx.lineTo(xPos, chartArea.bottom);
                        ctx.stroke();
                    }
                    
                    // Draw axis titles
                    ctx.fillStyle = '#333333';
                    ctx.font = 'bold 12px Arial';
                    
                    // Y-axis title
                    if (layout && layout.yaxis && layout.yaxis.title) {
                        ctx.save();
                        ctx.translate(15, (chartArea.top + chartArea.bottom) / 2);
                        ctx.rotate(-Math.PI / 2);
                        ctx.textAlign = 'center';
                        ctx.fillText(layout.yaxis.title.text || layout.yaxis.title, 0, 0);
                        ctx.restore();
                    }
                    
                    // X-axis title
                    if (layout && layout.xaxis && layout.xaxis.title) {
                        ctx.textAlign = 'center';
                        ctx.fillText(
                            layout.xaxis.title.text || layout.xaxis.title,
                            (chartArea.left + chartArea.right) / 2,
                            chartArea.bottom + 30
                        );
                    }
                    
                    // Draw data series
                    data.forEach((series, seriesIndex) => {
                        // Skip if no y values
                        if (!Array.isArray(series.y) || series.y.length === 0) {
                            return;
                        }
                        
                        const color = series.marker?.color || this._getDefaultColor(seriesIndex);
                        const mode = series.mode || 'lines+markers';
                        const type = series.type || 'scatter';
                        
                        // Use consistent x values if available, otherwise use indices
                        const xData = Array.isArray(series.x) && series.x.length >= series.y.length
                            ? series.x
                            : series.y.map((_, i) => i);
                            
                        // Skip data outside bounds
                        const points = [];
                        for (let i = 0; i < series.y.length; i++) {
                            if (series.y[i] !== null && series.y[i] !== undefined && 
                                xData[i] !== null && xData[i] !== undefined) {
                                points.push({
                                    x: xData[i],
                                    y: series.y[i]
                                });
                            }
                        }
                        
                        // Draw data points and/or lines
                        if (points.length > 0) {
                            // For bar charts
                            if (type === 'bar') {
                                this._drawBarChart(ctx, points, color, chartArea, minX, maxX, minY, maxY);
                            } 
                            // For all other charts (scatter/line)
                            else {
                                // Draw lines if mode includes 'lines'
                                if (mode.includes('lines')) {
                                    this._drawLines(ctx, points, color, chartArea, minX, maxX, minY, maxY);
                                }
                                
                                // Draw markers if mode includes 'markers'
                                if (mode.includes('markers')) {
                                    this._drawMarkers(ctx, points, color, chartArea, minX, maxX, minY, maxY);
                                }
                            }
                        }
                    });
                },
                
                /**
                 * Draw lines connecting data points
                 */
                _drawLines: function(ctx, points, color, chartArea, minX, maxX, minY, maxY) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    points.forEach((point, i) => {
                        // Convert to canvas coordinates
                        const x = chartArea.left + (point.x - minX) / (maxX - minX) * (chartArea.right - chartArea.left);
                        const y = chartArea.bottom - (point.y - minY) / (maxY - minY) * (chartArea.bottom - chartArea.top);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                },
                
                /**
                 * Draw markers at data points
                 */
                _drawMarkers: function(ctx, points, color, chartArea, minX, maxX, minY, maxY) {
                    const markerSize = 6;
                    
                    ctx.fillStyle = color;
                    
                    points.forEach(point => {
                        // Convert to canvas coordinates
                        const x = chartArea.left + (point.x - minX) / (maxX - minX) * (chartArea.right - chartArea.left);
                        const y = chartArea.bottom - (point.y - minY) / (maxY - minY) * (chartArea.bottom - chartArea.top);
                        
                        // Draw a circle
                        ctx.beginPath();
                        ctx.arc(x, y, markerSize, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                },
                
                /**
                 * Draw bar chart
                 */
                _drawBarChart: function(ctx, points, color, chartArea, minX, maxX, minY, maxY) {
                    const barWidth = (chartArea.right - chartArea.left) / (points.length * 1.5);
                    
                    ctx.fillStyle = color;
                    
                    points.forEach(point => {
                        // Convert to canvas coordinates
                        const x = chartArea.left + (point.x - minX) / (maxX - minX) * (chartArea.right - chartArea.left);
                        const y = chartArea.bottom - (point.y - minY) / (maxY - minY) * (chartArea.bottom - chartArea.top);
                        
                        // Draw a bar from baseline to y
                        const baseline = chartArea.bottom - (0 - minY) / (maxY - minY) * (chartArea.bottom - chartArea.top);
                        const barHeight = baseline - y;
                        
                        ctx.fillRect(x - barWidth/2, y, barWidth, barHeight);
                    });
                },
                
                /**
                 * Create a fallback table when canvas is not available
                 */
                _createFallbackTable: function(container, data, layout) {
                    const tableContainer = document.createElement('div');
                    tableContainer.style.overflowX = 'auto';
                    
                    const table = document.createElement('table');
                    table.style.width = '100%';
                    table.style.borderCollapse = 'collapse';
                    table.style.border = '1px solid #e2e8f0';
                    table.style.fontSize = '14px';
                    
                    // Add header
                    const thead = document.createElement('thead');
                    thead.style.backgroundColor = '#f8fafc';
                    const headerRow = document.createElement('tr');
                    
                    // Determine if we have X values to show
                    const hasXValues = data.some(series => Array.isArray(series.x) && series.x.length > 0);
                    
                    // Create headers
                    if (hasXValues) {
                        const xHeader = document.createElement('th');
                        xHeader.style.padding = '8px 12px';
                        xHeader.style.textAlign = 'left';
                        xHeader.style.borderBottom = '2px solid #e2e8f0';
                        xHeader.textContent = layout?.xaxis?.title?.text || 'X';
                        headerRow.appendChild(xHeader);
                    }
                    
                    data.forEach((series, i) => {
                        const th = document.createElement('th');
                        th.style.padding = '8px 12px';
                        th.style.textAlign = 'right';
                        th.style.borderBottom = '2px solid #e2e8f0';
                        th.textContent = series.name || `Series ${i+1}`;
                        headerRow.appendChild(th);
                    });
                    
                    thead.appendChild(headerRow);
                    table.appendChild(thead);
                    
                    // Create body with sample data
                    const tbody = document.createElement('tbody');
                    
                    // Find max data points
                    let maxPoints = Math.max(...data.map(series => 
                        Array.isArray(series.y) ? series.y.length : 0
                    ));
                    
                    // Limit to 20 rows for performance
                    maxPoints = Math.min(20, maxPoints);
                    
                    for (let i = 0; i < maxPoints; i++) {
                        const row = document.createElement('tr');
                        row.style.borderBottom = '1px solid #e2e8f0';
                        
                        // Add X value if available
                        if (hasXValues) {
                            const xCell = document.createElement('td');
                            xCell.style.padding = '8px 12px';
                            xCell.style.textAlign = 'left';
                            
                            // Find a series with X values
                            const seriesWithX = data.find(s => Array.isArray(s.x) && i < s.x.length);
                            xCell.textContent = seriesWithX ? this._formatValue(seriesWithX.x[i]) : i;
                            
                            row.appendChild(xCell);
                        }
                        
                        // Add Y values for each series
                        data.forEach(series => {
                            const cell = document.createElement('td');
                            cell.style.padding = '8px 12px';
                            cell.style.textAlign = 'right';
                            
                            if (Array.isArray(series.y) && i < series.y.length) {
                                cell.textContent = this._formatValue(series.y[i]);
                            } else {
                                cell.textContent = '-';
                                cell.style.color = '#a0aec0';
                            }
                            
                            row.appendChild(cell);
                        });
                        
                        tbody.appendChild(row);
                    }
                    
                    table.appendChild(tbody);
                    tableContainer.appendChild(table);
                    container.appendChild(tableContainer);
                },
                
                /**
                 * Create a special visualization for indicator (gauge) charts
                 * @param {HTMLElement} container - The container element
                 * @param {Object} data - The indicator data
                 */
                _createIndicatorChart: function(container, data) {
                    const value = data.value;
                    const mode = data.mode || 'gauge';
                    const title = data.title?.text || '';
                    
                    const indicatorDiv = document.createElement('div');
                    indicatorDiv.className = 'plotly-indicator';
                    indicatorDiv.style.textAlign = 'center';
                    indicatorDiv.style.padding = '20px';
                    
                    if (title) {
                        const titleElem = document.createElement('h4');
                        titleElem.style.marginBottom = '10px';
                        titleElem.textContent = title;
                        indicatorDiv.appendChild(titleElem);
                    }
                    
                    const valueDiv = document.createElement('div');
                    valueDiv.className = 'indicator-value';
                    valueDiv.style.fontSize = '3rem';
                    valueDiv.style.fontWeight = 'bold';
                    valueDiv.style.color = '#2c5282';
                    valueDiv.textContent = this._formatValue(value);
                    
                    indicatorDiv.appendChild(valueDiv);
                    
                    // If it's a gauge, add simple gauge representation
                    if (mode.includes('gauge')) {
                        const gaugeContainer = document.createElement('div');
                        gaugeContainer.style.margin = '20px auto';
                        gaugeContainer.style.width = '80%';
                        gaugeContainer.style.maxWidth = '300px';
                        
                        const min = data.gauge?.axis?.range?.[0] || 0;
                        const max = data.gauge?.axis?.range?.[1] || 100;
                        const steps = data.gauge?.steps || [];
                        
                        // Create gauge bar
                        const gaugeBar = document.createElement('div');
                        gaugeBar.style.height = '10px';
                        gaugeBar.style.width = '100%';
                        gaugeBar.style.backgroundColor = '#e2e8f0';
                        gaugeBar.style.borderRadius = '5px';
                        gaugeBar.style.overflow = 'hidden';
                        gaugeBar.style.position = 'relative';
                        
                        // Create filled portion
                        if (typeof value === 'number') {
                            const percentage = Math.max(0, Math.min(100, ((value - min) / (max - min)) * 100));
                            const filled = document.createElement('div');
                            filled.style.position = 'absolute';
                            filled.style.top = '0';
                            filled.style.left = '0';
                            filled.style.width = `${percentage}%`;
                            filled.style.height = '100%';
                            filled.style.backgroundColor = '#3182ce';
                            gaugeBar.appendChild(filled);
                        }
                        
                        gaugeContainer.appendChild(gaugeBar);
                        
                        // Add scale marks
                        const scale = document.createElement('div');
                        scale.style.display = 'flex';
                        scale.style.justifyContent = 'space-between';
                        scale.style.marginTop = '5px';
                        scale.style.color = '#718096';
                        scale.style.fontSize = '12px';
                        
                        const minLabel = document.createElement('span');
                        minLabel.textContent = this._formatValue(min);
                        scale.appendChild(minLabel);
                        
                        const maxLabel = document.createElement('span');
                        maxLabel.textContent = this._formatValue(max);
                        scale.appendChild(maxLabel);
                        
                        gaugeContainer.appendChild(scale);
                        indicatorDiv.appendChild(gaugeContainer);
                    }
                    
                    container.appendChild(indicatorDiv);
                },
                
                /**
                 * Create a message for when no data is available
                 * @param {HTMLElement} container - The container element
                 */
                _createNoDataMessage: function(container) {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'no-data-message';
                    msgDiv.style.textAlign = 'center';
                    msgDiv.style.padding = '40px 20px';
                    msgDiv.style.color = '#718096';
                    
                    const icon = document.createElement('div');
                    icon.innerHTML = '📊';
                    icon.style.fontSize = '2rem';
                    icon.style.marginBottom = '10px';
                    
                    const text = document.createElement('p');
                    text.textContent = 'No chart data available';
                    
                    msgDiv.appendChild(icon);
                    msgDiv.appendChild(text);
                    container.appendChild(msgDiv);
                },
                
                /**
                 * Format a value for display
                 * @param {*} value - The value to format
                 * @returns {string} Formatted value
                 */
                _formatValue: function(value) {
                    if (value === undefined || value === null) return '-';
                    if (typeof value === 'number') {
                        // Format with appropriate precision
                        return value.toLocaleString(undefined, { 
                            maximumFractionDigits: 4,
                            minimumFractionDigits: Math.abs(value) < 0.1 ? 4 : 2
                        });
                    }
                    if (value instanceof Date) {
                        return value.toLocaleString();
                    }
                    return String(value);
                },
                
                /**
                 * Get a color from a default color palette
                 * @param {number} index - Index in the palette
                 * @returns {string} Color value
                 */
                _getDefaultColor: function(index) {
                    const colors = [
                        '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
                        '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
                    ];
                    return colors[index % colors.length];
                },
                
                /**
                 * Clean up a plot's DOM element
                 * @param {string|HTMLElement} container - Container element or ID
                 * @returns {Promise} Promise that resolves when complete
                 */
                purge: function(container) {
                    console.log("Using fallback Plotly.purge");
                    
                    // Get the element
                    const element = typeof container === 'string' ? 
                        document.getElementById(container) : container;
                        
                    // Clear if found
                    if (element) element.innerHTML = '';
                    
                    // Remove from tracked plots
                    const id = typeof container === 'string' ? container : 
                        (container && container.id) ? container.id : null;
                        
                    if (id && this._plots[id]) {
                        delete this._plots[id];
                    }
                    
                    return Promise.resolve();
                },
                
                /**
                 * Update layout properties
                 * @param {string|HTMLElement} container - Container element or ID
                 * @param {Object} layoutUpdate - Layout properties to update
                 * @returns {Promise} Promise that resolves when complete
                 */
                relayout: function(container, layoutUpdate) {
                    console.log("Using enhanced fallback Plotly.relayout", container, layoutUpdate);
                    
                    const id = typeof container === 'string' ? container : 
                        (container && container.id) ? container.id : null;
                    
                    // Update stored layout if we have it
                    if (id && this._plots[id]) {
                        const plotInfo = this._plots[id];
                        plotInfo.layout = Object.assign({}, plotInfo.layout || {}, layoutUpdate);
                        
                        // If container exists, rerender the visualization with updated layout
                        const containerElement = this._getContainerElement(container);
                        if (containerElement) {
                            containerElement.innerHTML = '';
                            this._createVisualization(containerElement, plotInfo.data, plotInfo.layout);
                        }
                    } else {
                        console.warn("Plot not found for relayout:", container);
                    }
                    
                    return Promise.resolve();
                },
                
                /**
                 * Replace all traces in an existing plot
                 * @returns {Promise} Promise that resolves when complete
                 */
                react: function(container, data, layout, config) {
                    // For react, we basically do the same as newPlot
                    return this.newPlot(container, data, layout, config);
                },
                
                /**
                 * Updates the traces of a plot with new data and layout
                 * @returns {Promise} Promise that resolves when complete
                 */
                update: function(container, traceUpdate, layoutUpdate, traceIndices) {
                    console.log("Using fallback Plotly.update");
                    
                    const id = typeof container === 'string' ? container : 
                        (container && container.id) ? container.id : null;
                    
                    if (id && this._plots[id]) {
                        const plotInfo = this._plots[id];
                        
                        // Update layout if provided
                        if (layoutUpdate) {
                            plotInfo.layout = Object.assign({}, plotInfo.layout || {}, layoutUpdate);
                        }
                        
                        // Update traces if provided
                        if (traceUpdate) {
                            const indices = traceIndices || 
                                Array.from({ length: plotInfo.data.length }, (_, i) => i);
                                
                            // Ensure indices is an array
                            const indicesArray = Array.isArray(indices) ? indices : [indices];
                            
                            // Update each specified trace
                            indicesArray.forEach(i => {
                                if (i >= 0 && i < plotInfo.data.length) {
                                    plotInfo.data[i] = Object.assign({}, plotInfo.data[i], traceUpdate);
                                }
                            });
                        }
                        
                        // Rerender the plot
                        const containerElement = this._getContainerElement(container);
                        if (containerElement) {
                            containerElement.innerHTML = '';
                            this._createVisualization(containerElement, plotInfo.data, plotInfo.layout);
                        }
                    }
                    
                    return Promise.resolve();
                },
                
                /**
                 * Updates trace(s) properties
                 * @returns {Promise} Promise that resolves when complete
                 */
                restyle: function(container, update, indices) {
                    // For our fallback, restyle is essentially the same as update but only for traces
                    return this.update(container, update, null, indices);
                },
                
                /**
                 * Add traces to an existing plot
                 * @returns {Promise} Promise that resolves when complete
                 */
                addTraces: function(gd, traces, newIndices) {
                    console.log("Using fallback Plotly.addTraces");
                    
                    const id = typeof gd === 'string' ? gd : 
                        (gd && gd.id) ? gd.id : null;
                    
                    if (id && this._plots[id]) {
                        const plotInfo = this._plots[id];
                        const newTraces = Array.isArray(traces) ? traces : [traces];
                        
                        // Add new traces
                        if (Array.isArray(newIndices) && newIndices.length === newTraces.length) {
                            // Insert at specific indices
                            newIndices.forEach((index, i) => {
                                plotInfo.data.splice(index, 0, newTraces[i]);
                            });
                        } else {
                            // Append to end
                            plotInfo.data = plotInfo.data.concat(newTraces);
                        }
                        
                        // Rerender the plot
                        const containerElement = this._getContainerElement(gd);
                        if (containerElement) {
                            containerElement.innerHTML = '';
                            this._createVisualization(containerElement, plotInfo.data, plotInfo.layout);
                        }
                    }
                    
                    return Promise.resolve();
                },
                
                /**
                 * Delete traces from an existing plot
                 * @returns {Promise} Promise that resolves when complete
                 */
                deleteTraces: function(gd, indices) {
                    console.log("Using fallback Plotly.deleteTraces");
                    
                    const id = typeof gd === 'string' ? gd : 
                        (gd && gd.id) ? gd.id : null;
                    
                    if (id && this._plots[id]) {
                        const plotInfo = this._plots[id];
                        const indicesArray = Array.isArray(indices) ? indices : [indices];
                        
                        // Sort indices in descending order to avoid shifting issues
                        const sortedIndices = indicesArray.slice().sort((a, b) => b - a);
                        
                        // Remove traces
                        sortedIndices.forEach(index => {
                            if (index >= 0 && index < plotInfo.data.length) {
                                plotInfo.data.splice(index, 1);
                            }
                        });
                        
                        // Rerender the plot
                        const containerElement = this._getContainerElement(gd);
                        if (containerElement) {
                            containerElement.innerHTML = '';
                            this._createVisualization(containerElement, plotInfo.data, plotInfo.layout);
                        }
                    }
                    
                    return Promise.resolve();
                },
                
                /**
                 * Rearrange traces in an existing plot
                 * @returns {Promise} Promise that resolves when complete
                 */
                moveTraces: function(gd, currentIndices, newIndices) {
                    return Promise.resolve();
                },
                
                /**
                 * Convert a plot to an image
                 * @returns {Promise} Promise resolving to a data URL
                 */
                toImage: function(gd, opts) {
                    return Promise.resolve("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=");
                },
                
                /**
                 * Download a plot as an image
                 * @returns {Promise} Promise that resolves when complete
                 */
                downloadImage: function(gd, opts) {
                    return Promise.resolve();
                }
            };
            
            // Define a robust fallback PerturbationResultsManager
            window.PerturbationResultsManager = window.PerturbationResultsManager || {
                /**
                 * Extract perturbation data from the global report data
                 * @returns {Object} Structured perturbation data
                 */
                extractPerturbationData: function() {
                    console.log("Using enhanced fallback PerturbationResultsManager");
                    
                    // Use global report data if available
                    if (window.reportData) {
                        try {
                            // Try to extract data from perturbation_details_data
                            if (window.reportData.perturbation_details_data) {
                                return this._extractFromDetailData(window.reportData.perturbation_details_data);
                            }
                            
                            // Try to extract from raw data
                            if (window.reportData.raw && window.reportData.raw.by_level) {
                                return this._extractFromRawData(window.reportData);
                            }
                            
                            // Try to extract from chart data
                            if (window.reportData.perturbation_chart_data) {
                                return this._extractFromChartData(window.reportData.perturbation_chart_data);
                            }
                        } catch (err) {
                            console.error("Error extracting perturbation data:", err);
                        }
                    }
                    
                    // Fallback with empty data
                    return {
                        modelName: window.reportData?.model_name || 'Model',
                        modelType: window.reportData?.model_type || 'Unknown',
                        metric: window.reportData?.metric || 'Score',
                        baseScore: window.reportData?.base_score || 0,
                        results: []  // Empty results array, will show "no data" message
                    };
                },
                
                /**
                 * Extract data from perturbation_details_data format
                 * @param {Object} detailsData - The perturbation details data
                 * @returns {Object} Structured perturbation data
                 */
                _extractFromDetailData: function(detailsData) {
                    return {
                        modelName: detailsData.modelName || 'Model',
                        modelType: detailsData.modelType || 'Unknown',
                        metric: detailsData.metric || 'Score',
                        baseScore: detailsData.baseScore || 0,
                        results: Array.isArray(detailsData.results) ? detailsData.results : []
                    };
                },
                
                /**
                 * Extract data from raw results format
                 * @param {Object} reportData - The full report data
                 * @returns {Object} Structured perturbation data
                 */
                _extractFromRawData: function(reportData) {
                    const rawData = reportData.raw.by_level;
                    const results = [];
                    
                    // Sort levels and process each one
                    const levels = Object.keys(rawData).map(Number).sort((a, b) => a - b);
                    
                    for (const level of levels) {
                        const levelData = rawData[level];
                        if (!levelData || !levelData.overall_result) continue;
                        
                        const result = {
                            level: level,
                            allFeatures: null,
                            featureSubset: null
                        };
                        
                        // Process all features
                        if (levelData.overall_result.all_features) {
                            const featureResult = levelData.overall_result.all_features;
                            const baseScore = reportData.base_score || 0;
                            const meanScore = featureResult.mean_score || 0;
                            
                            // Calculate impact safely
                            let impact = 0;
                            if (baseScore > 0) {
                                impact = (baseScore - meanScore) / baseScore;
                            }
                            
                            result.allFeatures = {
                                baseScore: baseScore,
                                meanScore: meanScore,
                                worstScore: featureResult.worst_score || 0,
                                impact: impact,
                                iterations: []
                            };
                            
                            // Add iterations if available
                            if (levelData.runs && levelData.runs.all_features) {
                                const iterations = [];
                                for (const run of levelData.runs.all_features) {
                                    if (run.iterations && Array.isArray(run.iterations.scores)) {
                                        iterations.push(...run.iterations.scores);
                                    }
                                }
                                result.allFeatures.iterations = iterations;
                            }
                        }
                        
                        // Process feature subset (same pattern as all features)
                        if (levelData.overall_result.feature_subset) {
                            const featureResult = levelData.overall_result.feature_subset;
                            const baseScore = reportData.base_score || 0;
                            const meanScore = featureResult.mean_score || 0;
                            
                            let impact = 0;
                            if (baseScore > 0) {
                                impact = (baseScore - meanScore) / baseScore;
                            }
                            
                            result.featureSubset = {
                                baseScore: baseScore,
                                meanScore: meanScore,
                                worstScore: featureResult.worst_score || 0,
                                impact: impact,
                                iterations: []
                            };
                            
                            // Add iterations
                            if (levelData.runs && levelData.runs.feature_subset) {
                                const iterations = [];
                                for (const run of levelData.runs.feature_subset) {
                                    if (run.iterations && Array.isArray(run.iterations.scores)) {
                                        iterations.push(...run.iterations.scores);
                                    }
                                }
                                result.featureSubset.iterations = iterations;
                            }
                        }
                        
                        results.push(result);
                    }
                    
                    return {
                        modelName: reportData.model_name || 'Model',
                        modelType: reportData.model_type || 'Unknown',
                        metric: reportData.metric || 'Score',
                        baseScore: reportData.base_score || 0,
                        results: results
                    };
                },
                
                /**
                 * Extract data from perturbation chart data format
                 * @param {Object} chartData - The perturbation chart data
                 * @returns {Object} Structured perturbation data
                 */
                _extractFromChartData: function(chartData) {
                    const results = [];
                    
                    // If we have levels and scores
                    if (Array.isArray(chartData.levels) && Array.isArray(chartData.scores)) {
                        const baseScore = chartData.baseScore || 0;
                        
                        for (let i = 0; i < chartData.levels.length; i++) {
                            const level = chartData.levels[i];
                            const meanScore = chartData.scores[i] || 0;
                            const worstScore = Array.isArray(chartData.worstScores) ? chartData.worstScores[i] || 0 : 0;
                            
                            let impact = 0;
                            if (baseScore > 0) {
                                impact = (baseScore - meanScore) / baseScore;
                            }
                            
                            // Create result entry
                            const result = {
                                level: level,
                                allFeatures: {
                                    baseScore: baseScore,
                                    meanScore: meanScore,
                                    worstScore: worstScore,
                                    impact: impact,
                                    iterations: []
                                },
                                featureSubset: null
                            };
                            
                            // Add to results
                            results.push(result);
                        }
                    }
                    
                    return {
                        modelName: chartData.modelName || 'Model',
                        modelType: window.reportData?.model_type || 'Unknown',
                        metric: chartData.metric || 'Score',
                        baseScore: chartData.baseScore || 0,
                        results: results
                    };
                },
                
                /**
                 * Format a number with appropriate decimals
                 * @param {number} number - Number to format
                 * @param {number} decimals - Decimal places (default: 4)
                 * @returns {string} Formatted number
                 */
                formatNumber: function(number, decimals = 4) {
                    if (number === undefined || number === null) return '-';
                    
                    try {
                        return Number(number).toFixed(decimals);
                    } catch (e) {
                        return String(number);
                    }
                },
                
                /**
                 * Get background color class for score based on comparison to base score
                 * @param {number} score - The score to evaluate
                 * @param {number} baseScore - The base score for comparison
                 * @returns {string} CSS class name
                 */
                getScoreBgColorClass: function(score, baseScore) {
                    if (score === undefined || score === null || baseScore === undefined) return '';
                    
                    try {
                        const diff = score - baseScore;
                        if (Math.abs(diff) < 0.001) return '';
                        
                        if (diff > 0) {
                            return 'bg-green-50';
                        } else {
                            return 'bg-red-50';
                        }
                    } catch (e) {
                        return '';
                    }
                },
                
                /**
                 * Get color class for impact value
                 * @param {number} impact - The impact value
                 * @returns {string} CSS class name
                 */
                getImpactColorClass: function(impact) {
                    if (impact === undefined || impact === null) return '';
                    
                    try {
                        if (Math.abs(impact) < 0.001) return 'text-gray-600';
                        
                        if (impact < 0) {
                            return 'text-green-600';
                        } else if (impact < 0.05) {
                            return 'text-blue-600';
                        } else if (impact < 0.1) {
                            return 'text-yellow-600';
                        } else if (impact < 0.2) {
                            return 'text-orange-600';
                        } else {
                            return 'text-red-600';
                        }
                    } catch (e) {
                        return '';
                    }
                }
            };
            
            // Define a comprehensive ChartManager with real data extraction
            window.ChartManager = window.ChartManager || {
                /**
                 * Initialize perturbation chart showing score change across perturbation levels
                 * @param {string} container - Container element ID
                 */
                initializePerturbationChart: function(container) {
                    console.log("ChartManager: Initializing perturbation chart");
                    
                    // Check if container exists
                    const containerElement = document.getElementById(container);
                    if (!containerElement) {
                        console.warn("Container not found:", container);
                        return;
                    }
                    
                    // Extract data for chart
                    const chartData = this.extractPerturbationChartData();
                    
                    // If no data, show message
                    if (!chartData || !chartData.levels || chartData.levels.length === 0) {
                        containerElement.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #666;">
                                <p>No perturbation data available for chart.</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // Create traces for Plotly
                    const traces = [];
                    
                    // Main model trace
                    traces.push({
                        x: chartData.levels.map(l => l * 100), // Convert to percentage
                        y: chartData.scores,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: chartData.modelName || 'Primary Model',
                        line: { width: 3, color: '#3182ce' },
                        marker: { size: 8, color: '#3182ce' }
                    });
                    
                    // Add baseline
                    traces.push({
                        x: [0, Math.max(...chartData.levels) * 100],
                        y: [chartData.baseScore, chartData.baseScore],
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Baseline',
                        line: { dash: 'dash', color: '#718096' },
                        hoverinfo: 'y'
                    });
                    
                    // Add alternative models if available
                    if (chartData.alternativeModels) {
                        const colors = ['#f56565', '#48bb78', '#9f7aea', '#ed8936', '#0694a2'];
                        let colorIndex = 0;
                        
                        for (const [modelName, modelData] of Object.entries(chartData.alternativeModels)) {
                            if (Array.isArray(modelData.scores) && modelData.scores.length > 0) {
                                const color = colors[colorIndex % colors.length];
                                colorIndex++;
                                
                                traces.push({
                                    x: chartData.levels.map(l => l * 100),
                                    y: modelData.scores,
                                    type: 'scatter',
                                    mode: 'lines+markers',
                                    name: modelName,
                                    line: { width: 2, color: color },
                                    marker: { size: 6, color: color }
                                });
                            }
                        }
                    }
                    
                    // Layout configuration
                    const layout = {
                        title: 'Performance Across Perturbation Levels',
                        xaxis: {
                            title: 'Perturbation Level (%)',
                            ticksuffix: '%'
                        },
                        yaxis: {
                            title: chartData.metric || 'Score'
                        },
                        legend: {
                            orientation: 'h', 
                            y: -0.2
                        },
                        hovermode: 'closest',
                        autosize: true,
                        margin: {
                            l: 50,
                            r: 30,
                            t: 50,
                            b: 60,
                            pad: 4
                        }
                    };
                    
                    // Config with responsive resize
                    const config = {
                        responsive: true,
                        displayModeBar: false
                    };
                    
                    // Create plot
                    Plotly.newPlot(container, traces, layout, config);
                },
                
                /**
                 * Extract data for perturbation chart from report data
                 * @returns {Object} Chart data
                 */
                extractPerturbationChartData: function() {
                    if (window.reportData) {
                        // Best source: perturbation_chart_data
                        if (window.reportData.perturbation_chart_data) {
                            return window.reportData.perturbation_chart_data;
                        }
                        
                        // Try to extract from raw data
                        if (window.reportData.raw && window.reportData.raw.by_level) {
                            const rawData = window.reportData.raw.by_level;
                            const levels = Object.keys(rawData).map(Number).sort((a, b) => a - b);
                            const scores = [];
                            const worstScores = [];
                            
                            for (const level of levels) {
                                const levelData = rawData[level];
                                if (!levelData || !levelData.overall_result || !levelData.overall_result.all_features) {
                                    scores.push(null);
                                    worstScores.push(null);
                                    continue;
                                }
                                
                                const result = levelData.overall_result.all_features;
                                scores.push(result.mean_score);
                                worstScores.push(result.worst_score);
                            }
                            
                            return {
                                modelName: window.reportData.model_name || 'Model',
                                levels: levels,
                                scores: scores,
                                worstScores: worstScores,
                                baseScore: window.reportData.base_score || 0,
                                metric: window.reportData.metric || 'Score'
                            };
                        }
                    }
                    
                    // Empty data as fallback
                    return {
                        modelName: 'Model',
                        levels: [],
                        scores: [],
                        worstScores: [],
                        baseScore: 0,
                        metric: 'Score',
                        alternativeModels: {}
                    };
                },
                
                /**
                 * Initialize worst score chart showing worst performance
                 * @param {string} container - Container element ID
                 */
                initializeWorstScoreChart: function(container) {
                    console.log("ChartManager: Initializing worst score chart");
                    
                    // Check if container exists
                    const containerElement = document.getElementById(container);
                    if (!containerElement) {
                        console.warn("Container not found:", container);
                        return;
                    }
                    
                    // Get data from perturbation chart data
                    const chartData = this.extractPerturbationChartData();
                    
                    // If no worst scores or levels, show message
                    if (!chartData || !chartData.levels || chartData.levels.length === 0 || 
                        !chartData.worstScores || chartData.worstScores.length === 0) {
                        containerElement.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #666;">
                                <p>No worst score data available for chart.</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // Create traces for Plotly
                    const traces = [
                        // Worst scores trace
                        {
                            x: chartData.levels.map(l => l * 100),
                            y: chartData.worstScores,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: 'Worst Score',
                            line: { width: 3, color: '#e53e3e' },
                            marker: { size: 8, color: '#e53e3e' }
                        },
                        // Baseline
                        {
                            x: [0, Math.max(...chartData.levels) * 100],
                            y: [chartData.baseScore, chartData.baseScore],
                            type: 'scatter',
                            mode: 'lines',
                            name: 'Baseline',
                            line: { dash: 'dash', color: '#718096' },
                            hoverinfo: 'y'
                        }
                    ];
                    
                    // Layout configuration
                    const layout = {
                        title: 'Worst Performance Across Perturbation Levels',
                        xaxis: {
                            title: 'Perturbation Level (%)',
                            ticksuffix: '%'
                        },
                        yaxis: {
                            title: chartData.metric || 'Score'
                        },
                        legend: {
                            orientation: 'h', 
                            y: -0.2
                        },
                        hovermode: 'closest',
                        autosize: true,
                        margin: {
                            l: 50,
                            r: 30,
                            t: 50,
                            b: 60,
                            pad: 4
                        }
                    };
                    
                    // Config with responsive resize
                    const config = {
                        responsive: true,
                        displayModeBar: false
                    };
                    
                    // Create plot
                    Plotly.newPlot(container, traces, layout, config);
                },
                
                /**
                 * Initialize mean score chart
                 * @param {string} container - Container element ID
                 */
                initializeMeanScoreChart: function(container) {
                    // This is essentially the same as perturbation chart but with a different title
                    console.log("ChartManager: Initializing mean score chart");
                    
                    // Just delegate to perturbation chart for now
                    this.initializePerturbationChart(container);
                },
                
                /**
                 * Initialize model comparison chart for comparing different models
                 * @param {string} container - Container element ID
                 */
                initializeModelComparisonChart: function(container) {
                    console.log("ChartManager: Initializing model comparison chart");
                    
                    // Check if container exists
                    const containerElement = document.getElementById(container);
                    if (!containerElement) {
                        console.warn("Container not found:", container);
                        return;
                    }
                    
                    // Try to get model comparison data
                    const chartData = this.extractModelComparisonData();
                    
                    // If no data, show message
                    if (!chartData || !chartData.models || Object.keys(chartData.models).length === 0) {
                        containerElement.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #666;">
                                <p>No model comparison data available.</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // Create bar chart data
                    const models = Object.keys(chartData.models);
                    const baseScores = models.map(name => chartData.models[name].baseScore || 0);
                    const robustnessScores = models.map(name => chartData.models[name].robustnessScore || 0);
                    
                    // Create traces
                    const traces = [
                        {
                            x: models,
                            y: baseScores,
                            type: 'bar',
                            name: 'Base Score',
                            marker: { color: '#3182ce' }
                        },
                        {
                            x: models,
                            y: robustnessScores,
                            type: 'bar',
                            name: 'Robustness Score',
                            marker: { color: '#48bb78' }
                        }
                    ];
                    
                    // Layout
                    const layout = {
                        title: 'Model Comparison',
                        xaxis: {
                            title: 'Models'
                        },
                        yaxis: {
                            title: 'Score'
                        },
                        barmode: 'group',
                        legend: {
                            orientation: 'h',
                            y: -0.2
                        },
                        autosize: true,
                        margin: {
                            l: 50,
                            r: 30,
                            t: 50,
                            b: 100,
                            pad: 4
                        }
                    };
                    
                    // Config
                    const config = {
                        responsive: true,
                        displayModeBar: false
                    };
                    
                    // Create plot
                    Plotly.newPlot(container, traces, layout, config);
                },
                
                /**
                 * Extract model comparison data from report
                 * @returns {Object} Comparison data
                 */
                extractModelComparisonData: function() {
                    const models = {};
                    
                    if (window.reportData) {
                        // Add main model
                        models[window.reportData.model_name || 'Main Model'] = {
                            baseScore: window.reportData.base_score || 0,
                            robustnessScore: window.reportData.robustness_score || 0,
                            type: window.reportData.model_type || 'Unknown'
                        };
                        
                        // Add alternative models
                        if (window.reportData.alternative_models) {
                            for (const [name, model] of Object.entries(window.reportData.alternative_models)) {
                                models[name] = {
                                    baseScore: model.base_score || 0,
                                    robustnessScore: model.robustness_score || 0,
                                    type: model.model_type || 'Unknown'
                                };
                            }
                        }
                    }
                    
                    return { models };
                },
                
                /**
                 * Initialize model level details chart showing scores at each level
                 * @param {string} container - Container element ID
                 */
                initializeModelLevelDetailsChart: function(container) {
                    console.log("ChartManager: Initializing model level details chart");
                    
                    // Check if container exists
                    const containerElement = document.getElementById(container);
                    if (!containerElement) {
                        console.warn("Container not found:", container);
                        return;
                    }
                    
                    // Get data for chart
                    const chartData = this.extractModelLevelDetailsData();
                    
                    // If no data, show message
                    if (!chartData || !chartData.levels || chartData.levels.length === 0 || 
                        !chartData.modelScores || Object.keys(chartData.modelScores).length === 0) {
                        containerElement.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #666;">
                                <p>No level details data available for chart.</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // Create traces for each model
                    const traces = [];
                    const colors = ['#3182ce', '#f56565', '#48bb78', '#9f7aea', '#ed8936', '#0694a2'];
                    let colorIndex = 0;
                    
                    for (const [modelId, scores] of Object.entries(chartData.modelScores)) {
                        if (Array.isArray(scores) && scores.length > 0) {
                            const name = chartData.modelNames && chartData.modelNames[modelId] 
                                ? chartData.modelNames[modelId] : modelId;
                                
                            traces.push({
                                x: chartData.levels.map(l => l * 100),
                                y: scores,
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: name,
                                line: { width: 2, color: colors[colorIndex % colors.length] },
                                marker: { size: 6, color: colors[colorIndex % colors.length] }
                            });
                            
                            colorIndex++;
                        }
                    }
                    
                    // Layout
                    const layout = {
                        title: 'Model Performance by Perturbation Level',
                        xaxis: {
                            title: 'Perturbation Level (%)',
                            ticksuffix: '%'
                        },
                        yaxis: {
                            title: chartData.metricName || 'Score'
                        },
                        legend: {
                            orientation: 'h',
                            y: -0.2
                        },
                        hovermode: 'closest',
                        autosize: true,
                        margin: {
                            l: 50,
                            r: 30,
                            t: 50,
                            b: 80,
                            pad: 4
                        }
                    };
                    
                    // Config
                    const config = {
                        responsive: true,
                        displayModeBar: false
                    };
                    
                    // Create plot
                    Plotly.newPlot(container, traces, layout, config);
                },
                
                /**
                 * Extract model level details data from report
                 * @returns {Object} Level details data
                 */
                extractModelLevelDetailsData: function() {
                    console.log("Using enhanced extractModelLevelDetailsData with real data");
                    
                    if (window.reportData) {
                        // Try perturbation_chart_data first
                        if (window.reportData.perturbation_chart_data) {
                            const chartData = window.reportData.perturbation_chart_data;
                            const result = {
                                levels: chartData.levels || [],
                                modelScores: {},
                                modelNames: {},
                                metricName: chartData.metric || 'Score'
                            };
                            
                            // Add primary model
                            if (Array.isArray(chartData.scores) && chartData.scores.length > 0) {
                                const primaryModelId = 'primary';
                                result.modelScores[primaryModelId] = chartData.scores;
                                result.modelNames[primaryModelId] = chartData.modelName || 'Primary Model';
                            }
                            
                            // Add alternative models
                            if (chartData.alternativeModels) {
                                for (const [modelName, modelData] of Object.entries(chartData.alternativeModels)) {
                                    if (Array.isArray(modelData.scores) && modelData.scores.length > 0) {
                                        const modelId = modelName.toLowerCase().replace(/[^a-z0-9]+/g, '_');
                                        result.modelScores[modelId] = modelData.scores;
                                        result.modelNames[modelId] = modelName;
                                    }
                                }
                            }
                            
                            return result;
                        }
                    }
                    
                    // Fallback with empty structure
                    return {
                        levels: [],
                        modelScores: {},
                        modelNames: {},
                        metricName: 'Score'
                    };
                },
                
                /**
                 * Initialize feature importance chart showing relative importance
                 * @param {string} container - Container element ID
                 */
                initializeFeatureImportanceChart: function(container) {
                    console.log("ChartManager: Initializing feature importance chart");
                    
                    // Check if container exists
                    const containerElement = document.getElementById(container);
                    if (!containerElement) {
                        console.warn("Container not found:", container);
                        return;
                    }
                    
                    // Get feature importance data
                    const chartData = this.extractFeatureImportanceData();
                    
                    // If no data, show message
                    if (!chartData || !chartData.features || chartData.features.length === 0 ||
                        !chartData.values || chartData.values.length === 0) {
                        containerElement.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #666;">
                                <p>No feature importance data available.</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // Sort features by importance (descending)
                    const sortedIndices = chartData.values
                        .map((value, index) => ({ value, index }))
                        .sort((a, b) => b.value - a.value)
                        .map(item => item.index);
                        
                    const sortedFeatures = sortedIndices.map(i => chartData.features[i]);
                    const sortedValues = sortedIndices.map(i => chartData.values[i]);
                    
                    // Create horizontal bar chart
                    const trace = {
                        y: sortedFeatures,
                        x: sortedValues,
                        type: 'bar',
                        orientation: 'h',
                        marker: {
                            color: '#3182ce'
                        }
                    };
                    
                    // Layout
                    const layout = {
                        title: 'Feature Importance',
                        xaxis: {
                            title: 'Importance Score'
                        },
                        yaxis: {
                            title: 'Features',
                            automargin: true
                        },
                        autosize: true,
                        margin: {
                            l: 150,
                            r: 30,
                            t: 50,
                            b: 50,
                            pad: 4
                        }
                    };
                    
                    // Config
                    const config = {
                        responsive: true,
                        displayModeBar: false
                    };
                    
                    // Create plot
                    Plotly.newPlot(container, [trace], layout, config);
                },
                
                /**
                 * Extract feature importance data from report
                 * @returns {Object} Feature importance data
                 */
                extractFeatureImportanceData: function() {
                    if (window.reportData) {
                        // Try direct feature_importance property
                        if (window.reportData.feature_importance && 
                            typeof window.reportData.feature_importance === 'object') {
                            
                            const features = [];
                            const values = [];
                            
                            // Convert object to arrays
                            for (const [feature, importance] of Object.entries(window.reportData.feature_importance)) {
                                features.push(feature);
                                values.push(importance);
                            }
                            
                            return { features, values };
                        }
                    }
                    
                    // Return empty data as fallback
                    return { features: [], values: [] };
                },
                
                /**
                 * Initialize metrics radar chart for model metrics comparison
                 * @param {string} container - Container element ID
                 */
                initializeMetricsRadarChart: function(container) {
                    console.log("ChartManager: Initializing metrics radar chart");
                    
                    // Check if container exists
                    const containerElement = document.getElementById(container);
                    if (!containerElement) {
                        console.warn("Container not found:", container);
                        return;
                    }
                    
                    // Get metrics data
                    const chartData = this.extractMetricsRadarData();
                    
                    // If no data, show message
                    if (!chartData || !chartData.metrics || chartData.metrics.length === 0 ||
                        !chartData.models || Object.keys(chartData.models).length === 0) {
                        containerElement.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #666;">
                                <p>No metrics data available for radar chart.</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // Create traces for each model
                    const traces = [];
                    const colors = ['#3182ce', '#f56565', '#48bb78', '#9f7aea', '#ed8936', '#0694a2'];
                    let colorIndex = 0;
                    
                    for (const [modelId, modelData] of Object.entries(chartData.models)) {
                        if (modelData.values && modelData.values.length > 0) {
                            // Create radar trace
                            traces.push({
                                type: 'scatterpolar',
                                r: modelData.values,
                                theta: chartData.metrics,
                                fill: 'toself',
                                name: modelData.name || modelId,
                                line: {
                                    color: colors[colorIndex % colors.length]
                                }
                            });
                            
                            colorIndex++;
                        }
                    }
                    
                    // Layout
                    const layout = {
                        title: 'Model Metrics Comparison',
                        polar: {
                            radialaxis: {
                                visible: true,
                                range: [0, 1]
                            }
                        },
                        showlegend: true,
                        legend: {
                            orientation: 'h',
                            y: -0.2
                        },
                        autosize: true,
                        margin: {
                            l: 60,
                            r: 60,
                            t: 50,
                            b: 60,
                            pad: 4
                        }
                    };
                    
                    // Config
                    const config = {
                        responsive: true,
                        displayModeBar: false
                    };
                    
                    // Create plot
                    Plotly.newPlot(container, traces, layout, config);
                },
                
                /**
                 * Extract metrics radar data from report
                 * @returns {Object} Metrics radar data
                 */
                extractMetricsRadarData: function() {
                    if (window.reportData) {
                        // Try radar_chart_data first
                        if (window.reportData.radar_chart_data && 
                            window.reportData.radar_chart_data.models) {
                            
                            return this._processRadarChartData(window.reportData.radar_chart_data);
                        }
                        
                        // Try initial_results
                        if (window.reportData.initial_results && 
                            window.reportData.initial_results.models) {
                            
                            // Convert initial_results to radar format
                            const radarData = {
                                models: {}
                            };
                            
                            // Collect all metrics across all models
                            const allMetrics = new Set();
                            for (const model of Object.values(window.reportData.initial_results.models)) {
                                if (model.metrics) {
                                    Object.keys(model.metrics).forEach(metric => allMetrics.add(metric));
                                }
                            }
                            
                            // Process each model
                            for (const [modelId, model] of Object.entries(window.reportData.initial_results.models)) {
                                if (!model.metrics) continue;
                                
                                const modelData = {
                                    name: model.name || modelId,
                                    type: model.type || 'Unknown',
                                    values: []
                                };
                                
                                // Add metrics in consistent order
                                const metrics = Array.from(allMetrics);
                                for (const metric of metrics) {
                                    modelData.values.push(model.metrics[metric] || 0);
                                }
                                
                                radarData.models[modelId] = modelData;
                            }
                            
                            // Add metrics array
                            radarData.metrics = Array.from(allMetrics);
                            
                            return radarData;
                        }
                    }
                    
                    // Return empty data as fallback
                    return { metrics: [], models: {} };
                },
                
                /**
                 * Process radar chart data into standardized format
                 * @param {Object} data - Raw radar chart data
                 * @returns {Object} Processed data
                 */
                _processRadarChartData: function(data) {
                    const result = {
                        metrics: [],
                        models: {}
                    };
                    
                    // Get all metrics across all models
                    const allMetrics = new Set();
                    for (const model of Object.values(data.models)) {
                        if (model.metrics) {
                            Object.keys(model.metrics).forEach(metric => allMetrics.add(metric));
                        }
                    }
                    
                    // Set metrics array
                    result.metrics = Array.from(allMetrics);
                    
                    // Process each model
                    for (const [modelId, model] of Object.entries(data.models)) {
                        if (!model.metrics) continue;
                        
                        const modelData = {
                            name: model.name || modelId,
                            type: model.type || 'Unknown',
                            values: []
                        };
                        
                        // Add metrics in consistent order
                        for (const metric of result.metrics) {
                            modelData.values.push(model.metrics[metric] || 0);
                        }
                        
                        result.models[modelId] = modelData;
                    }
                    
                    return result;
                }
            };
            
            // Function to initialize all charts and controllers
            window.initializeCharts = function() {
                console.log("Initializing all charts...");
                
                // First make sure the window.reportData is available
                if (!window.reportData && document.getElementById('reportDataJson')) {
                    try {
                        // Try to load from embedded data 
                        const reportDataJson = document.getElementById('reportDataJson').textContent;
                        window.reportData = JSON.parse(reportDataJson);
                        console.log("Loaded report data from embedded JSON");
                    } catch (e) {
                        console.error("Failed to load report data from embedded JSON:", e);
                    }
                }
                
                // Also try to load chart data
                if (!window.chartData && document.getElementById('chartDataJson')) {
                    try {
                        const chartDataJson = document.getElementById('chartDataJson').textContent;
                        window.chartData = JSON.parse(chartDataJson);
                        console.log("Loaded chart data from embedded JSON");
                    } catch (e) {
                        console.error("Failed to load chart data from embedded JSON:", e);
                    }
                }
                
                // Auto-detect and initialize all chart containers in the document
                const chartContainers = document.querySelectorAll('.chart-plot, [id$="-chart"], [id$="-chart-plot"]');
                console.log(`Found ${chartContainers.length} chart containers`);
                
                if (window.ChartManager) {
                    // Define mapping of container IDs to initialization methods
                    const containers = {
                        'perturbation-chart-plot': 'initializePerturbationChart',
                        'worst-score-chart-plot': 'initializeWorstScoreChart',
                        'mean-score-chart-plot': 'initializeMeanScoreChart',
                        'model-comparison-chart-plot': 'initializeModelComparisonChart',
                        'model-level-details-chart-plot': 'initializeModelLevelDetailsChart',
                        'feature-importance-chart': 'initializeFeatureImportanceChart',
                        'metrics-radar-chart': 'initializeMetricsRadarChart',
                        'importance-comparison-chart-plot': 'initializeFeatureImportanceComparisonChart'
                    };
                    
                    // Try identified containers first
                    for (const [containerId, initMethod] of Object.entries(containers)) {
                        const container = document.getElementById(containerId);
                        if (container && typeof window.ChartManager[initMethod] === 'function') {
                            try {
                                console.log(`Initializing ${containerId} with ${initMethod}`);
                                window.ChartManager[initMethod](containerId);
                                // Mark this container as initialized
                                container.dataset.initialized = 'true';
                            } catch (e) {
                                console.error(`Error initializing ${containerId}:`, e);
                            }
                        }
                    }
                    
                    // For any uninitialized containers, try best-effort initialization
                    chartContainers.forEach(container => {
                        if (container.dataset.initialized === 'true') return;
                        
                        const containerId = container.id;
                        if (!containerId) return;
                        
                        // Try to determine the chart type from the ID
                        let method = null;
                        
                        if (containerId.includes('perturbation')) {
                            method = 'initializePerturbationChart';
                        } else if (containerId.includes('worst-score')) {
                            method = 'initializeWorstScoreChart';
                        } else if (containerId.includes('mean-score')) {
                            method = 'initializeMeanScoreChart';
                        } else if (containerId.includes('model-comparison')) {
                            method = 'initializeModelComparisonChart';
                        } else if (containerId.includes('model-level')) {
                            method = 'initializeModelLevelDetailsChart';
                        } else if (containerId.includes('feature-importance')) {
                            method = 'initializeFeatureImportanceChart';
                        } else if (containerId.includes('metrics')) {
                            method = 'initializeMetricsRadarChart';
                        } else if (containerId.includes('importance-comparison')) {
                            method = 'initializeFeatureImportanceComparisonChart';
                        } else {
                            // Fall back to a generic method if available
                            method = 'initializeGenericChart';
                        }
                        
                        if (method && typeof window.ChartManager[method] === 'function') {
                            try {
                                console.log(`Best-effort initializing ${containerId} with ${method}`);
                                window.ChartManager[method](containerId);
                                container.dataset.initialized = 'true';
                            } catch (e) {
                                console.error(`Error in best-effort initialization of ${containerId}:`, e);
                            }
                        }
                    });
                }
                
                // Initialize any custom controllers
                if (window.PerturbationResultsController && 
                    typeof window.PerturbationResultsController.init === 'function' && 
                    document.getElementById('perturbation-results-container')) {
                    try {
                        console.log("Initializing PerturbationResultsController");
                        window.PerturbationResultsController.init();
                    } catch (e) {
                        console.error("Error initializing PerturbationResultsController:", e);
                    }
                }
                
                console.log("Chart initialization complete");
            };
            
            // Helper function for compatibility
            window.loadPlotly = function() {
                console.log("Using embedded Plotly implementation");
                return Promise.resolve(window.Plotly);
            };
            
            // Initialize everything on page load
            document.addEventListener('DOMContentLoaded', function() {
                console.log("DOMContentLoaded event - Starting initialization");
                
                // Initialize tabs first to ensure chart containers are visible
                if (typeof initTabs === 'function') {
                    console.log("Initializing tabs");
                    initTabs();
                }
                
                // Initialize charts with a slight delay to ensure DOM is fully ready
                setTimeout(function() {
                    window.initializeCharts();
                }, 100);
            });
            
            // Also initialize if the page is already loaded
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                console.log("Document already loaded - Starting initialization");
                setTimeout(window.initializeCharts, 100);
            }
        })();
    </script>
    
    <!-- CSS combinado -->
    <style>
        {{ css_content }}
    </style>
    
    <!-- Embedding report data as JSON for chart initialization -->
    <script id="reportDataJson" type="application/json">
        {{ report_data_json }}
    </script>
    
    <!-- Embedding chart data as JSON for chart initialization -->
    <script id="chartDataJson" type="application/json">
        {{ chart_data_json }}
    </script>
    
    <!-- Making data available directly in window object -->
    <script>
        // Initialize report data in window object
        window.reportData = {{ report_data_json|safe }};
        
        // Initialize chart data in window object
        window.chartData = {{ chart_data_json|safe }};
        
        console.log("Report data and chart data initialized in window object");
    </script>
</head>
<body>
    <div class="report-container {{ report_type }}-report">
        <!-- Header comum -->
        {% include 'common/header.html' %}

        <!-- Summary section (inserido diretamente como o header) -->
        {% include 'report_types/' + report_type + '/partials/summary.html' %}

        <div class="report-content">
            <!-- Navegação em abas usando componente comum -->
            {% with 
                tabs=[
                    {'id': 'overview', 'title': 'Overview'},
                    {'id': 'details', 'title': 'Details'},
                    {'id': 'boxplot', 'title': 'Box Plot'},
                    {'id': 'feature_impact', 'title': 'Feature Importance'},
                    {'id': 'importance_comparison', 'title': 'Importance Comparison'}
                ]
            %}
            {% include 'common/navigation.html' %}
            {% endwith %}

            <!-- Conteúdo das abas -->
            <div id="overview" class="tab-content active">
                {% include 'report_types/' + report_type + '/partials/overview.html' %}
            </div>
            
            <div id="details" class="tab-content">
                {% include 'report_types/' + report_type + '/partials/details.html' %}
            </div>
            
            <div id="boxplot" class="tab-content">
                {% include 'report_types/' + report_type + '/partials/boxplot.html' %}
            </div>
            
            <div id="feature_impact" class="tab-content">
                {% include 'report_types/' + report_type + '/partials/features.html' %}
            </div>
            
            <div id="importance_comparison" class="tab-content">
                {% include 'report_types/' + report_type + '/partials/importance_comparison_fixed.html' %}
            </div>
        </div>
        
        <!-- Footer comum -->
        {% include 'common/footer.html' %}
    </div>

    <!-- Inicialização de dados do relatório -->
    <script>
        // Disponibilizar dados do relatório para todos os componentes
        window.reportData = {{ report_data_json|safe }};
        
        // Configuração básica do relatório
        window.reportConfig = {
            reportType: '{{ report_type }}',
            modelName: '{{ report_data.model_name }}',
            // Incluir dados de importância de características diretamente para acesso mais fácil
            feature_importance: {{ report_data.feature_importance|tojson|default('{}') }},
            model_feature_importance: {{ report_data.model_feature_importance|tojson|default('{}') }},
            feature_subset: {{ report_data.feature_subset|tojson|default('[]') }}
        };
        
        // Extrair dados do gráfico, se disponíveis
        if (window.reportData && window.reportData.chart_data_json) {
            try {
                // Limpar dados JSON antes de analisar
                const jsonStr = window.reportData.chart_data_json;
                let cleanJson = jsonStr;
                
                // Corrigir vírgulas finais
                cleanJson = cleanJson.replace(/,(\s*})/g, '$1');
                cleanJson = cleanJson.replace(/,(\s*\])/g, '$1');
                
                // Tratar outros problemas de sintaxe
                cleanJson = cleanJson.replace(/\bNaN\b/g, 'null');
                cleanJson = cleanJson.replace(/\bInfinity\b/g, 'null');
                cleanJson = cleanJson.replace(/\b-Infinity\b/g, 'null');
                cleanJson = cleanJson.replace(/\bundefined\b/g, 'null');
                
                // Analisar os dados JSON limpos
                window.chartData = JSON.parse(cleanJson);
                console.log("Dados de gráfico carregados com sucesso");
            } catch (e) {
                console.error("Erro ao analisar dados do gráfico:", e);
                window.chartData = {
                    perturbation_levels: [],
                    feature_importance: {},
                    model_feature_importance: {},
                    boxplot_data: { models: [] }
                };
            }
        }
    </script>
    
    <!-- Scripts combinados para funcionalidade completa -->
    <script>
        // Todos os scripts são combinados e injetados diretamente no HTML
        // para garantir que o relatório seja totalmente autônomo sem dados sintéticos
        
        // Inicialização segura - garantir que seja executado apenas quando o DOM estiver pronto
        window.DeepBridgeInit = function deepBridgeInit() {
            console.log("DeepBridge report initialization - 100% autonomous mode");
            
            // Tentar carregar Plotly se ainda não estiver carregado
            if (typeof window.loadPlotly === 'function') {
                window.loadPlotly().catch(e => {
                    console.warn("Chart functionality may be limited", e);
                });
            }
            
            // Call initialization functions if defined
            if (typeof setupTabNavigation === 'function') {
                setupTabNavigation();
                console.log("Tab navigation initialized");
            }
            
            if (typeof initializeControllers === 'function') {
                initializeControllers();
                console.log("Controllers initialized");
            }
            
            // Initialize first tab's charts
            const initialTab = document.querySelector('.tab-btn.active');
            if (initialTab) {
                const tabId = initialTab.getAttribute('data-tab');
                if (typeof handleTabChange === 'function') {
                    handleTabChange(tabId);
                    console.log(`Initial tab ${tabId} initialized`);
                }
            } else {
                // Default to overview if no tab is active
                if (typeof window.ChartInitializer !== 'undefined' && 
                    typeof window.ChartInitializer.initializeOverviewCharts === 'function') {
                    window.ChartInitializer.initializeOverviewCharts();
                    console.log("Overview charts initialized by default");
                }
            }
        };
        
        // Fallback initialization function
        window.initFallbackMode = function initFallbackMode() {
            console.log("Using fallback mode initialization");
            
            // Inicializar abas
            const tabButtons = document.querySelectorAll('.tab-btn');
            if (tabButtons.length > 0) {
                tabButtons.forEach(function setupTabButton(button) {
                    button.addEventListener('click', function tabClickHandler() {
                        const targetTab = this.getAttribute('data-tab');
                        
                        // Desativar todas as abas
                        document.querySelectorAll('.tab-content').forEach(function hideTab(tab) {
                            tab.classList.remove('active');
                        });
                        
                        // Ativar a aba selecionada
                        const selectedTab = document.getElementById(targetTab);
                        if (selectedTab) {
                            selectedTab.classList.add('active');
                        }
                        
                        // Desativar todos os botões
                        tabButtons.forEach(function deactivateButton(btn) {
                            btn.classList.remove('active');
                        });
                        
                        // Ativar o botão selecionado
                        this.classList.add('active');
                    });
                });
                
                // Ativar a primeira aba por padrão
                tabButtons[0].click();
            }
        };
        
        // Código de todos os scripts combinados
        {{ js_content }}
        
        // Garantir que a inicialização ocorra quando o DOM estiver pronto
        document.addEventListener('DOMContentLoaded', function onDOMContentLoaded() {
            console.log("DOM content loaded - initializing report...");
            
            // Uma pequena pausa para garantir que todos os dados estão disponíveis
            setTimeout(function delayedInit() {
                if (typeof window.DeepBridgeInit === 'function') {
                    try {
                        window.DeepBridgeInit();
                    } catch (e) {
                        console.error("Error during initialization:", e);
                        
                        // Fallback initialization
                        window.initFallbackMode();
                    }
                } else {
                    console.warn("DeepBridgeInit não disponível - usando inicialização alternativa");
                    window.initFallbackMode();
                }
            }, 100);
        });
    </script>
    
    <!-- Embedded JavaScript modules -->
    <script>
        {{ js_content }}
    </script>
</body>
</html>