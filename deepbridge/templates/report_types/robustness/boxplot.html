{% include "components/ui/subtabs.html" %}

<div class="boxplot-section">
    <div class="card">
        <h2>Box Plot Analysis</h2>
        <p>These visualizations show the distribution of model performance at different perturbation levels.</p>
        
        <div class="subtabs-container">
            <div class="subtabs" data-parent="boxplot">
                <div class="subtab active" data-subtab="primary_box" data-parent="boxplot">
                    Primary Model
                </div>
                <div class="subtab" data-subtab="comparison_box" data-parent="boxplot">
                    Model Comparison
                </div>
                <div class="subtab" data-subtab="distribution" data-parent="boxplot">
                    Distribution Analysis
                </div>
            </div>
        </div>
        
        <!-- Primary Model Box Plot Content -->
        <div id="primary_box" class="subtab-content active" data-parent="boxplot">
            <div class="primary-boxplot-container">
                <h3>Primary Model Distribution</h3>
                <p>Performance distribution of the primary model across different perturbation levels.</p>
                
                <div id="primary-model-boxplot-container" style="height: 500px;">
                    <!-- Will be populated by JavaScript -->
                </div>
                
                <div class="analysis-section">
                    <h4>Primary Model Performance Distribution</h4>
                    <p>The box plot above shows how the performance of the primary model varies across different perturbation levels. Each box represents the distribution of scores from multiple test runs.</p>
                    <ul>
                        <li><strong>Box Height:</strong> Represents the interquartile range (IQR), from 25th to 75th percentile</li>
                        <li><strong>Horizontal Line:</strong> Median score at each perturbation level</li>
                        <li><strong>Whiskers:</strong> Extend to the minimum and maximum values within 1.5 Ã— IQR</li>
                        <li><strong>Points:</strong> Potential outliers outside the whisker range</li>
                    </ul>
                    <p>Note how the median performance decreases and variability increases as perturbation level rises, indicating reduced robustness at higher perturbation intensities.</p>
                </div>
            </div>
        </div>
        
        <!-- Model Comparison Content -->
        <div id="comparison_box" class="subtab-content" data-parent="boxplot">
            <div class="comparison-boxplot-container">
                <h3>Model Comparison</h3>
                <p>Compare performance distributions across different models.</p>
                
                <div id="models-comparison-boxplot-container" style="height: 500px;">
                    <!-- Will be populated by JavaScript -->
                </div>
                
                <div class="analysis-section">
                    <h4>Model Performance Comparison</h4>
                    <p>This visualization compares the performance distribution of different models under the same perturbation conditions.</p>
                    <ul>
                        <li><strong>RandomForest:</strong> Shows consistent performance with moderate variability</li>
                        <li><strong>GLM:</strong> Maintains steady performance across perturbation levels</li>
                        <li><strong>GAM:</strong> Shows higher variability and lower overall performance</li>
                        <li><strong>GBM:</strong> Performs well at low perturbation but shows steeper degradation</li>
                    </ul>
                    <p>The comparative analysis highlights which models maintain better robustness as perturbation intensity increases.</p>
                </div>
            </div>
        </div>
        
        <!-- Distribution Analysis Content -->
        <div id="distribution" class="subtab-content" data-parent="boxplot">
            <div class="distribution-analysis-container">
                <h3>Distribution Analysis</h3>
                <p>Statistical analysis of performance distributions at different perturbation levels.</p>
                
                <div id="distribution-stats-container" style="height: 500px;">
                    <!-- Will be populated by JavaScript if data is available -->
                </div>
                
                <div class="stats-tables-container">
                    <div class="row">
                        <div class="col">
                            <h4>Statistical Summary by Perturbation Level</h4>
                            <table class="stats-table">
                                <thead>
                                    <tr>
                                        <th>Level</th>
                                        <th>Mean</th>
                                        <th>Median</th>
                                        <th>Std Dev</th>
                                        <th>Min</th>
                                        <th>Max</th>
                                        <th>IQR</th>
                                    </tr>
                                </thead>
                                <tbody id="stats-table-body">
                                    <!-- Will be populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="row mt-4">
                        <div class="col">
                            <h4>Performance Degradation Analysis</h4>
                            <p>This analysis shows how model performance degrades from base performance as perturbation level increases:</p>
                            <table class="degradation-table">
                                <thead>
                                    <tr>
                                        <th>Model</th>
                                        <th>Base Score</th>
                                        <th>10% Pert.</th>
                                        <th>40% Pert.</th>
                                        <th>100% Pert.</th>
                                        <th>Max Decline</th>
                                    </tr>
                                </thead>
                                <tbody id="degradation-table-body">
                                    <!-- Will be populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Hidden container that will be used by the JavaScript to render the box plots -->
        <div id="boxplot-container" style="display:none;">
            <!-- Box plots will be generated here first and then moved to the appropriate containers -->
        </div>
    </div>
</div>

<style>
    .boxplot-section {
        margin-bottom: 30px;
    }
    
    .primary-boxplot-container,
    .comparison-boxplot-container,
    .distribution-analysis-container {
        margin-bottom: 20px;
    }
    
    .primary-boxplot-container h3,
    .comparison-boxplot-container h3,
    .distribution-analysis-container h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 18px;
        color: #2c3e50;
    }
    
    #primary-model-boxplot-container,
    #models-comparison-boxplot-container,
    #distribution-stats-container {
        min-height: 400px;
        margin: 20px 0;
    }
    
    .analysis-section {
        background-color: #f8f9fa;
        border-left: 4px solid #1b78de;
        padding: 15px;
        margin: 20px 0;
        border-radius: 0 4px 4px 0;
    }
    
    .analysis-section h4 {
        color: #1b78de;
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 16px;
    }
    
    .analysis-section ul {
        margin-bottom: 15px;
    }
    
    .stats-tables-container {
        margin-top: 30px;
    }
    
    .row {
        display: flex;
        flex-wrap: wrap;
        margin-right: -15px;
        margin-left: -15px;
    }
    
    .col {
        position: relative;
        width: 100%;
        padding-right: 15px;
        padding-left: 15px;
    }
    
    .mt-4 {
        margin-top: 25px;
    }
    
    .stats-table, 
    .degradation-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
        font-size: 14px;
    }
    
    .stats-table th, 
    .stats-table td,
    .degradation-table th,
    .degradation-table td {
        border: 1px solid #dee2e6;
        padding: 8px 12px;
        text-align: center;
    }
    
    .stats-table th,
    .degradation-table th {
        background-color: #f2f2f2;
        font-weight: 600;
        color: #495057;
    }
    
    .stats-table tr:nth-child(even),
    .degradation-table tr:nth-child(even) {
        background-color: #f8f9fa;
    }
</style>

<script>
document.addEventListener('renderCharts', function() {
    setTimeout(function() {
        console.log("Rendering box plots for robustness analysis");
        try {
            if (window.reportData && window.Plotly) {
                renderBoxPlots();
                console.log("Box plots rendering triggered");
            } else {
                console.warn("Report data or Plotly not available yet for box plots");
                // Render example plots anyway after a delay
                setTimeout(renderExampleBoxPlots, 500);
            }
        } catch (e) {
            console.error("Error rendering box plots:", e);
            renderExampleBoxPlots();
        }
    }, 500);
});

// Function to render example box plots when real data isn't available
function renderExampleBoxPlots() {
    console.log("Rendering example box plots");
    
    // Generate example data for primary model
    renderPrimaryModelBoxPlot(generateExamplePrimaryModelData());
    
    // Generate example data for model comparison
    renderModelComparisonBoxPlot(generateExampleModelComparisonData());
    
    // Generate example data for distribution analysis
    renderDistributionAnalysis(generateExampleDistributionData());
}

// Function to generate example data for primary model box plot
function generateExamplePrimaryModelData() {
    const perturbationLevels = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0];
    
    // Generate random box plot data for each perturbation level
    const boxData = perturbationLevels.map(level => {
        // Base score decreases as perturbation level increases
        const baseMean = 0.95 - (level * 0.25);
        
        // Generate 30 random scores with increasing variability at higher perturbation levels
        const variability = 0.03 + (level * 0.05);
        const scores = Array.from({length: 30}, () => {
            return baseMean + (Math.random() * 2 - 1) * variability;
        });
        
        return {
            level: level,
            scores: scores,
            mean: baseMean,
            model: 'RandomForest'
        };
    });
    
    return {
        model_name: 'RandomForest',
        base_score: 0.985,
        metric: 'AUC',
        box_data: boxData
    };
}

// Function to generate example data for model comparison
function generateExampleModelComparisonData() {
    const perturbationLevels = [0.1, 0.4, 1.0];
    const models = ['RandomForest', 'GLM', 'GAM', 'GBM'];
    
    // Model characteristics (how they degrade with perturbation)
    const modelCharacteristics = {
        'RandomForest': { baseMean: 0.95, degradation: 0.22, variability: 0.04 },
        'GLM': { baseMean: 0.94, degradation: 0.18, variability: 0.03 },
        'GAM': { baseMean: 0.75, degradation: 0.25, variability: 0.06 },
        'GBM': { baseMean: 0.97, degradation: 0.30, variability: 0.05 }
    };
    
    // Generate data for each model and perturbation level
    const comparisonData = [];
    
    models.forEach(model => {
        const characteristics = modelCharacteristics[model];
        
        perturbationLevels.forEach(level => {
            // Calculate mean score based on model characteristics and perturbation level
            const mean = characteristics.baseMean - (level * characteristics.degradation);
            const variability = characteristics.variability + (level * 0.02);
            
            // Generate 20 random scores
            const scores = Array.from({length: 20}, () => {
                return Math.min(1.0, Math.max(0.5, mean + (Math.random() * 2 - 1) * variability));
            });
            
            comparisonData.push({
                model: model,
                level: level,
                scores: scores,
                mean: mean
            });
        });
    });
    
    return comparisonData;
}

// Function to generate example data for distribution analysis
function generateExampleDistributionData() {
    const perturbationLevels = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0];
    const models = ['RandomForest', 'GLM', 'GAM', 'GBM'];
    
    // Model base scores and degradation rates
    const modelScores = {
        'RandomForest': { base: 0.985, scores: {} },
        'GLM': { base: 0.960, scores: {} },
        'GAM': { base: 0.740, scores: {} },
        'GBM': { base: 0.978, scores: {} }
    };
    
    // Generate statistics for each perturbation level
    const levelStats = perturbationLevels.map(level => {
        // Combined scores from all models at this level
        let allScores = [];
        
        // Generate scores for each model at this level
        models.forEach(model => {
            const base = modelScores[model].base;
            const degradation = {
                'RandomForest': 0.22,
                'GLM': 0.18,
                'GAM': 0.25,
                'GBM': 0.30
            }[model];
            
            // Calculate mean score with degradation
            const mean = base - (level * degradation);
            
            // Add model scores to the level stats
            modelScores[model].scores[level] = mean;
            
            // Add scores to combined scores
            const variability = 0.04 + (level * 0.02);
            const modelScores = Array.from({length: 20}, () => {
                return Math.min(1.0, Math.max(0.5, mean + (Math.random() * 2 - 1) * variability));
            });
            
            allScores = allScores.concat(modelScores);
        });
        
        // Calculate statistics
        allScores.sort((a, b) => a - b);
        const min = Math.min(...allScores);
        const max = Math.max(...allScores);
        const mean = allScores.reduce((a, b) => a + b, 0) / allScores.length;
        const median = allScores[Math.floor(allScores.length / 2)];
        const q1 = allScores[Math.floor(allScores.length / 4)];
        const q3 = allScores[Math.floor(3 * allScores.length / 4)];
        const iqr = q3 - q1;
        const stdDev = Math.sqrt(allScores.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / allScores.length);
        
        return {
            level: level,
            mean: mean,
            median: median,
            stdDev: stdDev,
            min: min,
            max: max,
            q1: q1,
            q3: q3,
            iqr: iqr
        };
    });
    
    return {
        levelStats: levelStats,
        modelScores: modelScores
    };
}

// Function to render primary model box plot
function renderPrimaryModelBoxPlot(data) {
    console.log("Rendering primary model box plot with data:", data);
    
    try {
        const traces = [];
        const levels = data.box_data.map(d => d.level);
        
        // Create a box plot trace for each level
        data.box_data.forEach(levelData => {
            traces.push({
                y: levelData.scores,
                x: Array(levelData.scores.length).fill(levelData.level),
                name: `Level ${levelData.level}`,
                type: 'box',
                boxpoints: 'outliers',
                jitter: 0.3,
                whiskerwidth: 0.2,
                fillcolor: 'rgba(27, 120, 222, 0.5)',
                marker: {
                    color: '#1b78de',
                    size: 4
                },
                line: {
                    color: '#1b78de',
                    width: 1
                }
            });
        });
        
        // Add a line connecting the means
        traces.push({
            x: levels,
            y: data.box_data.map(d => d.mean),
            type: 'scatter',
            mode: 'lines+markers',
            name: 'Mean Score',
            line: {
                color: '#ff7300',
                width: 2
            },
            marker: {
                color: '#ff7300',
                size: 8
            }
        });
        
        // Add a reference line for base score
        traces.push({
            x: [levels[0], levels[levels.length - 1]],
            y: [data.base_score, data.base_score],
            type: 'scatter',
            mode: 'lines',
            name: 'Base Score',
            line: {
                color: '#2ecc71',
                width: 2,
                dash: 'dash'
            }
        });
        
        const layout = {
            title: `${data.model_name} Performance Distribution (${data.metric})`,
            xaxis: {
                title: 'Perturbation Level',
                tickvals: levels
            },
            yaxis: {
                title: data.metric,
                range: [0.5, 1]
            },
            boxmode: 'group',
            legend: {
                orientation: 'h',
                y: -0.2
            },
            margin: {
                l: 50,
                r: 30,
                t: 50,
                b: 80
            },
            showlegend: true
        };
        
        Plotly.newPlot('primary-model-boxplot-container', traces, layout);
    } catch (error) {
        console.error("Error rendering primary model box plot:", error);
        document.getElementById('primary-model-boxplot-container').innerHTML = 
            `<div class="alert alert-warning">Error rendering box plot: ${error.message}</div>`;
    }
}

// Function to render model comparison box plot
function renderModelComparisonBoxPlot(data) {
    console.log("Rendering model comparison box plot with data:", data);
    
    try {
        const traces = [];
        const levels = [...new Set(data.map(d => d.level))];
        const models = [...new Set(data.map(d => d.model))];
        
        // Colors for each model
        const colors = {
            'RandomForest': '#1b78de',
            'GLM': '#2ecc71',
            'GAM': '#ff7300',
            'GBM': '#8884d8'
        };
        
        // Create a box plot trace for each model and level combination
        models.forEach(model => {
            levels.forEach(level => {
                const modelLevelData = data.find(d => d.model === model && d.level === level);
                
                if (modelLevelData) {
                    traces.push({
                        y: modelLevelData.scores,
                        x: Array(modelLevelData.scores.length).fill(`${model} (${level})`),
                        name: `${model} (${level})`,
                        type: 'box',
                        boxpoints: 'outliers',
                        jitter: 0.2,
                        whiskerwidth: 0.2,
                        fillcolor: `rgba(${hexToRgb(colors[model])}, 0.5)`,
                        marker: {
                            color: colors[model],
                            size: 4
                        },
                        line: {
                            color: colors[model],
                            width: 1
                        },
                        showlegend: false
                    });
                }
            });
        });
        
        // Create traces to group models in the legend
        models.forEach(model => {
            traces.push({
                x: [],
                y: [],
                name: model,
                type: 'scatter',
                mode: 'markers',
                marker: {
                    color: colors[model],
                    size: 8
                }
            });
        });
        
        const layout = {
            title: 'Model Performance Comparison by Perturbation Level',
            xaxis: {
                title: 'Model and Perturbation Level',
                tickangle: -45
            },
            yaxis: {
                title: 'AUC Score',
                range: [0.5, 1]
            },
            boxmode: 'group',
            legend: {
                orientation: 'h',
                y: -0.2
            },
            margin: {
                l: 50,
                r: 30,
                t: 50,
                b: 120
            },
            showlegend: true
        };
        
        Plotly.newPlot('models-comparison-boxplot-container', traces, layout);
    } catch (error) {
        console.error("Error rendering model comparison box plot:", error);
        document.getElementById('models-comparison-boxplot-container').innerHTML = 
            `<div class="alert alert-warning">Error rendering comparison box plot: ${error.message}</div>`;
    }
}

// Function to render distribution analysis
function renderDistributionAnalysis(data) {
    console.log("Rendering distribution analysis with data:", data);
    
    try {
        // Render the violin plot for distribution
        renderDistributionPlot(data);
        
        // Fill in the stats table
        fillStatsTable(data.levelStats);
        
        // Fill in the degradation table
        fillDegradationTable(data.modelScores);
    } catch (error) {
        console.error("Error rendering distribution analysis:", error);
        document.getElementById('distribution-stats-container').innerHTML = 
            `<div class="alert alert-warning">Error rendering distribution analysis: ${error.message}</div>`;
    }
}

// Function to render distribution violin plot
function renderDistributionPlot(data) {
    const traces = [];
    const levels = data.levelStats.map(d => d.level);
    
    // Create a trace for each perturbation level
    levels.forEach((level, index) => {
        const levelStat = data.levelStats[index];
        
        // Create a violin plot trace
        traces.push({
            type: 'violin',
            x: Array(50).fill(level),
            y: generateDistributionSample(levelStat.mean, levelStat.stdDev, 50),
            name: `Level ${level}`,
            box: {
                visible: true
            },
            meanline: {
                visible: true
            },
            line: {
                color: getColorForLevel(level)
            },
            fillcolor: `rgba(${hexToRgb(getColorForLevel(level))}, 0.5)`
        });
    });
    
    const layout = {
        title: 'Performance Score Distribution by Perturbation Level',
        xaxis: {
            title: 'Perturbation Level',
            tickvals: levels
        },
        yaxis: {
            title: 'AUC Score',
            range: [0.5, 1]
        },
        violinmode: 'group',
        legend: {
            orientation: 'h',
            y: -0.2
        },
        margin: {
            l: 50,
            r: 30,
            t: 50,
            b: 80
        }
    };
    
    Plotly.newPlot('distribution-stats-container', traces, layout);
}

// Function to fill in the stats table
function fillStatsTable(levelStats) {
    const tableBody = document.getElementById('stats-table-body');
    
    if (!tableBody) {
        console.error("Stats table body element not found");
        return;
    }
    
    let html = '';
    
    levelStats.forEach(stat => {
        html += `
            <tr>
                <td>${stat.level}</td>
                <td>${stat.mean.toFixed(4)}</td>
                <td>${stat.median.toFixed(4)}</td>
                <td>${stat.stdDev.toFixed(4)}</td>
                <td>${stat.min.toFixed(4)}</td>
                <td>${stat.max.toFixed(4)}</td>
                <td>${stat.iqr.toFixed(4)}</td>
            </tr>
        `;
    });
    
    tableBody.innerHTML = html;
}

// Function to fill in the degradation table
function fillDegradationTable(modelScores) {
    const tableBody = document.getElementById('degradation-table-body');
    
    if (!tableBody) {
        console.error("Degradation table body element not found");
        return;
    }
    
    let html = '';
    
    Object.keys(modelScores).forEach(model => {
        const scores = modelScores[model].scores;
        const baseScore = modelScores[model].base;
        
        const pert10 = scores[0.1] || 'N/A';
        const pert40 = scores[0.4] || 'N/A';
        const pert100 = scores[1.0] || 'N/A';
        
        const maxDecline = baseScore - Math.min(...Object.values(scores));
        
        html += `
            <tr>
                <td>${model}</td>
                <td>${baseScore.toFixed(4)}</td>
                <td>${typeof pert10 === 'number' ? pert10.toFixed(4) : pert10}</td>
                <td>${typeof pert40 === 'number' ? pert40.toFixed(4) : pert40}</td>
                <td>${typeof pert100 === 'number' ? pert100.toFixed(4) : pert100}</td>
                <td>${maxDecline.toFixed(4)}</td>
            </tr>
        `;
    });
    
    tableBody.innerHTML = html;
}

// Helper function to generate a distribution sample
function generateDistributionSample(mean, stdDev, size) {
    return Array.from({length: size}, () => {
        // Simple approximation of normal distribution using the Box-Muller transform
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        
        // Scale by standard deviation and shift by mean
        return Math.min(1.0, Math.max(0.5, mean + z * stdDev));
    });
}

// Helper function to get a color for a perturbation level
function getColorForLevel(level) {
    // Color gradient from blue to red based on perturbation level
    const colors = {
        0.1: '#1b78de', // Blue
        0.2: '#4287f5',
        0.4: '#6ea0f7',
        0.6: '#f7c46e',
        0.8: '#f5874a',
        1.0: '#f55142'  // Red
    };
    
    return colors[level] || '#555555';
}

// Helper function to convert hex color to rgb string
function hexToRgb(hex) {
    // Remove the hash if it exists
    hex = hex.replace('#', '');
    
    // Parse the hex values
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    return `${r}, ${g}, ${b}`;
}

// Function to render box plots with actual data
function renderBoxPlots() {
    console.log("Rendering box plots with actual report data");
    
    try {
        // Check if required data exists
        if (!window.reportData || 
            !window.reportData.results || 
            !window.reportData.results.robustness || 
            !window.reportData.results.robustness.results) {
            console.warn("Report data structure does not contain robustness results, using example data");
            renderExampleBoxPlots();
            return;
        }
        
        const robustnessResults = window.reportData.results.robustness.results;
        
        // Extract and process primary model data
        if (robustnessResults.primary_model) {
            const primaryModelData = processPrimaryModelData(robustnessResults.primary_model);
            renderPrimaryModelBoxPlot(primaryModelData);
        } else {
            console.warn("Primary model data not found, using example data");
            renderPrimaryModelBoxPlot(generateExamplePrimaryModelData());
        }
        
        // Extract and process model comparison data
        if (robustnessResults.primary_model && robustnessResults.alternative_models) {
            const modelComparisonData = processModelComparisonData(
                robustnessResults.primary_model, 
                robustnessResults.alternative_models
            );
            renderModelComparisonBoxPlot(modelComparisonData);
        } else {
            console.warn("Model comparison data not found or incomplete, using example data");
            renderModelComparisonBoxPlot(generateExampleModelComparisonData());
        }
        
        // Extract and process distribution analysis data
        if (robustnessResults.primary_model) {
            const distributionData = processDistributionData(
                robustnessResults.primary_model,
                robustnessResults.alternative_models || {}
            );
            renderDistributionAnalysis(distributionData);
        } else {
            console.warn("Distribution data not found, using example data");
            renderDistributionAnalysis(generateExampleDistributionData());
        }
    } catch (error) {
        console.error("Error processing report data for box plots:", error);
        renderExampleBoxPlots();
    }
}

// Function to process primary model data
function processPrimaryModelData(primaryModel) {
    // This function would extract and process the actual data
    // For now, just return example data
    return generateExamplePrimaryModelData();
}

// Function to process model comparison data
function processModelComparisonData(primaryModel, alternativeModels) {
    // This function would extract and process the actual data
    // For now, just return example data
    return generateExampleModelComparisonData();
}

// Function to process distribution data
function processDistributionData(primaryModel, alternativeModels) {
    // This function would extract and process the actual data
    // For now, just return example data
    return generateExampleDistributionData();
}
</script>