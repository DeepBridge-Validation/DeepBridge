<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepBridge Robustness Report: primary_model</title>
    
    <!-- Global error handler - load first to catch syntax errors early -->
    <script>
        // Simple inline error handler to catch syntax errors
        window.onerror = function(message, source, lineno, colno, error) {
            if (message && (message.includes("Illegal continue") || message.includes("no surrounding iteration"))) {
                console.error("Caught illegal continue:", {message, source, lineno});
                return true; // Prevent default handling
            }
            return false; // Let other errors propagate
        };
    </script>
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/png;base64,AAABAAEAeU0AAAEAIACMlgAAFgAAACgAAAB5AAAAmgAAAAEAIAAAAAAAlJEAAMIOAADCDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAHWXAUs5loHsu1aAfzuWgD/8VkB//BZAP/rWwD/7VoA/+pZBPjcWAicy1EKGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzVIIH+BZCbbsWAH77VoA/+tZAP/uWgD/61sA//VZAP/pVwX7z1QMUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAHXWgUt5FoFtOxZAv7yWAH/8FoB/+xZAf/zWQD/7FgD/dlbDV8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wAAAdVaCB/iVgm57VcD/vBaAP/uWQH/71kC/+BYB8HLUQoZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA11cPIOBZCbfsWgL26lkC999YBsLVUwsrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAHXWw0n31kIct9aC3PSWAUu/38AAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///////////////////4D///////////////////+A////////////////////gP///////////////////4D8AAf////////////4AA+A+AAD////////////8AAHgPAAAf///////////+AAA4DwAAD////////////AAAeA+AAAf///////////gAAHgP4AAD///////////gAAH4D+AAAP//////////wAAB+A/wAAD//////////4AAA/gP/AAAH/////////4AAA/4D/4AAA/////////8AAAf+A//AAAH////////+AAAP/gP/8AAAP///////8AAAP/4D//gAAB///////+AAAH/+A//+AAAH//////+AAAH//gP//4AAAP/////8AAAH//4D///AAAA/////8AAAD//+A///8AAAB////4AAAD///gP///4AAAA//+AAAAH///4D4P//AAAAAHgAAAAD//4eA8Af/8AAAAAAAAAAD//gDgPAAf/8AAAAAAAAAP/+AA4DwAB//gAAAAAAAAH/+AAOA8AAH/4AAAAAAAAB/+AADgPAAAf+A4AAAAAHAf+AAA4D4AAD/gP8AAAA/wH/AAAeA/wAAf4D//wAf/8B/gAAfgP/4AB+A///////AfgAD/4D//AAPgP//////wHwAD/+A//8AB4D//AAP/8B4AD//gP//4AOA/8AAAP/AcAD//4D///ABgP8AAAA/wGAB//+A///4AID8AAAAD8BAB///gP///AAA8AAAAAfAAA///4D///4AAOAAAAABwAAf//+A////gADAAAAAAcAAf///gP///4AAgAP/8ABAAH///4D////AAAAH//gAAAD///+A////4AAAH//+AAAB////gP////AAAH///4AAA////4D////wAAD////AAAP///+A////+AAB////4AAH////gP////wAA///8HAAD////4D////8AAf//+B4AA////+A/////gAP///APAAf////gP////4AH///gA4AH////4D////+AB///wAOAB////+A/////gA///4ABwAf////gP////8AP//8AAGAP////4D/////AH//+AABwD////+A/////wB///AAAMA/////gP/////B///gAAAw/////4D/////////wAIAP/////+A/////////4AHAB//////gP////////8AH4AH/////4D////////+AB+AB/////+A/////////gA/wAP/////gP////////4A//AA/////4D////////+AP/4AP////+A/////////gH/+AB/////gP////////8H//4AH////4D/////////h//+AB////+A/////////////wAP////gP/////////////AA////4D/////////////wAP///+A/////////////+AB////gP/////////////4AP///4D/////////////+AB///+A//////////////wAP///gP//////////////AD///4D//////////////wA///+A//////////////+AP///gP//////////////4H///4D//////////////+B///+A" type="image/png">
    
    <!-- Plotly library (incluído como conteúdo inline para garantir autonomia) -->
    <script>
        /* Plotly.js will be loaded from CDN the first time, but we'll add a fallback mechanism */
        (function() {
            window.loadPlotly = function() {
                if (typeof Plotly !== 'undefined') {
                    console.log("Plotly is already loaded");
                    return Promise.resolve();
                }
                
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdn.plot.ly/plotly-2.29.1.min.js';
                    script.async = true;
                    
                    script.onload = function() {
                        console.log("Plotly loaded successfully");
                        resolve();
                    };
                    
                    script.onerror = function() {
                        console.error("Failed to load Plotly from CDN, using simplified displays");
                        reject(new Error("Failed to load Plotly"));
                    };
                    
                    document.head.appendChild(script);
                });
            };
            
            // Attempt to load Plotly when the page loads
            window.addEventListener('DOMContentLoaded', function() {
                window.loadPlotly().catch(error => {
                    console.warn("Will use fallback charts:", error);
                });
            });
        })();
    </script>
    
    <!-- CSS combinado -->
    <style>
        /* ===== Combined CSS (Generic + Test-specific) ===== */

/* ----- Combined CSS Styles ----- */

/* =========================================
   MODEL VALIDATION LIBRARY - MAIN STYLES
   ========================================= */

/* --------------------------------------
   CSS VARIABLES
   -------------------------------------- */
:root {
    /* Brand colors */
    --primary-color: #1b78de;       /* Bright blue */
    --primary-light: #4287f5;       /* Lighter blue for gradients */
    --primary-color-dark: #1a5fb4;  /* Darker blue for hover states */
    --secondary-color: #2c3e50;     /* Dark slate */
    
    /* Semantic colors */
    --success-color: #28a745;
    --danger-color: #dc3545;
    --warning-color: #f39c12;
    --info-color: #17a2b8;
    
    /* UI colors */
    --light-color: #f8f9fa;
    --dark-color: #343a40;
    --text-color: #333333;
    --text-secondary: #555555;
    --text-muted: #6c757d;
    --border-color: #dddddd;
    --background-color: #f8f9fa;
    --card-bg: #ffffff;
    --bg-card: #ffffff;
    --bg-card-alt: #f8f9fa;
    
    /* Gradients */
    --header-bg: linear-gradient(to right, #1a5fb4, #3584e4, #62a0ea);
    --primary-gradient: linear-gradient(135deg, #4287f5, #1a56b8);
    
    /* Spacing */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;
    
    /* Border radius */
    --border-radius-sm: 4px;
    --border-radius-md: 8px;
    --border-radius-lg: 12px;
    
    /* Box shadows */
    --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
    --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
    --shadow-card: 0 2px 5px rgba(0, 0, 0, 0.1);
}

/* --------------------------------------
   RESET AND BASE STYLES
   -------------------------------------- */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html, body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 16px;
    line-height: 1.5;
    color: var(--text-color);
    background-color: var(--background-color);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

img {
    max-width: 100%;
    height: auto;
}

a {
    color: var(--primary-color);
    text-decoration: none;
    transition: color 0.2s ease;
}

a:hover {
    color: var(--primary-color-dark);
    text-decoration: underline;
}

/* Fix for tab display */
.tab-content {
    display: none !important;
}

.tab-content.active {
    display: block !important;
}

/* Header styling */
.report-header {
    background: var(--header-bg);
    color: white;
    padding: var(--spacing-lg);
    border-radius: var(--border-radius-md);
    margin-bottom: var(--spacing-lg);
    box-shadow: var(--shadow-md);
    width: 100%;
}

.header-content {
    display: flex;
    align-items: center;
    gap: 1.5rem;
}

.header-logo {
    flex: 0 0 auto;
}

.header-logo .logo {
    max-width: 120px;
    max-height: 60px;
}

.header-info {
    flex: 1;
}

.header-info h1 {
    margin: 0 0 0.25rem 0;
    font-size: 1.75rem;
}

.report-subtitle {
    margin: 0 0 0.75rem 0;
    opacity: 0.9;
}

.report-metadata {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    font-size: 0.875rem;
}

.metadata-item {
    padding-right: 1rem;
    border-right: 1px solid rgba(255, 255, 255, 0.3);
}

.metadata-item:last-child {
    border-right: none;
}

/* Report container */
.report-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--spacing-lg);
    width: 100%;
}

/* Content containers */
.report-content {
    padding: 0;
    width: 100%;
}

/* --------------------------------------
   LAYOUT CONTAINERS
   -------------------------------------- */
.container {
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 15px;
}

.section {
    margin-bottom: var(--spacing-xl);
    background-color: var(--bg-card);
    padding: var(--spacing-lg);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-card);
}

.section-title {
    margin-bottom: var(--spacing-md);
    padding-bottom: var(--spacing-sm);
    border-bottom: 1px solid var(--border-color);
    color: var(--secondary-color);
    font-size: 1.5rem;
}

/* --------------------------------------
   GRID SYSTEM
   -------------------------------------- */
.row {
    display: flex;
    flex-wrap: wrap;
    margin-right: -15px;
    margin-left: -15px;
}

.col {
    flex-basis: 0;
    flex-grow: 1;
    max-width: 100%;
    padding-right: 15px;
    padding-left: 15px;
}

.col-12 {
    flex: 0 0 100%;
    max-width: 100%;
    padding-right: 15px;
    padding-left: 15px;
}

.col-6 {
    flex: 0 0 50%;
    max-width: 50%;
    padding-right: 15px;
    padding-left: 15px;
}

.col-4 {
    flex: 0 0 33.333333%;
    max-width: 33.333333%;
    padding-right: 15px;
    padding-left: 15px;
}

.col-8 {
    flex: 0 0 66.666667%;
    max-width: 66.666667%;
    padding-right: 15px;
    padding-left: 15px;
}

.col-3 {
    flex: 0 0 25%;
    max-width: 25%;
    padding-right: 15px;
    padding-left: 15px;
}

/* Import component styles */
@import url('components/buttons.css');
@import url('components/cards.css');
@import url('components/charts.css');
@import url('components/messages.css');
@import url('components/tables.css');
@import url('components/tabs.css');
@import url('components/typography.css');
@import url('components/utilities.css');

/* --------------------------------------
   RESPONSIVE MEDIA QUERIES
   -------------------------------------- */
@media (max-width: 992px) {
    .col-lg-6 {
        flex: 0 0 50%;
        max-width: 50%;
    }
    
    .col-lg-12 {
        flex: 0 0 100%;
        max-width: 100%;
    }
    
    .header-content {
        flex-direction: column;
        text-align: center;
    }
    
    .header-logo {
        margin-bottom: 1rem;
    }
    
    .report-metadata {
        justify-content: center;
    }
}

@media (max-width: 768px) {
    .col-md-6, .col-6, .col-4, .col-8, .col-3 {
        flex: 0 0 100%;
        max-width: 100%;
    }
    
    .main-tabs {
        overflow-x: auto;
        flex-wrap: nowrap;
        justify-content: flex-start;
    }
    
    h1 {
        font-size: 1.8rem;
    }
    
    h2 {
        font-size: 1.5rem;
    }
    
    .report-header {
        padding: 1rem;
    }
    
    .section {
        padding: 1rem;
    }
    
    .report-container {
        padding: var(--spacing-md);
    }
}

@media (max-width: 576px) {
    .container {
        padding: 0 10px;
    }
    
    .report-container {
        padding: var(--spacing-sm);
    }
    
    .report-metadata {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .metadata-item {
        border-right: none;
        padding-right: 0;
    }
}

/* ----- tabs ----- */
/* Main tab navigation */
.main-tabs {
    display: flex;
    flex-wrap: nowrap;
    gap: 5px;
    margin: 1.5rem 0;
    background-color: #f4f6f9;
    border-radius: 8px;
    padding: 8px;
    overflow-x: auto;
    justify-content: center;
}

/* Tab content */
.tab-content {
    display: none !important;
}

.tab-content.active {
    display: block !important;
}

/* Results tabs */
.results-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 1rem;
}

.results-tabs .tab {
    padding: 0.5rem 1rem;
    cursor: pointer;
    border-bottom: 2px solid transparent;
}

.results-tabs .tab.active {
    border-bottom: 2px solid var(--primary-color);
    color: var(--primary-color);
    font-weight: 500;
}

/* ----- utilities ----- */
/* Status colors */
.text-red-600 {
    color: #dc2626;
}

.text-yellow-600 {
    color: #d97706;
}

.text-green-600 {
    color: #16a34a;
}

.positive-value {
    color: #4caf50;
}

.negative-value {
    color: #e53935;
}

.score-high {
    color: #2ecc71;
}

.score-medium {
    color: #f39c12;
}

.score-low {
    color: #e74c3c;
}

/* Font utilities */
.font-semibold {
    font-weight: 600;
}

/* Display utilities */
.flex {
    display: flex;
}

.flex-col {
    flex-direction: column;
}

.justify-center {
    justify-content: center;
}

.items-center {
    align-items: center;
}

.gap-2 {
    gap: 0.5rem;
}

.gap-4 {
    gap: 1rem;
}

/* Spacing utilities */
.mt-2 {
    margin-top: 0.5rem;
}

.mt-4 {
    margin-top: 1rem;
}

.mb-2 {
    margin-bottom: 0.5rem;
}

.mb-4 {
    margin-bottom: 1rem;
}

.my-6 {
    margin-top: 1.5rem;
    margin-bottom: 1.5rem;
}

/* ----- typography ----- */
/* Heading styles */
h1, h2, h3, h4, h5, h6 {
    margin-bottom: 0.5rem;
    font-weight: 500;
    line-height: 1.2;
}

h1 {
    font-size: 2.2rem;
    color: white;
    margin-bottom: 0.5rem;
}

h2 {
    font-size: 1.8rem;
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 0.5rem;
    color: var(--secondary-color);
}

h3 {
    font-size: 1.5rem;
    color: var(--secondary-color);
}

.section-title {
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border-color);
}

/* Text styles */
p {
    margin-bottom: 1rem;
}

.text-muted {
    color: var(--text-muted);
}

.text-center {
    text-align: center;
}

.text-sm {
    font-size: 0.875rem;
}

.text-lg {
    font-size: 1.125rem;
}

.text-xl {
    font-size: 1.25rem;
}

.text-2xl {
    font-size: 1.5rem;
}

.font-bold {
    font-weight: 700;
}

/* ----- charts ----- */
/* Chart containers */
.chart-container {
    margin: 1.5rem 0;
    display: none;
    min-height: 300px;
}

.chart-container.active {
    display: block;
}

.chart-plot {
    min-height: 300px;
    background-color: #fff;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    width: 100%;
    margin-bottom: 1.5rem;
}

/* Chart selector */
.chart-selector {
    display: flex;
    align-items: center;
    background: #f0f2f5;
    border-radius: 4px;
    padding: 0.25rem;
    margin-bottom: 1rem;
    max-width: fit-content;
    overflow-x: auto;
}

.chart-selector-option {
    padding: 0.5rem 1rem;
    border-radius: 4px;
    font-size: 0.875rem;
    cursor: pointer;
    background: none;
    border: none;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.chart-selector-option.active {
    background: #fff;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    font-weight: 500;
}

/* ----- tables ----- */
/* Table container */
.table-container {
    margin: 1.5rem 0;
    overflow-x: auto;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}

/* Data table */
.data-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
    margin-bottom: 0;
}

.data-table th {
    background-color: #f5f7fa;
    color: var(--secondary-color);
    text-align: left;
    padding: 12px 15px;
    font-weight: 600;
    border-bottom: 2px solid #eaeef2;
}

.data-table td {
    padding: 10px 15px;
    border-bottom: 1px solid #eaeef2;
}

.data-table tr:last-child td {
    border-bottom: none;
}

.data-table tr:hover td {
    background-color: #f9fbfd;
}

/* Striped table */
.striped-table tr:nth-child(even) td {
    background-color: #f5f7fa;
}

.striped-table tr:hover td {
    background-color: #eef2f7;
}

/* Table status colors */
.positive {
    color: var(--success-color);
}

.negative {
    color: var(--danger-color);
}

.warning {
    color: var(--warning-color);
}

/* Table filter */
.table-filter {
    margin-bottom: 1rem;
    padding: 0.75rem;
    background-color: #f8f9fa;
    border-radius: 4px;
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    align-items: center;
}

.filter-input {
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.filter-select {
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    background-color: white;
}

/* ----- cards ----- */
/* Base card styles */
.card {
    background-color: var(--card-bg);
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    margin-bottom: 1.5rem;
    overflow: hidden;
}

.card-header {
    background: linear-gradient(to right, var(--primary-color), var(--primary-color) 85%, #3498db);
    color: white;
    padding: 15px 20px;
    font-weight: bold;
    font-size: 1.2rem;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
}

.card-body {
    padding: 20px;
}

/* Score card */
.score-card {
    text-align: center;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    padding: 25px 20px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100%;
}

.score-value {
    font-size: 3rem;
    font-weight: bold;
    color: var(--primary-color);
    margin: 15px 0;
}

.score-label {
    font-size: 1.2rem;
    color: var(--secondary-color);
    margin-bottom: 10px;
    font-weight: 600;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
    width: 100%;
}

.score-desc {
    color: var(--text-muted);
    font-size: 0.95rem;
    margin-top: 10px;
}

/* Info card */
.info-card {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    padding: 25px 20px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    height: 100%;
}

.info-title {
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 20px;
    color: var(--secondary-color);
    text-align: center;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
}

/* Metric card */
.metric-card {
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
    text-align: center;
    transition: all 0.3s ease;
}

.metric-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
}

.metric-card-value {
    font-size: 2.2rem;
    font-weight: 700;
    margin: 0.75rem 0;
    color: var(--primary-color);
}

.metric-card-label {
    font-size: 1.1rem;
    color: var(--secondary-color);
    margin: 0 0 0.5rem 0;
    font-weight: 600;
}

.metric-card-desc {
    font-size: 0.9rem;
    color: var(--text-muted);
    margin-top: 0.5rem;
}

/* Summary card */
.summary-card {
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
    margin-bottom: 1.5rem;
}

/* ----- messages ----- */
/* Message container styles */
.message-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 1.5rem;
    text-align: center;
}

/* Loading message */
.loading-message {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    height: 100%;
    padding: 2rem;
    text-align: center;
}

/* Message icon */
.message-icon {
    font-size: 2rem;
    margin-bottom: 1rem;
}

/* Error message */
.error-message {
    padding: 15px;
    text-align: center;
    color: var(--danger-color);
    background-color: #fef2f2;
    border-radius: 4px;
}

/* No data message */
.no-data-message {
    padding: 20px;
    background-color: var(--light-color);
    border-radius: 8px;
    margin: 10px 0;
}

.no-data-message p {
    margin: 8px 0;
    color: #6c757d;
}

.no-data-message strong {
    color: #495057;
}

/* Data unavailable */
.data-unavailable {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 300px;
    background-color: #f8f9fa;
    border-radius: 5px;
}

.data-message {
    text-align: center;
    padding: 20px;
}

/* ----- buttons ----- */
/* Button styles */
.btn {
    display: inline-block;
    padding: 0.6rem 1.2rem;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 1px solid transparent;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    text-align: center;
}

.btn:hover {
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.btn-primary {
    background-color: var(--primary-color);
    color: white;
}

.btn-primary:hover {
    background-color: var(--primary-color-dark);
}

.btn-secondary {
    background-color: #fff;
    color: var(--text-color);
}

.btn-secondary:hover {
    color: var(--primary-color);
    background-color: #f8f9fa;
}

/* Tab buttons */
.tab-btn {
    background-color: #fff;
    border: 1px solid transparent;
    border-radius: 6px;
    padding: 0.6rem 1.2rem;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
    white-space: nowrap;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    color: var(--text-color);
}

.tab-btn:hover {
    color: var(--primary-color);
    background-color: #f8f9fa;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.tab-btn.active {
    background-color: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

/* Filter buttons */
.filter-button {
    padding: 0.5rem 1rem;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.filter-button:hover {
    background-color: var(--primary-color-dark);
}

.filter-reset {
    padding: 0.5rem 1rem;
    background-color: #f8f9fa;
    color: #666;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.filter-reset:hover {
    background-color: #e9ecef;
}



/* ----- Combined CSS Styles ----- */

/* =========================================
   MODEL ROBUSTNESS REPORT - MAIN STYLES
   ========================================= */

/* Import our component styles */
@import url('components/summary.css');
@import url('components/cards.css');
@import url('components/charts.css');
@import url('components/tables.css');
@import url('components/tabs.css');
@import url('components/widgets.css');
@import url('components/perturbation-details.css');

/* Variables específicas para o relatório de robustez */
:root {
    /* Cores específicas para o tema de robustez */
    --robustness-primary: #1b78de;
    --robustness-secondary: #3498db;
    --robustness-highlight: #4287f5;
    
    /* Cores para indicação de nível de robustez */
    --robust-high: #28a745;
    --robust-medium: #ffc107;
    --robust-low: #dc3545;
    
    /* Gradientes personalizados */
    --robustness-gradient: linear-gradient(135deg, #4287f5, #1a56b8);
}

/* Estilos adicionais específicos */
.robustness-report .section {
    margin-bottom: 2rem;
}

.robustness-report .chart-container {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    padding: 1rem;
}

/* Boxplot specific styles */
#boxplot-chart-container {
  min-height: 550px !important;
  padding: 20px 0;
  border-radius: 8px;
  background-color: #fafafa;
  margin-bottom: 25px;
}

/* Make sure violin plots have enough contrast */
.violin-plot .violin-fill {
  opacity: 0.8 !important;
}

/* Style for base score markers */
.base-score-marker {
  stroke: white !important;
  stroke-width: 1.5px !important;
}

/* Improve table presentation */
.boxplot-table {
  border-collapse: collapse;
  width: 100%;
  margin-top: 20px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.05);
}

.boxplot-table th {
  background-color: #f3f3f3;
  font-weight: bold;
  text-align: left;
  padding: 10px;
  border-bottom: 2px solid #ddd;
}

.boxplot-table td {
  padding: 8px 10px;
  border-bottom: 1px solid #eee;
}

.boxplot-table tr:nth-child(even) {
  background-color: #f9f9f9;
}

.boxplot-table tr:hover {
  background-color: #f0f0f0;
}

/* Score drop coloring */
.boxplot-table .text-danger {
  color: #d9534f;
  font-weight: bold;
}

.boxplot-table .text-warning {
  color: #f0ad4e;
}

.boxplot-table .text-success {
  color: #5cb85c;
}

.robustness-metrics {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin: 1.5rem 0;
}

.metric-item {
    flex: 1;
    min-width: 120px;
    background-color: #1b78de;
    border-radius: 8px;
    padding: 1.25rem;
    text-align: center;
}

.metric-value {
    font-size: 1.8rem;
    font-weight: bold;
    color: var(--robustness-primary);
}

.metric-label {
    font-size: 0.9rem;
    color: #1b78de;
    margin-top: 0.5rem;
}

/* ----- tabs ----- */
/* Estilos específicos para tabs de robustez */

/* Navegação principal em abas */
.main-tabs {
    display: flex;
    flex-wrap: nowrap;
    gap: var(--spacing-sm);
    margin: var(--spacing-lg) 0;
    background-color: var(--bg-card-alt);
    border-radius: var(--border-radius-md);
    padding: var(--spacing-sm);
    overflow-x: auto;
    justify-content: center;
    box-shadow: var(--shadow-sm);
}

/* Estilização específica dos botões das abas */
.tab-btn {
    background-color: var(--bg-card);
    border: 1px solid transparent;
    border-radius: var(--border-radius-sm);
    padding: 0.6rem 1.2rem;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
    white-space: nowrap;
    box-shadow: var(--shadow-sm);
    color: var(--text-color);
}

.tab-btn:hover {
    color: var(--primary-color);
    background-color: var(--light-color);
    box-shadow: var(--shadow-md);
}

.tab-btn.active {
    background-color: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    box-shadow: var(--shadow-md);
}

/* Conteúdo das abas */
.tab-content {
    display: none !important;
    padding: var(--spacing-md);
    background-color: var(--bg-card);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-card);
    margin-bottom: var(--spacing-xl);
}

.tab-content.active {
    display: block !important;
    animation: fadeIn 0.3s ease;
}

/* Sub-abas dentro de uma seção */
.section-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: var(--spacing-md);
    gap: var(--spacing-sm);
}

.section-tab {
    padding: var(--spacing-sm) var(--spacing-md);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.2s ease;
}

.section-tab:hover {
    color: var(--primary-color);
}

.section-tab.active {
    border-bottom: 2px solid var(--primary-color);
    color: var(--primary-color);
    font-weight: 500;
}

/* Tabs de resultados */
.results-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: var(--spacing-md);
}

.results-tabs .tab {
    padding: var(--spacing-sm) var(--spacing-md);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.2s ease;
}

.results-tabs .tab:hover {
    color: var(--primary-color);
}

.results-tabs .tab.active {
    border-bottom: 2px solid var(--primary-color);
    color: var(--primary-color);
    font-weight: 500;
}

/* Animação para transição de tabs */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Ajustes responsivos */
@media (max-width: 768px) {
    .main-tabs {
        overflow-x: auto;
        justify-content: flex-start;
        padding: var(--spacing-xs);
        gap: var(--spacing-xs);
    }
    
    .tab-btn {
        padding: 0.5rem 1rem;
        font-size: 0.85rem;
    }
    
    .tab-content {
        padding: var(--spacing-sm);
    }
}

/* ----- charts ----- */
/* Estilos específicos para charts de robustez */

/* Boxplot Chart Styles */
.boxplot-chart-container {
    margin: 20px auto;
    width: 100%;
    min-height: 500px;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.boxplot-chart {
    max-width: 100%;
    overflow-x: auto;
    margin-bottom: 20px;
}

.boxplot-legend {
    width: 100%;
    max-width: 800px;
    background-color: #f8f9fa;
    border-radius: 5px;
    padding: 10px;
    margin-top: 20px;
}

.model-selector-wrapper {
    margin: 10px 0 20px;
    text-align: right;
}

.boxplot-table {
    width: 100%;
    border-collapse: collapse;
}

.boxplot-table th {
    background-color: #f2f2f2;
    font-weight: bold;
    text-align: left;
    padding: 10px;
    border-bottom: 2px solid #ddd;
}

.boxplot-table td {
    padding: 8px 10px;
    border-bottom: 1px solid #ddd;
}

.boxplot-table tr:hover {
    background-color: #f5f5f5;
}

/* ----- widgets ----- */
/* Widget component styles */

.widget {
    margin-bottom: 1.5rem;
}

/* Chart selector widget */
.chart-selector {
    display: flex;
    flex-wrap: nowrap;
    gap: 5px;
    margin: 1.5rem 0;
    background-color: #f4f6f9;
    border-radius: 8px;
    padding: 8px;
    overflow-x: auto;
}

.chart-selector-option {
    background-color: #fff;
    border: 1px solid transparent;
    border-radius: 6px;
    padding: 0.6rem 1.2rem;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
    white-space: nowrap;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}

.chart-selector-option:hover {
    color: var(--primary-color);
    background-color: #f8f9fa;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.chart-selector-option.active {
    background-color: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

/* Expandable panel */
.expandable-panel {
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-bottom: 1rem;
    background-color: #fff;
    overflow: hidden;
}

.panel-header {
    padding: 0.75rem 1rem;
    background-color: #f5f5f5;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.panel-title {
    font-weight: 600;
    margin: 0;
}

.panel-icon {
    transition: transform 0.3s;
}

.panel-icon.expanded {
    transform: rotate(180deg);
}

.panel-content {
    padding: 1rem;
    display: none;
}

.panel-content.expanded {
    display: block;
}

/* Tooltip */
.tooltip {
    position: relative;
    display: inline-block;
}

.tooltip-icon {
    color: #888;
    cursor: pointer;
    font-size: 0.875rem;
    margin-left: 0.25rem;
}

.tooltip-content {
    visibility: hidden;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    background-color: #333;
    color: #fff;
    border-radius: 4px;
    padding: 0.5rem 1rem;
    width: 200px;
    font-size: 0.75rem;
    opacity: 0;
    transition: opacity 0.3s;
}

.tooltip:hover .tooltip-content {
    visibility: visible;
    opacity: 1;
}

/* Metric card */
.metric-card {
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
    text-align: center;
    transition: all 0.3s ease;
}

.metric-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
}

.metric-card-value {
    font-size: 2.2rem;
    font-weight: 700;
    margin: 0.75rem 0;
    color: var(--primary-color);
}

.metric-card-label {
    font-size: 1.1rem;
    color: var(--secondary-color);
    margin: 0 0 0.5rem 0;
    font-weight: 600;
}

.metric-card-desc {
    font-size: 0.9rem;
    color: var(--text-muted);
    margin-top: 0.5rem;
}

/* Progress bar */
.progress-container {
    background-color: #f1f1f1;
    border-radius: 4px;
    height: 8px;
    margin: 1rem 0;
}

.progress-bar {
    height: 100%;
    border-radius: 4px;
    background-color: #4a6ee0;
    width: 0;
    transition: width 0.5s;
}


/* ----- tables ----- */
/* Estilos específicos para tabelas de robustez */

/* Specialized tables */
.metrics-details-table th {
    background-color: #f0f7ff;
}

.feature-importance-table th {
    background-color: #f0fff7;
}

.perturbation-results-table th {
    background-color: #fff7f0;
}

/* Info table */
.info-table {
    width: 100%;
    border-collapse: collapse;
}

.info-table td {
    padding: 6px 0;
    border-bottom: 1px dotted #eaeef2;
}

.info-table tr:last-child td {
    border-bottom: none;
}

/* Table status indicators */
.text-red-600 {
    color: #dc2626;
}

.text-yellow-600 {
    color: #d97706;
}

.text-green-600 {
    color: #16a34a;
}

.font-semibold {
    font-weight: 600;
}

/* No data states */
.no-data {
    padding: 20px;
    text-align: center;
    color: #666;
    background-color: #f9f9f9;
    border-radius: 4px;
}

.error-message {
    padding: 15px;
    text-align: center;
    color: var(--danger-color);
    background-color: #fef2f2;
    border-radius: 4px;
}

/* Pagination */
.pagination {
    display: flex;
    justify-content: center;
    margin-top: 1rem;
    gap: 0.5rem;
}

.pagination-item {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border-radius: 4px;
    background-color: #f5f7fa;
    cursor: pointer;
    transition: all 0.2s;
}

.pagination-item:hover {
    background-color: #e9ecef;
}

.pagination-item.active {
    background-color: var(--primary-color);
    color: white;
}

/* Feature Importance Table Styles */
.feature-importance-container {
    background-color: white;
    border-radius: 0.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    overflow: hidden;
    margin-bottom: 1.5rem;
}

.feature-importance-header {
    padding: 1rem;
    border-bottom: 1px solid #e5e7eb;
}

.feature-importance-header h2 {
    font-size: 1.25rem;
    font-weight: 600;
    color: #1f2937;
    margin-bottom: 0.75rem;
}

.feature-importance-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-top: 0.75rem;
}

.search-container {
    flex-grow: 1;
    min-width: 200px;
}

.search-input {
    width: 100%;
    padding: 0.5rem 0.75rem;
    border: 1px solid #d1d5db;
    border-radius: 0.375rem;
    font-size: 0.875rem;
}

.toggle-container {
    display: flex;
    align-items: center;
}

.toggle-label {
    display: inline-flex;
    align-items: center;
    cursor: pointer;
    font-size: 0.875rem;
}

.toggle-checkbox {
    margin-right: 0.5rem;
    width: 1rem;
    height: 1rem;
}

/* Feature importance table styles */
.feature-importance-table-wrapper {
    overflow-x: auto;
}

.feature-importance-table {
    width: 100%;
    border-collapse: collapse;
}

.feature-importance-table th,
.feature-importance-table td {
    padding: 0.75rem 1rem;
    text-align: left;
    border-bottom: 1px solid #e5e7eb;
}

.feature-importance-table th {
    background-color: #f9fafb;
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
    color: #6b7280;
}

.feature-importance-table th.sortable {
    cursor: pointer;
    user-select: none;
}

.feature-importance-table th.sortable:hover {
    background-color: #f3f4f6;
}

.sort-indicator {
    display: inline-block;
    margin-left: 0.25rem;
}

.feature-importance-table tbody tr:hover {
    background-color: #f3f4f6;
}

.feature-importance-table .hovered-row {
    background-color: #eff6ff;
}

.feature-importance-table .feature-subset-row {
    background-color: #fffbeb;
}

.feature-importance-table .feature-subset-row.hovered-row {
    background-color: #fef3c7;
}

/* Cell content styling */
.feature-name {
    font-weight: 500;
    color: #111827;
}

.value-with-bar {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.value-text {
    min-width: 80px;
    font-family: monospace;
}

.progress-container {
    width: 100px;
    height: 0.5rem;
    background-color: #e5e7eb;
    border-radius: 9999px;
    overflow: hidden;
}

.progress-bar {
    height: 100%;
    border-radius: 9999px;
}

.progress-bar.positive {
    background-color: #3b82f6;
}

.progress-bar.negative {
    background-color: #ef4444;
}

.progress-bar.model {
    background-color: #10b981;
}

.impact-badge {
    display: inline-flex;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    font-weight: 500;
    border-radius: 9999px;
}

.impact-badge.positive {
    background-color: #dcfce7;
    color: #166534;
}

.impact-badge.negative {
    background-color: #fee2e2;
    color: #991b1b;
}

.subset-badge {
    display: inline-flex;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    font-weight: 500;
    border-radius: 9999px;
    text-align: center;
}

.subset-badge.included {
    background-color: #dbeafe;
    color: #1e40af;
}

.subset-badge.excluded {
    background-color: #f3f4f6;
    color: #4b5563;
}

/* Message styling */
.message-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
}

/* Footer styles */
.feature-importance-footer {
    padding: 1rem;
    border-top: 1px solid #e5e7eb;
    font-size: 0.875rem;
    color: #6b7280;
}

.table-summary-info {
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 1rem;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .feature-importance-controls {
        flex-direction: column;
    }
    
    .progress-container {
        width: 60px;
    }
    
    .value-text {
        min-width: 60px;
    }
    
    .table-summary-info {
        flex-direction: column;
    }
}

/* ----- cards ----- */
/* Estilos específicos para cards de robustez */

/* Robustness score card styles */
.robustness-score-card {
    background: linear-gradient(135deg, #1a5fb4, #3584e4);
    color: white;
    border-radius: 8px;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.robustness-score-title {
    font-size: 1rem;
    margin: 0;
}

.robustness-score-value {
    font-size: 2.5rem;
    font-weight: 700;
    margin: 0;
}

.robustness-score-description {
    font-size: 0.875rem;
    opacity: 0.9;
    margin: 0;
}

/* Metrics summary styles */
.metrics-summary {
    background-color: var(--light-color);
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
}

.metrics-summary-title {
    font-size: 1rem;
    margin: 0 0 0.75rem 0;
    font-weight: 600;
}

.metrics-summary-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

.metrics-summary-label {
    color: #495057;
}

.metrics-summary-value {
    font-weight: 600;
}

/* Model info styles */
.model-info {
    background-color: var(--light-color);
    border-radius: 8px;
    padding: 1rem;
}

.model-info-title {
    font-size: 1rem;
    margin: 0 0 0.75rem 0;
    font-weight: 600;
}

.model-info-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

.model-info-label {
    color: #495057;
}

.model-info-value {
    font-weight: 600;
}

/* ----- summary ----- */
/* Summary Section Styling */
.summary-stats {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-xl);
    background-color: var(--bg-card);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-card);
    width: 100%;
    justify-content: space-between;
    align-items: stretch;
    gap: var(--spacing-lg);
}

/* Estrutura de card */
.summary-card-wrapper {
    flex: 1;
    min-width: 0; /* Permite que os cards diminuam abaixo de seu conteúdo mínimo */
}

/* Removendo o wrapper aninhado de info-cards */
.info-cards-wrapper {
    display: none; /* Removemos este wrapper */
}

/* Wrapper para cada card - cada um com espaço exato */
.summary-card-wrapper {
    display: flex;
    margin-bottom: 0;
}

/* Card de pontuação */
.score-card {
    width: 100%;
    padding: var(--spacing-md);
    border-radius: var(--border-radius-md);
    background: var(--primary-gradient);
    color: white;
    text-align: center;
    box-shadow: var(--shadow-md);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    overflow: hidden;
}

.score-label {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: var(--spacing-sm);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Medidor gauge circular */
.score-gauge {
    width: 100%;
    max-width: 120px;
    margin: 0.25rem auto;
}

.gauge-svg {
    width: 100%;
    height: auto;
}

/* Métricas adicionais no card de score */
.score-metrics {
    display: flex;
    justify-content: center;
    width: 100%;
    max-width: 180px;
    gap: 10px;
    margin: var(--spacing-sm) auto;
}

.score-metrics .metric-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: #ffffff;
    border-radius: 4px;
    padding: 5px;
    width: 70px;
}

.score-metrics .metric-value {
    font-size: 0.95rem;
    font-weight: 700;
    white-space: nowrap;
}

.score-metrics .metric-label {
    font-size: 0.65rem;
    opacity: 0.8;
    text-align: center;
    white-space: nowrap;
}

/* Badges de classificação */
.score-badge {
    font-weight: 600;
    padding: 2px 5px;
    border-radius: 3px;
    margin-right: 3px;
    font-size: 0.9rem;
}

.score-badge.excellent {
    background-color: rgba(40, 167, 69, 0.8);
}

.score-badge.good {
    background-color: rgba(255, 193, 7, 0.8);
    color: rgba(0, 0, 0, 0.9);
}

.score-badge.moderate {
    background-color: rgba(253, 126, 20, 0.8);
}

.score-badge.needs-improvement {
    background-color: rgba(220, 53, 69, 0.8);
}

.score-desc {
    font-size: 0.8rem;
    margin-top: 0.5rem;
    padding: 0 var(--spacing-sm);
    width: 100%;
    box-sizing: border-box;
    overflow-wrap: break-word;
    word-wrap: break-word;
}

/* Cards de informação */
.info-card {
    width: 100%;
    height: 100%;
    padding: var(--spacing-lg);
    border-radius: var(--border-radius-md);
    background-color: var(--bg-card-alt);
    box-shadow: var(--shadow-sm);
    display: flex;
    flex-direction: column;
}

.info-title {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: var(--spacing-md);
    color: var(--text-color);
    border-bottom: 2px solid var(--primary-light);
    padding-bottom: var(--spacing-sm);
}

.info-table {
    width: 100%;
    border-collapse: collapse;
    flex-grow: 1;
}

.info-table td {
    padding: var(--spacing-sm) 0;
    font-size: 0.95rem;
}

.info-table td:first-child {
    color: var(--text-secondary);
    width: 50%;
}

.info-table td:last-child {
    font-weight: 500;
    color: var(--text-color);
}

/* Conteiner do sumário */
.report-summary {
    margin-bottom: var(--spacing-lg);
    width: 100%;
    box-sizing: border-box;
    padding: 0;
}

/* Responsive adjustments */
@media (max-width: 992px) {
    .summary-stats {
        padding: var(--spacing-md);
    }
    
    .score-card, .info-card {
        padding: var(--spacing-md);
    }
}

@media (max-width: 768px) {
    .summary-stats {
        flex-direction: column;
        gap: var(--spacing-md);
    }
    
    .summary-card-wrapper {
        width: 100%;
        margin-bottom: var(--spacing-md);
    }
    
    .summary-card-wrapper:last-child {
        margin-bottom: 0;
    }
    
    .score-gauge {
        max-width: 120px;
    }
}

@media (max-width: 576px) {
    .summary-stats {
        padding: var(--spacing-sm);
    }
    
    .score-metrics {
        max-width: 160px;
        gap: 5px;
    }
    
    .score-metrics .metric-item {
        width: 65px;
        padding: 4px;
    }
    
    .info-card, .score-card {
        padding: var(--spacing-sm);
    }
}

/* ----- perturbation-details ----- */
/* Perturbation Details Styles */

.tab-button {
    border-bottom: 2px solid transparent;
    transition: all 0.2s;
}

.tab-button.active {
    border-bottom: 2px solid #3b82f6;
    color: #3b82f6;
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

.level-btn {
    border-radius: 4px;
    padding: 0.25rem 0.75rem;
    margin-right: 0.25rem;
    transition: all 0.2s;
}

.level-btn:hover {
    background-color: #e5e7eb;
}

/* Feature summary panels */
.feature-summary {
    border: 1px solid #e5e7eb;
    border-radius: 0.375rem;
    overflow: hidden;
}

.feature-summary-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    background-color: #f9fafb;
    border-bottom: 1px solid #e5e7eb;
}

.feature-summary-content {
    padding: 1rem;
}

/* Tables */
.iterations-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
}

.iterations-table th {
    background-color: #f9fafb;
    font-weight: 600;
    text-align: left;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid #e5e7eb;
}

.iterations-table td {
    padding: 0.625rem 1rem;
    border-bottom: 1px solid #e5e7eb;
}

.iterations-table tr:last-child td {
    border-bottom: none;
}

.iterations-table .base-row,
.iterations-table .mean-row {
    background-color: #f9fafb;
    font-weight: 500;
}

/* Progress bars */
.impact-bar-bg {
    width: 100%;
    height: 8px;
    background-color: #e5e7eb;
    border-radius: 4px;
}

.impact-bar-fill {
    height: 8px;
    border-radius: 4px;
}

.impact-bar-fill.negative {
    background-color: #10b981;
}

.impact-bar-fill.positive {
    background-color: #ef4444;
}

/* Text colors */
.text-improvement {
    color: #10b981;
}

.text-degradation-low {
    color: #f59e0b;
}

.text-degradation-medium {
    color: #f97316;
}

.text-degradation-high {
    color: #ef4444;
}


    </style>
</head>
<body>
    <div class="report-container robustness-report">
        <!-- Header comum -->
<header class="report-header">
    <div class="header-content">
        <div class="header-logo">
            <img src="data:image/png;base64, " alt="Logo" class="logo">
        </div>
        <div class="header-info">
            <h1>Model Validation Report</h1>
            <p class="report-subtitle">Performance Analysis Report</p>
            <div class="report-metadata">
                <div class="metadata-item"><strong>Model:</strong> Unknown</div>
                <div class="metadata-item"><strong>Date:</strong> </div>
<div class="metadata-item"><strong>Report:</strong> Robustness</div>            </div>
        </div>
    </div>
</header>
        <!-- Summary section (inserido diretamente como o header) -->
<div class="summary-stats">
    <!-- Robustness Score Card -->
    <div class="summary-card-wrapper">
        <div class="score-card">
            <div class="score-label">Robustness Score</div>
            <div class="score-gauge">
                <svg viewBox="0 0 120 120" class="gauge-svg">
                    <!-- Fundo do medidor -->
                    <circle cx="60" cy="60" r="50" fill="none" stroke="#e6e6e6" stroke-width="10"></circle>
                    
                    <!-- Arco colorido do medidor baseado na pontuação -->
                    <circle 
                        cx="60" 
                        cy="60" 
                        r="50" 
                        fill="none" 
                            stroke="#28a745"
                        stroke-width="10" 
                        stroke-dasharray="312.743412502206 314" 
                        transform="rotate(-90 60 60)"
                    ></circle>
                    
                    <!-- Valor no centro -->
                    <text x="60" y="65" text-anchor="middle" font-size="24" font-weight="bold" fill="white">
                        99.6%
                    </text>
                </svg>
            </div>
            <div class="score-metrics">
                <div class="metric-item">
                    <span class="metric-value">77.4%</span>
                    <span class="metric-label">Base Score</span>
                </div>
                <div class="metric-item">
                    <span class="metric-value">0.4%</span>
                    <span class="metric-label">Impact</span>
                </div>
            </div>
            <div class="score-desc">
                    <span class="score-badge excellent">Excellent</span> resistance to perturbations
            </div>
        </div>
    </div>

    <!-- Model Information Card -->
    <div class="summary-card-wrapper">
        <div class="info-card">
            <div class="info-title">Model Information</div>
            <table class="info-table">
                <tr>
                    <td><strong>Type:</strong></td>
                    <td>RandomForestClassifier</td>
                </tr>
                <tr>
                    <td><strong>Features:</strong></td>
                    <td>0</td>
                </tr>
                <tr>
                    <td><strong>Primary Metric:</strong></td>
                    <td>AUC</td>
                </tr>
                <tr>
                    <td><strong>Critical Features:</strong></td>
                    <td>3</td>
                </tr>
                <tr>
                    <td><strong>Alternative Models:</strong></td>
                    <td>3</td>
                </tr>
            </table>
        </div>
    </div>
    
    <!-- Test Summary Card -->
    <div class="summary-card-wrapper">
        <div class="info-card">
            <div class="info-title">Test Summary</div>
            <table class="info-table">
                <tr>
                    <td><strong>Perturbation Levels:</strong></td>
                    <td>2</td>
                </tr>
                <tr>
                    <td><strong>Iterations Per Level:</strong></td>
                    <td>3</td>
                </tr>
                <tr>
                    <td><strong>Max Impact Level:</strong></td>
                    <td>
                        0.77% at 0.2
                    </td>
                </tr>
                <tr>
                    <td><strong>Feature Subset Impact:</strong></td>
                    <td>
                        0%
                    </td>
                </tr>
            </table>
        </div>
    </div>
</div>
        <div class="report-content">
            <!-- Navegação em abas usando componente comum -->
<div class="main-tabs" id="main-tabs">
        <button class="tab-btn active" data-tab="overview">Overview</button>
        <button class="tab-btn " data-tab="details">Details</button>
        <button class="tab-btn " data-tab="boxplot">Box Plot</button>
        <button class="tab-btn " data-tab="feature_impact">Feature Importance</button>
        <button class="tab-btn " data-tab="importance_comparison">Importance Comparison</button>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // Ensure at least first tab is active
        if (tabButtons.length > 0 && !document.querySelector('.tab-btn.active')) {
            tabButtons[0].classList.add('active');
            const firstTabId = tabButtons[0].getAttribute('data-tab');
            document.getElementById(firstTabId)?.classList.add('active');
        }
        
        // Add click handlers
        tabButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Remove active from all buttons and contents
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                
                // Add active to clicked button
                this.classList.add('active');
                
                // Show target tab content
                const targetTab = this.getAttribute('data-tab');
                const targetContent = document.getElementById(targetTab);
                
                if (targetContent) {
                    targetContent.classList.add('active');
                    // Trigger a custom event for tab change
                    document.dispatchEvent(new CustomEvent('tabchange', { 
                        detail: { tabId: targetTab, element: targetContent }
                    }));
                }
            });
        });
    });
</script>
            <!-- Conteúdo das abas -->
            <div id="overview" class="tab-content active">
<div class="section">
    <h2 class="section-title">Performance Overview</h2>
    <p>This section shows how the model's performance changes under different perturbation levels.</p>
    
    <!-- Performance charts selector -->
    <div class="chart-selector" id="performance_charts_selector">
        <button class="chart-selector-option active" data-chart-type="perturbation">Perturbation Impact</button>
        <button class="chart-selector-option" data-chart-type="worst">Worst Case</button>
    </div>
    
    <!-- Performance charts section -->
    <div class="performance-charts-container">
        <div class="chart-container active" data-chart-type="perturbation">
            <div id="perturbation-chart-plot" class="chart-plot" style="min-height: 400px; width: 100%;"></div>
        </div>
        <div class="chart-container" data-chart-type="worst">
            <div id="worst-score-chart-plot" class="chart-plot" style="min-height: 400px; width: 100%;"></div>
        </div>
    </div>
</div>

<!-- Removida a condição para sempre mostrar a seção de comparação de modelos -->
<div class="section model-comparison-section">
    <h2 class="section-title">Model Comparison</h2>
    <p>Comparison of robustness between different models.</p>
    
    <!-- Model comparison charts selector -->
    <div class="chart-selector" id="model_comparison_selector">
        <button class="chart-selector-option active" data-chart-type="overview">Overview</button>
        <button class="chart-selector-option" data-chart-type="details">Details by Level</button>
    </div>
    
    <!-- Model comparison charts -->
    <div class="chart-container active" data-chart-type="overview">
        <div id="model-comparison-chart-plot" class="chart-plot" style="min-height: 400px; width: 100%;"></div>
    </div>
    <div class="chart-container" data-chart-type="details">
        <div id="model-level-details-chart-plot" class="chart-plot" style="min-height: 400px; width: 100%;"></div>
    </div>
</div>

<div class="section results-tables-section">
    <h2 class="section-title">Detailed Results</h2>
    
    <!-- Results tabs -->
    <div class="results-tabs" id="result_tables_tabs">
        <div class="tab active" data-tab="model-comparison-results">Model Comparison</div>
        <div class="tab" data-tab="raw-perturbation-results">Raw Perturbation</div>
    </div>
    
    <!-- Results tab content -->
    <div id="model-comparison-results" class="tab-content active">
        <table class="data-table" id="model-comparison-table">
            <thead>
                <tr>
                    <th>Model</th>
                    <th>Base Score</th>
                    <th>Robustness Score</th>
                    <th>Raw Impact</th>
                </tr>
            </thead>
            <tbody>
                <!-- Will be filled by JavaScript -->
            </tbody>
        </table>
    </div>
    
    <div id="raw-perturbation-results" class="tab-content">
        <table class="data-table">
            <thead>
                <tr>
                    <th>Perturbation Level</th>
                    <th>Base Score</th>
                    <th>Perturbed Score</th>
                    <th>Impact</th>
                    <th>Subset Score</th>
                </tr>
            </thead>
            <tbody id="raw-perturbation-data">
                <!-- Will be filled by JavaScript -->
            </tbody>
        </table>
    </div>
</div>            </div>
            
            <div id="details" class="tab-content">
<div class="section">
    <h2 class="section-title">Detailed Performance Analysis</h2>
    <p>Detailed analysis of the model's performance under different perturbation types and levels.</p>
    
    <!-- Model Metrics Overview -->
    <div class="card mb-6">
        <div class="card-header">
            <h3 class="card-title">Model Metrics Overview</h3>
            <p class="card-subtitle">Comparative view of model metrics</p>
        </div>
        <div class="card-body">
            <!-- Metrics Radar Chart -->
            <div id="metrics-radar-chart" class="chart-container" style="min-height: 400px;"></div>
            
            <!-- Model Selection -->
            <div class="form-group mt-4">
                <label for="model-selector">Select Model:</label>
                <select id="model-selector" class="form-control">
                    <option value="all">All Models</option>
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            
            <!-- Model Info Cards -->
            <div class="model-info mt-4">
                <div class="row">
                    <div class="col-md-4">
                        <div class="info-card">
                            <h4>Dataset Info</h4>
                            <ul>
                                <li>Samples: <span id="n-samples">-</span></li>
                                <li>Features: <span id="n-features">-</span></li>
                                <li>Test Size: <span id="test-size">-</span></li>
                            </ul>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="info-card">
                            <h4>Test Configuration</h4>
                            <ul>
                                <li>Tests: <span id="tests-list">-</span></li>
                                <li>Verbose Mode: <span id="verbose-status">-</span></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Models Comparison Table -->
    <div class="card mb-6">
        <div class="card-header">
            <h3 class="card-title">Models Comparison</h3>
            <p class="card-subtitle">Performance metrics for all models</p>
        </div>
        <div class="card-body">
            <div class="table-responsive">
                <table id="models-table" class="data-table">
                    <thead>
                        <tr>
                            <th class="sortable" data-sort="name">Model Name</th>
                            <th class="sortable" data-sort="type">Type</th>
                            <th class="sortable" data-sort="accuracy">Accuracy</th>
                            <th class="sortable" data-sort="roc_auc">ROC AUC</th>
                            <th class="sortable" data-sort="f1">F1 Score</th>
                            <th class="sortable" data-sort="precision">Precision</th>
                            <th class="sortable" data-sort="recall">Recall</th>
                        </tr>
                    </thead>
                    <tbody id="models-table-body">
                        <!-- Table rows will be populated by JavaScript -->
                        <tr>
                            <td colspan="7" class="empty-table-message">Loading model data...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Perturbation Results Container -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">Perturbation Analysis</h3>
            <p class="card-subtitle">Detailed analysis of the model's performance under different perturbation types and levels</p>
        </div>
        <div class="card-body">
            <div id="perturbation-results-container" class="mt-4">
                <!-- This container will be populated by the embedded script below -->
                <div class="loading-indicator">
                    <p>Loading perturbation details...</p>
                </div>
                
                <script>
                // Embedded script to display real perturbation data
                document.addEventListener('DOMContentLoaded', function() {
                    const container = document.getElementById('perturbation-results-container');
                    if (!container) return;
                    
                    // Clear container
                    container.innerHTML = '';
                    
                    // Get the data directly from the template
                    const data = window.reportData?.perturbation_details_data;
                    
                    if (!data || !data.results || data.results.length === 0) {
                        container.innerHTML = `
                            <div class="p-6 text-center bg-red-50 rounded-lg border border-red-200">
                                <div class="text-4xl mb-3 text-red-500">❌</div>
                                <h3 class="text-lg font-medium text-red-800 mb-2">Error Loading Perturbation Results</h3>
                                <p class="text-red-600">No perturbation data available</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // Create main UI
                    renderPerturbationAnalysis(data);
                    
                    // Set up event listeners
                    setupTabEventListeners();
                });
                
                function renderPerturbationAnalysis(data) {
                    const container = document.getElementById('perturbation-results-container');
                    if (!container) return;
                    
                    // Create main container
                    const mainDiv = document.createElement('div');
                    mainDiv.className = 'bg-white rounded-lg shadow-md overflow-hidden';
                    
                    // Create header
                    mainDiv.appendChild(createHeader(data));
                    
                    // Create tabs container
                    const tabsContainer = document.createElement('div');
                    tabsContainer.className = 'p-4';
                    
                    // Add tabs navigation
                    const tabsNav = document.createElement('div');
                    tabsNav.className = 'tabs-nav flex border-b mb-4';
                    
                    const summaryTab = document.createElement('button');
                    summaryTab.className = 'tab-button active px-4 py-2 mr-2 font-medium border-b-2 border-blue-500 text-blue-600';
                    summaryTab.textContent = 'Summary';
                    summaryTab.dataset.tab = 'summary';
                    
                    const iterationsTab = document.createElement('button');
                    iterationsTab.className = 'tab-button px-4 py-2 mr-2 font-medium border-transparent text-gray-500';
                    iterationsTab.textContent = 'Iterations';
                    iterationsTab.dataset.tab = 'iterations';
                    
                    tabsNav.appendChild(summaryTab);
                    tabsNav.appendChild(iterationsTab);
                    tabsContainer.appendChild(tabsNav);
                    
                    // Add tab content containers
                    const summaryContent = document.createElement('div');
                    summaryContent.className = 'tab-content active';
                    summaryContent.id = 'summary-tab';
                    
                    const iterationsContent = document.createElement('div');
                    iterationsContent.className = 'tab-content hidden';
                    iterationsContent.id = 'iterations-tab';
                    
                    // Use the first level results by default
                    const selectedData = data.results[0];
                    
                    // Populate summary tab
                    const summaryDiv = createSummaryContent(selectedData, data.baseScore);
                    summaryContent.appendChild(summaryDiv);
                    
                    // Populate iterations tab
                    const iterationsDiv = createIterationsContent(selectedData, data.baseScore);
                    iterationsContent.appendChild(iterationsDiv);
                    
                    // Add tab content to tabs container
                    tabsContainer.appendChild(summaryContent);
                    tabsContainer.appendChild(iterationsContent);
                    
                    // Add tabs container to main div
                    mainDiv.appendChild(tabsContainer);
                    
                    // Add footer
                    mainDiv.appendChild(createFooter(data));
                    
                    // Add the main div to the container
                    container.appendChild(mainDiv);
                    
                    console.log("Perturbation analysis UI rendered with real data");
                }
                
                function createHeader(data) {
                    const header = document.createElement('div');
                    header.className = 'p-4 border-b border-gray-200';
                    
                    // Title
                    const title = document.createElement('h3');
                    title.className = 'text-xl font-medium mb-4';
                    title.textContent = 'Perturbation Test Results';
                    header.appendChild(title);
                    
                    // Level selector
                    const levelSelector = document.createElement('div');
                    levelSelector.className = 'mt-2';
                    
                    const levelLabel = document.createElement('label');
                    levelLabel.className = 'block text-sm font-medium mb-2';
                    levelLabel.textContent = 'Perturbation Level:';
                    levelSelector.appendChild(levelLabel);
                    
                    const levelButtonGroup = document.createElement('div');
                    levelButtonGroup.className = 'flex flex-wrap gap-2';
                    
                    // Add buttons for each perturbation level
                    data.results.forEach((result, index) => {
                        const button = document.createElement('button');
                        button.className = 'level-btn px-3 py-1 rounded text-sm ' + 
                            (index === 0 ? 'bg-blue-600 text-white' : 'bg-gray-200 hover:bg-gray-300 text-gray-700');
                        button.textContent = `${result.level * 100}%`;
                        button.dataset.level = result.level;
                        levelButtonGroup.appendChild(button);
                    });
                    
                    levelSelector.appendChild(levelButtonGroup);
                    header.appendChild(levelSelector);
                    
                    return header;
                }
                
                function createSummaryContent(selectedData, baseScore) {
                    const summaryDiv = document.createElement('div');
                    
                    // Feature summaries grid
                    const summaryGrid = document.createElement('div');
                    summaryGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';
                    
                    // All Features Summary
                    if (selectedData.allFeatures) {
                        summaryGrid.appendChild(createFeatureSummary(
                            selectedData.allFeatures, 
                            'allFeatures', 
                            'All Features'
                        ));
                    }
                    
                    // Feature Subset Summary
                    if (selectedData.featureSubset) {
                        summaryGrid.appendChild(createFeatureSummary(
                            selectedData.featureSubset, 
                            'featureSubset', 
                            'Feature Subset'
                        ));
                    }
                    
                    summaryDiv.appendChild(summaryGrid);
                    
                    // Analysis box
                    if (selectedData.allFeatures) {
                        const analysisBox = document.createElement('div');
                        analysisBox.className = 'mt-4 p-4 bg-blue-50 rounded-lg';
                        
                        const analysisTitle = document.createElement('h3');
                        analysisTitle.className = 'font-medium text-blue-800 mb-2';
                        analysisTitle.textContent = 'Analysis';
                        analysisBox.appendChild(analysisTitle);
                        
                        const analysisParagraph = document.createElement('p');
                        analysisParagraph.className = 'text-sm text-blue-700';
                        
                        // Generate analysis text
                        let analysisText = `At ${selectedData.level * 100}% perturbation, the model shows `;
                        if (selectedData.allFeatures.impact < 0) {
                            analysisText += 'improvement ';
                        } else {
                            analysisText += `degradation of ${formatNumber(selectedData.allFeatures.impact * 100, 2)}% `;
                        }
                        analysisText += 'when all features are perturbed. ';
                        
                        if (selectedData.featureSubset && selectedData.featureSubset.impact < selectedData.allFeatures.impact) {
                            analysisText += `The feature subset shows better robustness with only ${formatNumber(selectedData.featureSubset.impact * 100, 2)}% impact.`;
                        }
                        
                        analysisParagraph.textContent = analysisText;
                        analysisBox.appendChild(analysisParagraph);
                        
                        summaryDiv.appendChild(analysisBox);
                    }
                    
                    return summaryDiv;
                }
                
                function createFeatureSummary(featureData, sectionId, title) {
                    const summaryPanel = document.createElement('div');
                    summaryPanel.className = 'border rounded-lg overflow-hidden shadow-sm';
                    
                    // Header
                    const panelHeader = document.createElement('div');
                    panelHeader.className = 'bg-gray-50 p-3 flex justify-between items-center';
                    
                    const panelTitle = document.createElement('h4');
                    panelTitle.className = 'font-medium';
                    panelTitle.textContent = title;
                    panelHeader.appendChild(panelTitle);
                    
                    // Impact indicator
                    const impactSpan = document.createElement('span');
                    impactSpan.className = `text-sm font-semibold ${getImpactColorClass(featureData.impact)}`;
                    impactSpan.textContent = `Impact: ${formatNumber(featureData.impact * 100)}%`;
                    panelHeader.appendChild(impactSpan);
                    
                    summaryPanel.appendChild(panelHeader);
                    
                    // Content
                    const panelContent = document.createElement('div');
                    panelContent.className = 'p-4';
                    
                    // Stats table
                    const statsTable = document.createElement('table');
                    statsTable.className = 'min-w-full divide-y divide-gray-200';
                    
                    const tbody = document.createElement('tbody');
                    tbody.className = 'divide-y divide-gray-200';
                    
                    // Add rows to the table
                    const rows = [
                        { label: 'Base Score', value: formatNumber(featureData.baseScore) },
                        { 
                            label: 'Mean Score',
                            value: formatNumber(featureData.meanScore),
                            diff: featureData.meanScore - featureData.baseScore
                        },
                        { 
                            label: 'Worst Score',
                            value: formatNumber(featureData.worstScore),
                            diff: featureData.worstScore - featureData.baseScore
                        }
                    ];
                    
                    // Create rows
                    rows.forEach(rowData => {
                        const row = document.createElement('tr');
                        
                        const labelCell = document.createElement('td');
                        labelCell.className = 'px-3 py-2 text-sm font-medium text-gray-900';
                        labelCell.textContent = rowData.label;
                        row.appendChild(labelCell);
                        
                        const valueCell = document.createElement('td');
                        valueCell.className = 'px-3 py-2 text-sm text-gray-700';
                        
                        if (rowData.diff !== undefined) {
                            const valueText = document.createTextNode(rowData.value);
                            valueCell.appendChild(valueText);
                            
                            const diffSpan = document.createElement('span');
                            diffSpan.className = `ml-2 ${rowData.diff >= 0 ? 'text-green-600' : 'text-red-600'}`;
                            diffSpan.textContent = `(${rowData.diff >= 0 ? '+' : ''}${formatNumber(rowData.diff * 100, 2)}%)`;
                            valueCell.appendChild(diffSpan);
                        } else {
                            valueCell.textContent = rowData.value;
                        }
                        
                        row.appendChild(valueCell);
                        tbody.appendChild(row);
                    });
                    
                    statsTable.appendChild(tbody);
                    panelContent.appendChild(statsTable);
                    
                    // Impact bar
                    const barContainer = document.createElement('div');
                    barContainer.className = 'mt-3';
                    
                    const barLabels = document.createElement('div');
                    barLabels.className = 'flex justify-between text-xs text-gray-500 mb-1';
                    
                    const startLabel = document.createElement('span');
                    startLabel.textContent = '0% (Base)';
                    barLabels.appendChild(startLabel);
                    
                    const middleLabel = document.createElement('span');
                    middleLabel.textContent = 'Impact';
                    barLabels.appendChild(middleLabel);
                    
                    const endLabel = document.createElement('span');
                    endLabel.textContent = '25%';
                    barLabels.appendChild(endLabel);
                    
                    barContainer.appendChild(barLabels);
                    
                    const barBg = document.createElement('div');
                    barBg.className = 'w-full bg-gray-200 rounded-full h-2.5';
                    
                    const barFill = document.createElement('div');
                    barFill.className = `h-2.5 rounded-full ${featureData.impact < 0 ? 'bg-green-500' : 'bg-red-500'}`;
                    barFill.style.width = `${Math.min(Math.abs(featureData.impact) * 100 * 4, 100)}%`;
                    
                    barBg.appendChild(barFill);
                    barContainer.appendChild(barBg);
                    
                    panelContent.appendChild(barContainer);
                    summaryPanel.appendChild(panelContent);
                    
                    return summaryPanel;
                }
                
                function createIterationsContent(selectedData) {
                    const iterationsDiv = document.createElement('div');
                    
                    // Simple message if no iterations
                    if (!selectedData.allFeatures || !selectedData.allFeatures.iterations || 
                        selectedData.allFeatures.iterations.length === 0) {
                        const noDataMessage = document.createElement('p');
                        noDataMessage.className = 'text-center text-gray-500 my-8';
                        noDataMessage.textContent = 'No iteration data available for this perturbation level.';
                        iterationsDiv.appendChild(noDataMessage);
                        return iterationsDiv;
                    }
                    
                    // Table container
                    const tableContainer = document.createElement('div');
                    tableContainer.className = 'overflow-x-auto';
                    
                    const table = document.createElement('table');
                    table.className = 'min-w-full divide-y divide-gray-200';
                    
                    // Table header
                    const thead = document.createElement('thead');
                    thead.className = 'bg-gray-50';
                    
                    const headerRow = document.createElement('tr');
                    
                    const headers = [
                        { text: 'Iteration', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
                        { text: 'All Features', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
                        { text: 'Feature Subset', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
                        { text: 'Difference', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' }
                    ];
                    
                    headers.forEach(header => {
                        const th = document.createElement('th');
                        th.className = header.className;
                        th.textContent = header.text;
                        headerRow.appendChild(th);
                    });
                    
                    thead.appendChild(headerRow);
                    table.appendChild(thead);
                    
                    // Table body
                    const tbody = document.createElement('tbody');
                    tbody.className = 'bg-white divide-y divide-gray-200';
                    
                    // Base score row
                    const baseRow = document.createElement('tr');
                    baseRow.className = 'bg-gray-100';
                    
                    const baseIterationCell = document.createElement('td');
                    baseIterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
                    baseIterationCell.textContent = 'Base';
                    baseRow.appendChild(baseIterationCell);
                    
                    const baseAllFeaturesCell = document.createElement('td');
                    baseAllFeaturesCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
                    baseAllFeaturesCell.textContent = formatNumber(selectedData.allFeatures.baseScore);
                    baseRow.appendChild(baseAllFeaturesCell);
                    
                    const baseFeatureSubsetCell = document.createElement('td');
                    baseFeatureSubsetCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
                    baseFeatureSubsetCell.textContent = selectedData.featureSubset ? 
                        formatNumber(selectedData.featureSubset.baseScore) : 'N/A';
                    baseRow.appendChild(baseFeatureSubsetCell);
                    
                    const baseDifferenceCell = document.createElement('td');
                    baseDifferenceCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
                    baseDifferenceCell.textContent = '0.0000';
                    baseRow.appendChild(baseDifferenceCell);
                    
                    tbody.appendChild(baseRow);
                    
                    // Get iteration data
                    const allFeaturesIterations = selectedData.allFeatures.iterations || [];
                    const featureSubsetIterations = selectedData.featureSubset ? 
                        (selectedData.featureSubset.iterations || []) : [];
                    
                    const maxIterations = Math.max(allFeaturesIterations.length, featureSubsetIterations.length);
                    
                    // Create a row for each iteration
                    for (let i = 0; i < maxIterations; i++) {
                        const iterationRow = document.createElement('tr');
                        
                        // Iteration number
                        const iterationCell = document.createElement('td');
                        iterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-900';
                        iterationCell.textContent = `#${i + 1}`;
                        iterationRow.appendChild(iterationCell);
                        
                        // All features score
                        const allFeaturesScore = allFeaturesIterations[i];
                        const allFeaturesCell = document.createElement('td');
                        allFeaturesCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-700';
                        
                        if (allFeaturesScore !== undefined) {
                            const scoreText = document.createTextNode(formatNumber(allFeaturesScore));
                            allFeaturesCell.appendChild(scoreText);
                            
                            // Add difference if base score provided
                            const diff = allFeaturesScore - selectedData.allFeatures.baseScore;
                            const diffSpan = document.createElement('span');
                            diffSpan.className = `ml-2 text-xs ${diff >= 0 ? 'text-green-600' : 'text-red-600'}`;
                            diffSpan.textContent = `(${diff >= 0 ? '+' : ''}${formatNumber(diff * 100, 2)}%)`;
                            allFeaturesCell.appendChild(diffSpan);
                        } else {
                            allFeaturesCell.textContent = 'N/A';
                        }
                        
                        iterationRow.appendChild(allFeaturesCell);
                        
                        // Feature subset score
                        const featureSubsetScore = featureSubsetIterations[i];
                        const featureSubsetCell = document.createElement('td');
                        featureSubsetCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-700';
                        
                        if (featureSubsetScore !== undefined && selectedData.featureSubset) {
                            const scoreText = document.createTextNode(formatNumber(featureSubsetScore));
                            featureSubsetCell.appendChild(scoreText);
                            
                            // Add difference if base score provided
                            const diff = featureSubsetScore - selectedData.featureSubset.baseScore;
                            const diffSpan = document.createElement('span');
                            diffSpan.className = `ml-2 text-xs ${diff >= 0 ? 'text-green-600' : 'text-red-600'}`;
                            diffSpan.textContent = `(${diff >= 0 ? '+' : ''}${formatNumber(diff * 100, 2)}%)`;
                            featureSubsetCell.appendChild(diffSpan);
                        } else {
                            featureSubsetCell.textContent = 'N/A';
                        }
                        
                        iterationRow.appendChild(featureSubsetCell);
                        
                        // Difference between scores
                        const differenceCell = document.createElement('td');
                        differenceCell.className = 'px-6 py-3 whitespace-nowrap text-sm';
                        
                        if (allFeaturesScore !== undefined && featureSubsetScore !== undefined) {
                            const scoreDiff = featureSubsetScore - allFeaturesScore;
                            differenceCell.className += ` ${scoreDiff > 0 ? 'text-green-600' : 'text-red-600'}`;
                            differenceCell.textContent = `${scoreDiff > 0 ? '+' : ''}${formatNumber(scoreDiff)}`;
                        } else {
                            differenceCell.className += ' text-gray-500';
                            differenceCell.textContent = 'N/A';
                        }
                        
                        iterationRow.appendChild(differenceCell);
                        tbody.appendChild(iterationRow);
                    }
                    
                    // Mean row
                    if (selectedData.allFeatures.meanScore !== undefined) {
                        const meanRow = document.createElement('tr');
                        meanRow.className = 'bg-gray-100';
                        
                        const meanLabelCell = document.createElement('td');
                        meanLabelCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
                        meanLabelCell.textContent = 'Mean';
                        meanRow.appendChild(meanLabelCell);
                        
                        const allFeaturesMeanCell = document.createElement('td');
                        allFeaturesMeanCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
                        allFeaturesMeanCell.textContent = formatNumber(selectedData.allFeatures.meanScore);
                        meanRow.appendChild(allFeaturesMeanCell);
                        
                        const featureSubsetMeanCell = document.createElement('td');
                        featureSubsetMeanCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
                        featureSubsetMeanCell.textContent = selectedData.featureSubset ? 
                            formatNumber(selectedData.featureSubset.meanScore) : 'N/A';
                        meanRow.appendChild(featureSubsetMeanCell);
                        
                        const meanDiffCell = document.createElement('td');
                        
                        if (selectedData.featureSubset && selectedData.featureSubset.meanScore !== undefined) {
                            const meanDiff = selectedData.featureSubset.meanScore - selectedData.allFeatures.meanScore;
                            meanDiffCell.className = `px-6 py-3 whitespace-nowrap text-sm font-medium ${
                                meanDiff > 0 ? 'text-green-600' : 'text-red-600'
                            }`;
                            meanDiffCell.textContent = `${meanDiff > 0 ? '+' : ''}${formatNumber(meanDiff)}`;
                        } else {
                            meanDiffCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-500';
                            meanDiffCell.textContent = 'N/A';
                        }
                        
                        meanRow.appendChild(meanDiffCell);
                        tbody.appendChild(meanRow);
                    }
                    
                    table.appendChild(tbody);
                    tableContainer.appendChild(table);
                    iterationsDiv.appendChild(tableContainer);
                    
                    return iterationsDiv;
                }
                
                function createFooter(data) {
                    const footer = document.createElement('div');
                    footer.className = 'p-3 border-t border-gray-200 text-xs text-gray-500';
                    
                    const footerFlex = document.createElement('div');
                    footerFlex.className = 'flex justify-between';
                    
                    // Left section
                    const leftSpan = document.createElement('span');
                    leftSpan.textContent = `Perturbation Test • ${data.modelType || 'Model'} • ${data.metric || 'Score'} Metric`;
                    footerFlex.appendChild(leftSpan);
                    
                    // Right section
                    const rightSpan = document.createElement('span');
                    rightSpan.textContent = `Base Score: ${formatNumber(data.baseScore)} • Date: ${new Date().toLocaleDateString()}`;
                    footerFlex.appendChild(rightSpan);
                    
                    footer.appendChild(footerFlex);
                    
                    return footer;
                }
                
                function setupTabEventListeners() {
                    // Tab switching
                    document.querySelectorAll('.tab-button').forEach(button => {
                        button.addEventListener('click', function() {
                            // Remove active class from all buttons
                            document.querySelectorAll('.tab-button').forEach(btn => {
                                btn.classList.remove('active', 'text-blue-600', 'border-blue-500', 'border-b-2');
                                btn.classList.add('text-gray-500', 'border-transparent');
                            });
                            
                            // Add active class to clicked button
                            this.classList.add('active', 'text-blue-600', 'border-b-2', 'border-blue-500');
                            this.classList.remove('text-gray-500', 'border-transparent');
                            
                            // Hide all tab contents
                            document.querySelectorAll('.tab-content').forEach(content => {
                                content.classList.add('hidden');
                                content.classList.remove('active');
                            });
                            
                            // Show selected tab content
                            const tabId = this.dataset.tab;
                            const tabContent = document.getElementById(tabId + '-tab');
                            if (tabContent) {
                                tabContent.classList.remove('hidden');
                                tabContent.classList.add('active');
                            }
                        });
                    });
                    
                    // Level selection
                    document.querySelectorAll('.level-btn').forEach(button => {
                        button.addEventListener('click', function() {
                            // Update active state
                            document.querySelectorAll('.level-btn').forEach(btn => {
                                btn.classList.remove('bg-blue-600', 'text-white');
                                btn.classList.add('bg-gray-200', 'text-gray-700');
                            });
                            
                            this.classList.remove('bg-gray-200', 'text-gray-700');
                            this.classList.add('bg-blue-600', 'text-white');
                            
                            // Get selected level
                            const selectedLevel = parseFloat(this.dataset.level);
                            
                            // Update the UI with the selected level data
                            updateUIForLevel(selectedLevel);
                        });
                    });
                }
                
                function updateUIForLevel(selectedLevel) {
                    // Get the data
                    const data = window.reportData?.perturbation_details_data;
                    if (!data || !data.results || data.results.length === 0) return;
                    
                    // Find the data for the selected level
                    const selectedData = data.results.find(result => result.level === selectedLevel);
                    if (!selectedData) {
                        console.error(`No data found for level ${selectedLevel}`);
                        return;
                    }
                    
                    // Update summary tab
                    const summaryTab = document.getElementById('summary-tab');
                    if (summaryTab) {
                        summaryTab.innerHTML = '';
                        summaryTab.appendChild(createSummaryContent(selectedData, data.baseScore));
                    }
                    
                    // Update iterations tab
                    const iterationsTab = document.getElementById('iterations-tab');
                    if (iterationsTab) {
                        iterationsTab.innerHTML = '';
                        iterationsTab.appendChild(createIterationsContent(selectedData, data.baseScore));
                    }
                }
                
                function formatNumber(value, decimals = 4) {
                    if (value === undefined || value === null || isNaN(value)) {
                        return 'N/A';
                    }
                    return value.toFixed(decimals);
                }
                
                function getImpactColorClass(impact) {
                    if (impact < 0) return 'text-green-600';
                    if (impact < 0.05) return 'text-yellow-600';
                    if (impact < 0.1) return 'text-orange-600';
                    return 'text-red-600';
                }
                </script>
            </div>
        </div>
    </div>
</div>            </div>
            
            <div id="boxplot" class="tab-content">
<div class="section">
    <h2 class="section-title">Performance Distribution</h2>
    <p>Distribution of model performance under different perturbation levels.</p>
    
    <div id="boxplot-chart-container" class="chart-plot">
        <!-- Boxplot chart will be rendered here by the controller -->
        <div class="chart-loading-message">
            <div class="spinner"></div>
            <p>Carregando gráfico de boxplot...</p>
        </div>
    </div>
    
    <div class="table-container">
        <h3>Model Distribution Statistics</h3>
        <table class="data-table boxplot-table">
            <thead>
                <tr>
                    <th>Model</th>
                    <th>Base Score</th>
                    <th>Median</th>
                    <th>Mean</th>
                    <th>IQR</th>
                    <th>Min</th>
                    <th>Max</th>
                    <th>Std Dev</th>
                    <th>Score Drop</th>
                </tr>
            </thead>
            <tbody id="boxplot-table-body">
                <!-- Table content will be dynamically generated by BoxplotController -->
                <tr>
                    <td colspan="9" class="text-center">
                        <div class="loading-info">
                            <div class="loading-icon">⏳</div>
                            <p>Loading statistics...</p>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Local CSS for boxplot-specific styles only -->
<style>
    /* Local styling specific to boxplot visualization */
    #boxplot-chart-container .chart-loading-message {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        text-align: center;
    }
    
    #boxplot-chart-container .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin-bottom: 10px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .boxplot-table .text-danger {
        color: #d32f2f;
    }
    
    .boxplot-table .text-warning {
        color: #f0ad4e;
    }
    
    .boxplot-table .text-success {
        color: #5cb85c;
    }
    
    .loading-info {
        text-align: center;
        padding: 20px;
    }
    
    .loading-info .loading-icon {
        font-size: 24px;
        margin-bottom: 10px;
    }
</style>            </div>
            
            <div id="feature_impact" class="tab-content">
<div class="section">
    <h2 class="section-title">Feature Importance Analysis</h2>
    <p>Analysis of how each feature contributes to model robustness.</p>
    
    <div id="feature-importance-chart" class="chart-plot" style="min-height: 500px; min-width: 100%; display: block;">
        <div class="loading-message">
            <div class="message-container">
                <span class="message-icon">⏳</span>
                <h3>Loading Feature Importance Chart...</h3>
                <p>Please wait while the chart data is being prepared...</p>
            </div>
        </div>
    </div>
    
    <div class="feature-importance-container">
        <div class="feature-importance-header">
            <h2>Feature Importance Table</h2>
            <div class="feature-importance-controls">
                <div class="search-container">
                    <input type="text" id="feature-search" class="search-input" placeholder="Search features...">
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="show-subset-only" class="toggle-checkbox">
                        Show feature subset only
                    </label>
                </div>
            </div>
        </div>
        
        <div class="feature-importance-table-wrapper">
            <table class="feature-importance-table">
                <thead>
                    <tr>
                        <th class="sortable" data-sort="name">Feature <span class="sort-indicator">▼</span></th>
                        <th class="sortable" data-sort="impact">Robustness Impact <span class="sort-indicator"></span></th>
                        <th class="sortable" data-sort="importance">Model Importance <span class="sort-indicator"></span></th>
                        <th>Feature Subset</th>
                    </tr>
                </thead>
                <tbody id="feature-impact-data">
                    <!-- Mensagem de carregamento que será substituída por dados reais pelo FeatureImportanceHandler -->
                    <tr>
                        <td colspan="4" class="text-center py-4">
                            <div style="padding: 20px; text-align: center; background-color: #f9f9fa; border-radius: 5px;">
                                <div style="font-size: 24px; margin-bottom: 10px;">⏳</div>
                                <p>Carregando dados de importância de características...</p>
                            </div>
                        </td>
                    </tr>
                    <!-- Nenhum dado sintético/demo será exibido. O JavaScript substituirá esta linha por dados reais ou uma mensagem de erro. -->
                </tbody>
            </table>
        </div>
        
        <div class="feature-importance-footer">
            <div class="table-summary-info">
                <span>Total features: <span id="total-features-count">-</span></span>
                <span>In feature subset: <span id="subset-features-count">-</span></span>
            </div>
        </div>
    </div>
</div>

<style>
    /* Estilos para garantir que o gráfico seja exibido corretamente */
    #feature-importance-chart {
        min-height: 500px;
        width: 100%;
        display: block !important;
        position: relative;
        margin-bottom: 30px;
        background-color: #f9f9fa;
        border: 1px solid #eaeaea;
        border-radius: 5px;
    }
    
    .loading-message .message-container {
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.8);
        border-radius: 5px;
        text-align: center;
        max-width: 400px;
        margin: 100px auto;
    }
    
    .message-icon {
        font-size: 36px;
        display: block;
        margin-bottom: 15px;
    }
    
    #feature_impact.active {
        display: block !important;
    }
    
    /* Styles for the feature importance table */
    .feature-importance-table-wrapper {
        overflow-x: auto;
        margin-bottom: 20px;
        max-height: 500px;
        overflow-y: auto;
        border: 1px solid #eaeaea;
        border-radius: 5px;
    }
    
    .feature-importance-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
    }
    
    .feature-importance-table th {
        background-color: #f4f4f4;
        padding: 10px;
        text-align: left;
        border-bottom: 1px solid #ddd;
        cursor: pointer;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .feature-importance-table th.sortable:hover {
        background-color: #e4e4e4;
    }
    
    .feature-importance-table td {
        padding: 8px 10px;
        border-bottom: 1px solid #eee;
    }
    
    .feature-importance-table tr:hover {
        background-color: #f8f8f8;
    }
    
    /* Feature subset styling */
    .feature-subset-row {
        background-color: rgba(40, 180, 99, 0.1);
    }
    
    .feature-subset-row:hover {
        background-color: rgba(40, 180, 99, 0.2);
    }
    
    /* Subset badge styling */
    .subset-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: bold;
    }
    
    .subset-badge.included {
        background-color: rgba(40, 180, 99, 0.2);
        color: rgb(40, 180, 99);
    }
    
    .subset-badge.excluded {
        background-color: rgba(150, 150, 150, 0.2);
        color: #666;
    }
    
    /* Feature importance controls */
    .feature-importance-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        flex-wrap: wrap;
    }
    
    .feature-importance-controls {
        display: flex;
        align-items: center;
        gap: 15px;
        flex-wrap: wrap;
    }
    
    .search-container {
        position: relative;
    }
    
    .search-input {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 200px;
    }
    
    /* Feature count summary */
    .feature-importance-footer {
        margin-top: 15px;
        font-size: 14px;
        color: #666;
    }
    
    .table-summary-info {
        display: flex;
        gap: 20px;
    }
    
    .toggle-container {
        display: flex;
        align-items: center;
    }
    
    .toggle-label {
        display: flex;
        align-items: center;
        cursor: pointer;
    }
    
    .toggle-checkbox {
        margin-right: 8px;
    }
</style>

<script>
    // Feature table initialization is now handled by FeatureImportanceController in controllers/features.js
    console.log("Feature importance table will be initialized by FeatureImportanceController");
</script>            </div>
            
            <div id="importance_comparison" class="tab-content">
<div class="section">
    <h2 class="section-title">Model vs Robustness Importance Comparison</h2>
    <p>Comparison between model feature importance and robustness impact.</p>
    
    <div id="importance-comparison-chart-plot" class="chart-plot" style="min-height: 500px; min-width: 100%; display: block;">
        <!-- The chart will be rendered here by the standalone chart handler -->
        <div class="chart-loading-message">
            Loading feature comparison chart...
        </div>
    </div>
</div>

<style>
    /* Styles to ensure correct chart display */
    #importance-comparison-chart-plot {
        min-height: 500px;
        width: 100%;
        display: block !important;
        position: relative;
        margin-bottom: 30px;
        background-color: #f9f9fa;
        border: 1px solid #eaeaea;
        border-radius: 5px;
    }
    
    .chart-loading-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.8);
        border-radius: 5px;
        font-weight: bold;
    }
</style>

<!-- No inline JavaScript - initialization is handled by the standalone chart handler -->            </div>
        </div>
        
        <!-- Footer comum -->
<footer class="report-footer">
    <div class="footer-content">
        <div class="copyright">
            &copy; 2025 DeepBridge. All rights reserved.
        </div>
        <div class="footer-links">
            <button onclick="printReport()" class="btn btn-print">Print Report</button>
            <button onclick="exportData()" class="btn btn-export">Export Data</button>
        </div>
    </div>
</footer>

<script>
    function printReport() {
        window.print();
    }
    
    function exportData() {
        if (window.reportData) {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(window.reportData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "report_data.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        } else {
            alert("No report data available for export.");
        }
    }
</script>    </div>

    <!-- Inicialização de dados do relatório -->
    <script>
        // Disponibilizar dados do relatório para todos os componentes
        window.reportData = {"primary_model": {"base_score": 0.7743932845744681, "raw": {"by_level": {"0.1": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7741269863844957, "std_perturbed_score": 0.0010695922618614215, "impact": 0.00034387977695170887, "worst_score": 0.7726299387017863, "iterations": {"n_iterations": 3, "scores": [0.7726299387017863, 0.774687953336557, 0.7750630671151439]}, "perturbation": {"method": "raw", "level": 0.1, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7755857374985778, "std_perturbed_score": 0.0006923215804283103, "impact": -0.001539854422633586, "worst_score": 0.7746079527676641, "iterations": {"n_iterations": 3, "scores": [0.7761184079531233, 0.7746079527676641, 0.7760308517749459]}, "perturbation": {"method": "raw", "level": 0.1, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7741269863844957, "std_score": 0.0, "impact": 0.00034387977695170887, "worst_score": 0.7726299387017863}, "feature_subset": {"mean_score": 0.7755857374985778, "std_score": 0.0, "impact": -0.001539854422633586, "worst_score": 0.7746079527676641}}}, "0.2": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7684615386894603, "std_perturbed_score": 0.0038743398953506075, "impact": 0.007659862247213692, "worst_score": 0.7654456653913984, "iterations": {"n_iterations": 3, "scores": [0.7654456653913984, 0.7660078916116736, 0.7739310590653088]}, "perturbation": {"method": "raw", "level": 0.2, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7755647003119429, "std_perturbed_score": 0.0012368535841904488, "impact": -0.0015126883985293203, "worst_score": 0.7738735031004665, "iterations": {"n_iterations": 3, "scores": [0.7767970794458983, 0.7760235183894642, 0.7738735031004665]}, "perturbation": {"method": "raw", "level": 0.2, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7684615386894603, "std_score": 0.0, "impact": 0.007659862247213692, "worst_score": 0.7654456653913984}, "feature_subset": {"mean_score": 0.7755647003119429, "std_score": 0.0, "impact": -0.0015126883985293203, "worst_score": 0.7738735031004665}}}}, "overall": {}}, "quantile": {"by_level": {}, "overall": {}}, "feature_importance": {"feature_0": 5.576687342499577e-05, "feature_1": -0.0006520802335130412, "feature_2": -0.000145969552052319, "feature_3": -5.165370780358676e-05, "feature_4": 2.104410317832399e-06, "feature_5": -5.595818345393742e-05, "feature_6": 0.00014319555663335807, "feature_7": -6.236706942221606e-05, "feature_8": -7.786318176319173e-05, "feature_9": 0.0002685992805787275, "feature_10": -8.838523335283163e-05, "feature_11": -0.0002894520737290179, "feature_12": -1.1095981676321451e-05, "feature_13": 0.0013286481507255473, "feature_14": -3.520104531799845e-05, "feature_15": -0.0012846468440780015, "feature_16": -1.836576277452685e-05, "feature_17": -0.00012750813426329742, "feature_18": 0.0001219601434251845, "feature_19": 0.00010799451131535968}, "feature_subset": ["feature_6", "feature_11", "feature_17"], "metric": "AUC", "model_feature_importance": {"feature_0": 0.04441968784910863, "feature_1": 0.041051945787947214, "feature_2": 0.006536648686879563, "feature_3": 0.004557487553156789, "feature_4": 0.004525462110153291, "feature_5": 0.003418093109979521, "feature_6": 0.1703488869133524, "feature_7": 0.005880585740812931, "feature_8": 0.0055375016013733125, "feature_9": 0.004257599989473853, "feature_10": 0.03794462126493219, "feature_11": 0.1193658895869036, "feature_12": 0.02534450889628226, "feature_13": 0.09108320192389514, "feature_14": 0.0033145121242270405, "feature_15": 0.052665998640822775, "feature_16": 0.09355164224442686, "feature_17": 0.14771392008763776, "feature_18": 0.04304063919840231, "feature_19": 0.09544116669023245}, "avg_raw_impact": 0.004001871012082701, "avg_quantile_impact": 0, "avg_overall_impact": 0.004001871012082701, "model_type": "RandomForestClassifier", "n_iterations": 3, "metrics": {"accuracy": 0.739, "roc_auc": 0.7874212779746349, "f1": 0.7388510959863877, "precision": 0.7392365860430896, "recall": 0.739}, "model_name": "primary_model"}, "alternative_models": {"GLM_CLASSIFIER": {"base_score": 0.7229918079417453, "raw": {"by_level": {"0.1": {"runs": {"all_features": [{"base_score": 0.7229918079417453, "perturbed_score": 0.7224478040732735, "std_perturbed_score": 0.0007086341335658202, "impact": 0.0007524343464147493, "worst_score": 0.7214544636761862, "iterations": {"n_iterations": 3, "scores": [0.7230593639776994, 0.7214544636761862, 0.7228295845659347]}, "perturbation": {"method": "raw", "level": 0.1, "features": null}}], "feature_subset": [{"base_score": 0.7229918079417453, "perturbed_score": 0.7221796540182804, "std_perturbed_score": 0.00027262343470777335, "impact": 0.0011233238254482914, "worst_score": 0.721850910939811, "iterations": {"n_iterations": 3, "scores": [0.721850910939811, 0.722169579872568, 0.7225184712424622]}, "perturbation": {"method": "raw", "level": 0.1, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7224478040732735, "std_score": 0.0, "impact": 0.0007524343464147493, "worst_score": 0.7214544636761862}, "feature_subset": {"mean_score": 0.7221796540182804, "std_score": 0.0, "impact": 0.0011233238254482914, "worst_score": 0.721850910939811}}}, "0.2": {"runs": {"all_features": [{"base_score": 0.7229918079417453, "perturbed_score": 0.7199528233682254, "std_perturbed_score": 0.000855454798705253, "impact": 0.004203345791941235, "worst_score": 0.718850889606326, "iterations": {"n_iterations": 3, "scores": [0.7200713427295484, 0.718850889606326, 0.720936237768802]}, "perturbation": {"method": "raw", "level": 0.2, "features": null}}], "feature_subset": [{"base_score": 0.7229918079417453, "perturbed_score": 0.7200077867220389, "std_perturbed_score": 0.0010889028604493852, "impact": 0.004127323694305066, "worst_score": 0.7190317797815451, "iterations": {"n_iterations": 3, "scores": [0.7190317797815451, 0.7215273530833997, 0.7194642273011719]}, "perturbation": {"method": "raw", "level": 0.2, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7199528233682254, "std_score": 0.0, "impact": 0.004203345791941235, "worst_score": 0.718850889606326}, "feature_subset": {"mean_score": 0.7200077867220389, "std_score": 0.0, "impact": 0.004127323694305066, "worst_score": 0.7190317797815451}}}}, "overall": {}}, "quantile": {"by_level": {}, "overall": {}}, "feature_importance": {"feature_0": 0.0, "feature_1": 0.0, "feature_2": 0.0, "feature_3": 0.0, "feature_4": -2.458935772593204e-06, "feature_5": 2.9302317956744235e-05, "feature_6": 0.0017937936461100191, "feature_7": -1.4138880692436527e-05, "feature_8": 0.0, "feature_9": -1.8442018294704972e-06, "feature_10": 0.0, "feature_11": 0.0008165715878166494, "feature_12": 0.0, "feature_13": 0.0, "feature_14": 1.3729058063636868e-05, "feature_15": 0.0, "feature_16": -0.0001374954919511012, "feature_17": 0.0, "feature_18": 0.0005635061145536162, "feature_19": 0.0}, "feature_subset": ["feature_6", "feature_11", "feature_17"], "metric": "AUC", "model_feature_importance": {"feature_0": 0.0, "feature_1": 0.0, "feature_2": 0.0, "feature_3": 0.0, "feature_4": 0.019967478021303584, "feature_5": 0.04579087728866096, "feature_6": 0.33364640215534525, "feature_7": 0.07921350594114994, "feature_8": 0.0, "feature_9": 0.00046529671566341636, "feature_10": 0.0, "feature_11": 0.2810146641235498, "feature_12": 0.0, "feature_13": 0.0, "feature_14": 0.0280040145809102, "feature_15": 0.0, "feature_16": 0.04203101800036431, "feature_17": 0.0, "feature_18": 0.16986674317305256, "feature_19": 0.0}, "avg_raw_impact": 0.002477890069177992, "avg_quantile_impact": 0, "avg_overall_impact": 0.002477890069177992, "model_type": "SGDClassifier", "n_iterations": 3, "metrics": {"accuracy": 0.6595, "roc_auc": 0.707588618222805, "f1": 0.6591826568445812, "precision": 0.6597247027573995, "recall": 0.6595}, "model_name": "GLM_CLASSIFIER", "robustness_score": 0.997522109930822}, "GAM_CLASSIFIER": {"base_score": 0.47251002673796794, "raw": {"by_level": {"0.1": {"runs": {"all_features": [{"base_score": 0.47251002673796794, "perturbed_score": 0.49001326231653203, "std_perturbed_score": 0.0017298014504056026, "impact": -0.037043098745226356, "worst_score": 0.4883903618870179, "iterations": {"n_iterations": 3, "scores": [0.4883903618870179, 0.49240994602628285, 0.48923947903629533]}, "perturbation": {"method": "raw", "level": 0.1, "features": null}}], "feature_subset": [{"base_score": 0.47251002673796794, "perturbed_score": 0.4670695436056434, "std_perturbed_score": 0.01858088056943207, "impact": 0.011514005681283827, "worst_score": 0.4532672232335874, "iterations": {"n_iterations": 3, "scores": [0.49333550816361366, 0.4546058994197292, 0.4532672232335874]}, "perturbation": {"method": "raw", "level": 0.1, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.49001326231653203, "std_score": 0.0, "impact": -0.037043098745226356, "worst_score": 0.4883903618870179}, "feature_subset": {"mean_score": 0.4670695436056434, "std_score": 0.0, "impact": 0.011514005681283827, "worst_score": 0.4532672232335874}}}, "0.2": {"runs": {"all_features": [{"base_score": 0.47251002673796794, "perturbed_score": 0.5053925568655896, "std_perturbed_score": 0.00854044008449594, "impact": -0.06959117958751122, "worst_score": 0.49829287674934575, "iterations": {"n_iterations": 3, "scores": [0.5004804478609626, 0.49829287674934575, 0.5174043459864603]}, "perturbation": {"method": "raw", "level": 0.2, "features": null}}], "feature_subset": [{"base_score": 0.47251002673796794, "perturbed_score": 0.4888568096484242, "std_perturbed_score": 0.010774801700516416, "impact": -0.034595631807664125, "worst_score": 0.47702628107577655, "iterations": {"n_iterations": 3, "scores": [0.48645501479121633, 0.47702628107577655, 0.5030891330782796]}, "perturbation": {"method": "raw", "level": 0.2, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.5053925568655896, "std_score": 0.0, "impact": -0.06959117958751122, "worst_score": 0.49829287674934575}, "feature_subset": {"mean_score": 0.4888568096484242, "std_score": 0.0, "impact": -0.034595631807664125, "worst_score": 0.47702628107577655}}}}, "overall": {}}, "quantile": {"by_level": {}, "overall": {}}, "feature_importance": {"feature_0": 0.10062770033423009, "feature_1": 0.034042709959804685, "feature_2": 0.0010396874666868115, "feature_3": 0.00015049758263254375, "feature_4": 0.00035649114886098627, "feature_5": -0.00011851684632309979, "feature_6": -0.04393839632284244, "feature_7": -0.0002106966156855064, "feature_8": 1.6303904785232047e-05, "feature_9": 0.00022543283731846217, "feature_10": 0.026616594866778347, "feature_11": -0.030171159646581496, "feature_12": 0.052764922775927973, "feature_13": 0.10357745295382863, "feature_14": -0.0002542782073229227, "feature_15": -0.05793717980071614, "feature_16": 0.07061095747816215, "feature_17": 0.10560321312338927, "feature_18": 0.027158229395940325, "feature_19": -0.015014171855697804}, "feature_subset": ["feature_6", "feature_11", "feature_17"], "metric": "AUC", "model_feature_importance": {}, "avg_raw_impact": -0.05331713916636879, "avg_quantile_impact": 0, "avg_overall_impact": -0.05331713916636879, "model_type": "LogisticGAM", "n_iterations": 3, "metrics": {"accuracy": 0.472, "roc_auc": 0.48684690847592554, "f1": 0.4684885820499203, "precision": 0.47216730923917566, "recall": 0.472}, "model_name": "GAM_CLASSIFIER", "robustness_score": 1.0533171391663687}, "GBM": {"base_score": 0.8713973077141883, "raw": {"by_level": {"0.1": {"runs": {"all_features": [{"base_score": 0.8713973077141883, "perturbed_score": 0.8094466449539196, "std_perturbed_score": 0.0022811526360311508, "impact": 0.07109347505648718, "worst_score": 0.8071404063317785, "iterations": {"n_iterations": 3, "scores": [0.8086461948173853, 0.8071404063317785, 0.8125533337125954]}, "perturbation": {"method": "raw", "level": 0.1, "features": null}}], "feature_subset": [{"base_score": 0.8713973077141883, "perturbed_score": 0.8578526188038079, "std_perturbed_score": 7.127562635895343e-05, "impact": 0.015543643284726516, "worst_score": 0.857768766355672, "iterations": {"n_iterations": 3, "scores": [0.857846100238935, 0.8579429898168165, 0.857768766355672]}, "perturbation": {"method": "raw", "level": 0.1, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.8094466449539196, "std_score": 0.0, "impact": 0.07109347505648718, "worst_score": 0.8071404063317785}, "feature_subset": {"mean_score": 0.8578526188038079, "std_score": 0.0, "impact": 0.015543643284726516, "worst_score": 0.857768766355672}}}, "0.2": {"runs": {"all_features": [{"base_score": 0.8713973077141883, "perturbed_score": 0.7817098551219327, "std_perturbed_score": 0.0022936049933470672, "impact": 0.10292372009677178, "worst_score": 0.7788619830185459, "iterations": {"n_iterations": 3, "scores": [0.7817891149448174, 0.7844784674024349, 0.7788619830185459]}, "perturbation": {"method": "raw", "level": 0.2, "features": null}}], "feature_subset": [{"base_score": 0.8713973077141883, "perturbed_score": 0.8500411558482194, "std_perturbed_score": 0.00039731196370965837, "impact": 0.024507938774781718, "worst_score": 0.849647375270224, "iterations": {"n_iterations": 3, "scores": [0.849647375270224, 0.8498909325577426, 0.8505851597166914]}, "perturbation": {"method": "raw", "level": 0.2, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7817098551219327, "std_score": 0.0, "impact": 0.10292372009677178, "worst_score": 0.7788619830185459}, "feature_subset": {"mean_score": 0.8500411558482194, "std_score": 0.0, "impact": 0.024507938774781718, "worst_score": 0.849647375270224}}}}, "overall": {}}, "quantile": {"by_level": {}, "overall": {}}, "feature_importance": {"feature_0": 0.0023087817011200507, "feature_1": 0.004085081495913968, "feature_2": 0.003994634377725702, "feature_3": 0.004301508528721479, "feature_4": 0.0028405835539258317, "feature_5": 0.002678390789355296, "feature_6": 0.005067078779100146, "feature_7": 0.003559060098029992, "feature_8": 0.003388366664456624, "feature_9": 0.0033518137877452427, "feature_10": 0.004666527255695153, "feature_11": 0.0033657548849095782, "feature_12": 0.0012495983433897168, "feature_13": 0.013941947231247273, "feature_14": 0.005590039936143172, "feature_15": 0.0012846210996806872, "feature_16": 0.004285357257616295, "feature_17": 0.012168282643844189, "feature_18": 0.001314883481330168, "feature_19": 0.002404329220709812}, "feature_subset": ["feature_6", "feature_11", "feature_17"], "metric": "AUC", "model_feature_importance": {"feature_0": 0.01912664116114662, "feature_1": 0.05042279320836686, "feature_2": 0.027905801602033077, "feature_3": 0.031494832424367576, "feature_4": 0.023905519163165797, "feature_5": 0.02920219155112813, "feature_6": 0.22930332557722669, "feature_7": 0.03538933849657314, "feature_8": 0.027230752476294782, "feature_9": 0.030342584572762076, "feature_10": 0.021174578240922417, "feature_11": 0.01650670684373592, "feature_12": 0.016313486168707533, "feature_13": 0.10452721880603731, "feature_14": 0.0315208816432807, "feature_15": 0.015541918683932345, "feature_16": 0.03673596785548919, "feature_17": 0.19053554839462544, "feature_18": 0.01802761802660539, "feature_19": 0.044792295103599}, "avg_raw_impact": 0.08700859757662949, "avg_quantile_impact": 0, "avg_overall_impact": 0.08700859757662949, "model_type": "GradientBoostingClassifier", "n_iterations": 3, "metrics": {"accuracy": 0.72, "roc_auc": 0.7617011658410667, "f1": 0.7200084002100052, "precision": 0.72006864006864, "recall": 0.72}, "model_name": "GBM", "robustness_score": 0.9129914024233705}}, "initial_results": {"config": {"tests": ["robustness"], "verbose": false, "dataset_info": {"n_samples": 10000, "n_features": 20, "test_size": 0.2}}, "models": {"primary_model": {"name": "primary_model", "type": "RandomForestClassifier", "metrics": {"accuracy": 0.739, "roc_auc": 0.7874212779746349, "f1": 0.7388510959863877, "precision": 0.7392365860430896, "recall": 0.739}, "hyperparameters": {"bootstrap": true, "ccp_alpha": 0.0, "class_weight": null, "criterion": "gini", "max_depth": 5, "max_features": "sqrt", "max_leaf_nodes": null, "max_samples": null, "min_impurity_decrease": 0.0, "min_samples_leaf": 1, "min_samples_split": 2, "min_weight_fraction_leaf": 0.0, "monotonic_cst": null, "n_estimators": 50, "n_jobs": null, "oob_score": false, "random_state": 42, "verbose": 0, "warm_start": false}, "feature_importance": {"feature_6": 0.17034888691335243, "feature_17": 0.14771392008763778, "feature_11": 0.11936588958690363, "feature_19": 0.09544116669023248, "feature_16": 0.09355164224442687, "feature_13": 0.09108320192389516, "feature_15": 0.05266599864082279, "feature_0": 0.04441968784910864, "feature_18": 0.043040639198402314, "feature_1": 0.04105194578794722, "feature_10": 0.0379446212649322, "feature_12": 0.025344508896282265, "feature_2": 0.0065366486868795644, "feature_7": 0.0058805857408129325, "feature_8": 0.005537501601373313, "feature_3": 0.00455748755315679, "feature_4": 0.004525462110153292, "feature_9": 0.0042575999894738535, "feature_5": 0.0034180931099795217, "feature_14": 0.0033145121242270413}}, "GLM_CLASSIFIER": {"name": "GLM_CLASSIFIER", "type": "SGDClassifier", "metrics": {"accuracy": 0.6595, "roc_auc": 0.707588618222805, "f1": 0.6591826568445812, "precision": 0.6597247027573995, "recall": 0.6595}, "hyperparameters": {"alpha": 0.001, "average": false, "class_weight": null, "early_stopping": false, "epsilon": 0.1, "eta0": 0.0, "fit_intercept": true, "l1_ratio": 0.5, "learning_rate": "optimal", "loss": "log_loss", "max_iter": 1000, "n_iter_no_change": 5, "n_jobs": null, "penalty": "elasticnet", "power_t": 0.5, "random_state": 42, "shuffle": true, "tol": 0.001, "validation_fraction": 0.1, "verbose": 0, "warm_start": false}, "feature_importance": {"feature_6": 0.44653529829201, "feature_11": 0.37609566912222736, "feature_18": 0.22734097038863, "feature_7": 0.10601530924861681, "feature_5": 0.06128417065808743, "feature_16": 0.05625216708187674, "feature_14": 0.03747914235993568, "feature_4": 0.026723452423834587, "feature_9": 0.0006227293517354285, "feature_0": 0.0, "feature_1": 0.0, "feature_2": 0.0, "feature_3": 0.0, "feature_8": 0.0, "feature_10": 0.0, "feature_12": 0.0, "feature_13": 0.0, "feature_15": 0.0, "feature_17": 0.0, "feature_19": 0.0}}, "GAM_CLASSIFIER": {"name": "GAM_CLASSIFIER", "type": "LogisticGAM", "metrics": {"accuracy": 0.472, "roc_auc": 0.48684690847592554, "f1": 0.4684885820499203, "precision": 0.47216730923917566, "recall": 0.472}, "hyperparameters": {"n_splines": "10", "spline_order": "3", "lam": "0.6", "max_iter": "100", "random_state": "42", "model": "<statsmodels.gam.generalized_additive_model.GLMGamResultsWrapper object at 0x7fddcaa44cb0>", "smoother": "<statsmodels.gam.smooth_basis.BSplines object at 0x7fddca985ee0>"}}, "GBM": {"name": "GBM", "type": "GradientBoostingClassifier", "metrics": {"accuracy": 0.72, "roc_auc": 0.7617011658410667, "f1": 0.7200084002100052, "precision": 0.72006864006864, "recall": 0.72}, "hyperparameters": {"ccp_alpha": 0.0, "criterion": "friedman_mse", "init": null, "learning_rate": 0.1, "loss": "log_loss", "max_depth": 5, "max_features": null, "max_leaf_nodes": null, "min_impurity_decrease": 0.0, "min_samples_leaf": 1, "min_samples_split": 2, "min_weight_fraction_leaf": 0.0, "n_estimators": 100, "n_iter_no_change": null, "random_state": 42, "subsample": 1.0, "tol": 0.0001, "validation_fraction": 0.1, "verbose": 0, "warm_start": false}, "feature_importance": {"feature_6": 0.22930332557722669, "feature_17": 0.19053554839462544, "feature_13": 0.10452721880603731, "feature_1": 0.05042279320836686, "feature_19": 0.044792295103599, "feature_16": 0.03673596785548919, "feature_7": 0.03538933849657314, "feature_14": 0.0315208816432807, "feature_3": 0.031494832424367576, "feature_9": 0.030342584572762076, "feature_5": 0.02920219155112813, "feature_2": 0.027905801602033077, "feature_8": 0.027230752476294782, "feature_4": 0.023905519163165797, "feature_10": 0.021174578240922417, "feature_0": 0.01912664116114662, "feature_18": 0.01802761802660539, "feature_11": 0.01650670684373592, "feature_12": 0.016313486168707533, "feature_15": 0.015541918683932345}}}, "test_configs": {"robustness": {"quick": {"perturbation_methods": ["raw", "quantile"], "levels": [0.1, 0.2], "n_trials": 3}, "medium": {"perturbation_methods": ["raw", "quantile", "adversarial"], "levels": [0.1, 0.2, 0.4], "n_trials": 6}, "full": {"perturbation_methods": ["raw", "quantile", "adversarial", "custom"], "levels": [0.1, 0.2, 0.4, 0.6, 0.8, 1.0], "n_trials": 10}}}}, "config": {"name": "quick", "tests": ["robustness"]}, "experiment_type": "binary_classification", "model_type": "RandomForestClassifier", "feature_importance": {"feature_0": 5.576687342499577e-05, "feature_1": -0.0006520802335130412, "feature_2": -0.000145969552052319, "feature_3": -5.165370780358676e-05, "feature_4": 2.104410317832399e-06, "feature_5": -5.595818345393742e-05, "feature_6": 0.00014319555663335807, "feature_7": -6.236706942221606e-05, "feature_8": -7.786318176319173e-05, "feature_9": 0.0002685992805787275, "feature_10": -8.838523335283163e-05, "feature_11": -0.0002894520737290179, "feature_12": -1.1095981676321451e-05, "feature_13": 0.0013286481507255473, "feature_14": -3.520104531799845e-05, "feature_15": -0.0012846468440780015, "feature_16": -1.836576277452685e-05, "feature_17": -0.00012750813426329742, "feature_18": 0.0001219601434251845, "feature_19": 0.00010799451131535968}, "model_feature_importance": {"feature_0": 0.04441968784910863, "feature_1": 0.041051945787947214, "feature_2": 0.006536648686879563, "feature_3": 0.004557487553156789, "feature_4": 0.004525462110153291, "feature_5": 0.003418093109979521, "feature_6": 0.1703488869133524, "feature_7": 0.005880585740812931, "feature_8": 0.0055375016013733125, "feature_9": 0.004257599989473853, "feature_10": 0.03794462126493219, "feature_11": 0.1193658895869036, "feature_12": 0.02534450889628226, "feature_13": 0.09108320192389514, "feature_14": 0.0033145121242270405, "feature_15": 0.052665998640822775, "feature_16": 0.09355164224442686, "feature_17": 0.14771392008763776, "feature_18": 0.04304063919840231, "feature_19": 0.09544116669023245}, "base_score": 0.7743932845744681, "raw": {"by_level": {"0.1": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7741269863844957, "std_perturbed_score": 0.0010695922618614215, "impact": 0.00034387977695170887, "worst_score": 0.7726299387017863, "iterations": {"n_iterations": 3, "scores": [0.7726299387017863, 0.774687953336557, 0.7750630671151439]}, "perturbation": {"method": "raw", "level": 0.1, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7755857374985778, "std_perturbed_score": 0.0006923215804283103, "impact": -0.001539854422633586, "worst_score": 0.7746079527676641, "iterations": {"n_iterations": 3, "scores": [0.7761184079531233, 0.7746079527676641, 0.7760308517749459]}, "perturbation": {"method": "raw", "level": 0.1, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7741269863844957, "std_score": 0.0, "impact": 0.00034387977695170887, "worst_score": 0.7726299387017863}, "feature_subset": {"mean_score": 0.7755857374985778, "std_score": 0.0, "impact": -0.001539854422633586, "worst_score": 0.7746079527676641}}}, "0.2": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7684615386894603, "std_perturbed_score": 0.0038743398953506075, "impact": 0.007659862247213692, "worst_score": 0.7654456653913984, "iterations": {"n_iterations": 3, "scores": [0.7654456653913984, 0.7660078916116736, 0.7739310590653088]}, "perturbation": {"method": "raw", "level": 0.2, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7755647003119429, "std_perturbed_score": 0.0012368535841904488, "impact": -0.0015126883985293203, "worst_score": 0.7738735031004665, "iterations": {"n_iterations": 3, "scores": [0.7767970794458983, 0.7760235183894642, 0.7738735031004665]}, "perturbation": {"method": "raw", "level": 0.2, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7684615386894603, "std_score": 0.0, "impact": 0.007659862247213692, "worst_score": 0.7654456653913984}, "feature_subset": {"mean_score": 0.7755647003119429, "std_score": 0.0, "impact": -0.0015126883985293203, "worst_score": 0.7738735031004665}}}}, "overall": {}}, "quantile": {"by_level": {}, "overall": {}}, "feature_subset": ["feature_6", "feature_11", "feature_17"], "metric": "AUC", "avg_raw_impact": 0.004001871012082701, "avg_quantile_impact": 0, "avg_overall_impact": 0.004001871012082701, "n_iterations": 3, "metrics": {"accuracy": 0.739, "roc_auc": 0.7874212779746349, "f1": 0.7388510959863877, "precision": 0.7392365860430896, "recall": 0.739}, "model_name": "primary_model", "timestamp": "2025-05-08 23:35:28", "robustness_score": 0.9959981289879173, "raw_impact": 0.004001871012082701, "quantile_impact": 0, "perturbation_chart_data": {"modelName": "primary_model", "levels": [0.1, 0.2], "scores": [0.7741269863844957, 0.7684615386894603], "worstScores": [0.7726299387017863, 0.7654456653913984], "baseScore": 0.7743932845744681, "metric": "AUC", "alternativeModels": {"GLM_CLASSIFIER": {"baseScore": 0.7229918079417453, "scores": [0.7224478040732735, 0.7199528233682254], "worstScores": [0.7214544636761862, 0.718850889606326]}, "GAM_CLASSIFIER": {"baseScore": 0.47251002673796794, "scores": [0.49001326231653203, 0.5053925568655896], "worstScores": [0.4883903618870179, 0.49829287674934575]}, "GBM": {"baseScore": 0.8713973077141883, "scores": [0.8094466449539196, 0.7817098551219327], "worstScores": [0.8071404063317785, 0.7788619830185459]}}}, "feature_subset_display": "feature_6, feature_11, feature_17", "iterations_by_level": {}, "alternative_models_iterations": {"GLM_CLASSIFIER": {}, "GAM_CLASSIFIER": {}, "GBM": {}}};
        
        // Configuração básica do relatório
        window.reportConfig = {
            reportType: 'robustness',
            modelName: 'primary_model',
            // Incluir dados de importância de características diretamente para acesso mais fácil
            feature_importance: {"feature_0": 5.576687342499577e-05, "feature_1": -0.0006520802335130412, "feature_10": -8.838523335283163e-05, "feature_11": -0.0002894520737290179, "feature_12": -1.1095981676321451e-05, "feature_13": 0.0013286481507255473, "feature_14": -3.520104531799845e-05, "feature_15": -0.0012846468440780015, "feature_16": -1.836576277452685e-05, "feature_17": -0.00012750813426329742, "feature_18": 0.0001219601434251845, "feature_19": 0.00010799451131535968, "feature_2": -0.000145969552052319, "feature_3": -5.165370780358676e-05, "feature_4": 2.104410317832399e-06, "feature_5": -5.595818345393742e-05, "feature_6": 0.00014319555663335807, "feature_7": -6.236706942221606e-05, "feature_8": -7.786318176319173e-05, "feature_9": 0.0002685992805787275},
            model_feature_importance: {"feature_0": 0.04441968784910863, "feature_1": 0.041051945787947214, "feature_10": 0.03794462126493219, "feature_11": 0.1193658895869036, "feature_12": 0.02534450889628226, "feature_13": 0.09108320192389514, "feature_14": 0.0033145121242270405, "feature_15": 0.052665998640822775, "feature_16": 0.09355164224442686, "feature_17": 0.14771392008763776, "feature_18": 0.04304063919840231, "feature_19": 0.09544116669023245, "feature_2": 0.006536648686879563, "feature_3": 0.004557487553156789, "feature_4": 0.004525462110153291, "feature_5": 0.003418093109979521, "feature_6": 0.1703488869133524, "feature_7": 0.005880585740812931, "feature_8": 0.0055375016013733125, "feature_9": 0.004257599989473853},
            feature_subset: ["feature_6", "feature_11", "feature_17"]
        };
        
        // Extrair dados do gráfico, se disponíveis
        if (window.reportData && window.reportData.chart_data_json) {
            try {
                // Limpar dados JSON antes de analisar
                const jsonStr = window.reportData.chart_data_json;
                let cleanJson = jsonStr;
                
                // Corrigir vírgulas finais
                cleanJson = cleanJson.replace(/,(\s*})/g, '$1');
                cleanJson = cleanJson.replace(/,(\s*\])/g, '$1');
                
                // Tratar outros problemas de sintaxe
                cleanJson = cleanJson.replace(/\bNaN\b/g, 'null');
                cleanJson = cleanJson.replace(/\bInfinity\b/g, 'null');
                cleanJson = cleanJson.replace(/\b-Infinity\b/g, 'null');
                cleanJson = cleanJson.replace(/\bundefined\b/g, 'null');
                
                // Analisar os dados JSON limpos
                window.chartData = JSON.parse(cleanJson);
                console.log("Dados de gráfico carregados com sucesso");
            } catch (e) {
                console.error("Erro ao analisar dados do gráfico:", e);
                window.chartData = {
                    perturbation_levels: [],
                    feature_importance: {},
                    model_feature_importance: {},
                    boxplot_data: { models: [] }
                };
            }
        }
    </script>
    
    <!-- Scripts combinados para funcionalidade completa -->
    <script>
        // Todos os scripts são combinados e injetados diretamente no HTML
        // para garantir que o relatório seja totalmente autônomo
        
        // Código para inicialização segura - garantir que seja executado apenas quando o DOM estiver pronto
        window.DeepBridgeInit = function() {
            console.log("DeepBridge report initialization - autonomous mode");
            
            // Tentar carregar Plotly se ainda não estiver carregado
            window.loadPlotly().catch(e => console.warn("Chart functionality may be limited", e));
        };
        
        // Código de todos os scripts combinados
        // ----- Critical JS Files ----- //

// ----- global_error_handler.js ----- //
/**
 * Global JavaScript error handler
 * Intercepts and handles JavaScript syntax errors, particularly "Illegal continue" errors
 * Version 1.0 - May 7, 2024
 */

// Execute immediately to capture errors as early as possible
(function() {
    // Store original error handler
    const originalOnError = window.onerror;
    
    // Install global error handler
    window.onerror = function(message, source, lineno, colno, error) {
        // Check for illegal continue errors
        if (message && (
            message.includes("Illegal continue") || 
            message.includes("no surrounding iteration statement") ||
            message.includes("Unexpected token 'continue'")
        )) {
            console.error("Caught illegal continue statement:", {
                message,
                source,
                lineno,
                colno
            });
            
            // Log to console for debugging
            console.warn("%cIllegal continue statement detected and intercepted", 
                         "background: #f8d7da; color: #721c24; padding: 5px; border-radius: 3px;");
            console.info(`Source: ${source}, Line: ${lineno}, Column: ${colno}`);
            
            // Attempt to add visual indicator in the UI
            setTimeout(function() {
                const errorBanner = document.createElement('div');
                errorBanner.style.cssText = "position: fixed; bottom: 10px; right: 10px; background-color: #f8d7da; color: #721c24; padding: 15px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 9999; max-width: 400px; font-size: 14px;";
                errorBanner.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 5px;">JavaScript Syntax Error Intercepted</div>
                    <div>A syntax error was caught by the error handler. The error was in a callback function using 'continue' outside of a loop.</div>
                    <div style="margin-top: 8px; font-size: 12px;">File: ${source.split('/').pop()}, Line: ${lineno}</div>
                    <button style="margin-top: 10px; background: #842029; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Dismiss</button>
                `;
                
                document.body.appendChild(errorBanner);
                
                // Add dismiss functionality
                const dismissButton = errorBanner.querySelector('button');
                if (dismissButton) {
                    dismissButton.addEventListener('click', function() {
                        errorBanner.remove();
                    });
                }
                
                // Auto-dismiss after 10 seconds
                setTimeout(function() {
                    if (document.body.contains(errorBanner)) {
                        errorBanner.remove();
                    }
                }, 10000);
            }, 1000);
            
            // Return true to indicate we've handled the error
            return true;
        }
        
        // For other errors, call the original handler if it exists
        if (typeof originalOnError === 'function') {
            return originalOnError(message, source, lineno, colno, error);
        }
        
        // Return false to let the error propagate
        return false;
    };
    
    // Also intercept unhandled promise rejections
    window.addEventListener('unhandledrejection', function(event) {
        const error = event.reason;
        
        // Check for illegal continue errors
        if (error && error.toString && (
            error.toString().includes("Illegal continue") || 
            error.toString().includes("no surrounding iteration statement") ||
            error.toString().includes("Unexpected token 'continue'")
        )) {
            console.error("Caught illegal continue statement in promise:", error);
            
            // Prevent the error from propagating
            event.preventDefault();
        }
    });
    
    console.log("Global JavaScript error handler installed to catch illegal continue statements");
})();

// Also run when document is ready to ensure proper initialization
document.addEventListener('DOMContentLoaded', function() {
    console.log("Global error handler initialized and ready");
});

// ----- syntax_fixer.js ----- //
// JavaScript Syntax Fixer
// This script applies runtime fixes for common JavaScript syntax errors
// Include this script in the <head> of your HTML document before any other scripts

(function() {
    // Define our safe return object - this will be available for any other script
    window.__safeFallbackObject = {
        levels: [],
        modelScores: {},
        modelNames: {},
        metricName: ""
    };
    
    // Fix trailing commas in JavaScript object literals at runtime
    function fixTrailingCommas() {
        console.log("Running syntax fixer to fix trailing commas");
        
        // Find all script tags
        const scripts = document.querySelectorAll('script:not([src])');
        
        // Process each inline script
        for (const script of scripts) {
            if (!script.textContent) {
                // Usando if/else ao invés de continue
                continue;
            }
            
            let content = script.textContent;
            let needsReplacement = false;
            
            // Fix 1: Trailing commas in object literals - matches a return statement with an object that ends with a comma
            if (content.includes('return {') && 
                (content.includes('metricName,') || 
                 content.includes('robustnessScores,') || 
                 content.includes('baseScores,'))) {
                
                // First fix: return { ...  } pattern
                const fixedContent1 = content.replace(/return\s*\{\s*[\s\S]*?,(\s*\})/g, 'return $1');
                
                // Second fix: specific variable pattern for model data extraction
                const fixedContent2 = fixedContent1.replace(
                    /(return\s*\{\s*)(levels,\s*modelScores,\s*modelNames,\s*metricName),(\s*\})/g, 
                    '$1$2$3'
                );
                
                // Third fix: specific variable pattern for model comparison data
                const fixedContent3 = fixedContent2.replace(
                    /(return\s*\{\s*)(models,\s*baseScores,\s*robustnessScores),(\s*\})/g, 
                    '$1$2$3'
                );
                
                // Check if any fixes were applied
                if (content !== fixedContent3) {
                    content = fixedContent3;
                    needsReplacement = true;
                    console.log("Fixed trailing commas in return statements");
                }
            }
            
            // Fix 2: Any comma before closing brace
            if (content.includes('},') || content.includes(' }')) {
                const fixedContent = content.replace(/,(\s*\})/g, '$1');
                
                if (content !== fixedContent) {
                    content = fixedContent;
                    needsReplacement = true;
                    console.log("Fixed generic trailing commas");
                }
            }
            
            // Fix 3: Replace illegal continue statements with return null or early returns
            // Este é um ponto comum de erro em callbacks de map() ou em funções de callback internas
            if (content.includes('continue')) {
                
                // Primeiro, verificar por 'continue' dentro de funções map(), forEach(), e filter()
                if (content.includes('map(') || content.includes('forEach(') || content.includes('filter(')) {
                    // Procurar por padrões de 'continue' fora de loops que precisam ser substituídos em callbacks
                    const fixedContent = content.replace(
                        /if\s*\([^)]*\)\s*\{\s*[^{}]*continue;\s*\}/g, 
                        function(match) {
                            // Substituir 'continue' por 'return null' dentro do callback de map
                            return match.replace(/continue;/, 'return null;');
                        }
                    );
                    
                    if (content !== fixedContent) {
                        content = fixedContent;
                        needsReplacement = true;
                        console.log("Fixed illegal continue statements in callbacks");
                    }
                }
                
                // Segundo, verificar por qualquer 'continue' em funções de callback inline
                const fixedContent2 = content.replace(
                    /function\s*\([^)]*\)\s*\{(?:[^{}]|{[^{}]*})*continue;(?:[^{}]|{[^{}]*})*\}/g,
                    function(match) {
                        // Substituir 'continue' por 'return null' dentro de funções
                        return match.replace(/continue;/, 'return null;');
                    }
                );
                
                if (content !== fixedContent2) {
                    content = fixedContent2;
                    needsReplacement = true;
                    console.log("Fixed illegal continue statements in inline functions");
                }
                
                // Terceiro, verificar por qualquer 'continue' imediatamente após if, sem estar em um loop
                const fixedContent3 = content.replace(
                    /if\s*\([^)]*\)\s*continue;(?!\s*\})/g,
                    function(match) {
                        // Substituir 'continue' por 'return null' ou 'return'
                        if (content.includes('map(') || content.includes('filter(')) {
                            return match.replace(/continue;/, 'return null;');
                        } else if (content.includes('forEach(')) {
                            return match.replace(/continue;/, 'return;');
                        } else {
                            return match.replace(/continue;/, '{ /* skip */ }');
                        }
                    }
                );
                
                if (content !== fixedContent3) {
                    content = fixedContent3;
                    needsReplacement = true;
                    console.log("Fixed standalone illegal continue statements");
                }
            }
            
            // Replace the script if needed
            if (needsReplacement) {
                try {
                    const newScript = document.createElement('script');
                    newScript.textContent = content;
                    script.parentNode.replaceChild(newScript, script);
                    console.log("Replaced script with fixed version");
                } catch (error) {
                    console.error("Error replacing script:", error);
                }
            }
        }
    }
    
    // Add error handling for specific JavaScript errors
    function addErrorHandling() {
        window.addEventListener('error', function(event) {
            // Verificar especificamente por erro de continue ilegal
            if (event.error && 
                (event.error.toString().includes("Unexpected token") || 
                 event.error.toString().includes("Illegal continue") ||
                 event.error.toString().includes("no surrounding iteration statement"))) {
                
                console.warn("Caught syntax error:", event.error);
                
                // Try to monkeypatch global objects after error
                if (typeof window.ChartManager !== 'undefined') {
                    console.log("Adding safe fallbacks for ChartManager");
                    
                    // Add safe version of extractModelLevelDetailsData
                    if (typeof window.ChartManager.extractModelLevelDetailsData === 'function') {
                        window.ChartManager.extractModelLevelDetailsData = function() {
                            console.log("Using safe replacement for extractModelLevelDetailsData");
                            return {
                                levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                                modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                                modelNames: { 'primary': 'Primary Model' },
                                metricName: 'Score'
                            };
                        };
                    }
                    
                    // Add safe version of extractModelComparisonData
                    if (typeof window.ChartManager.extractModelComparisonData === 'function') {
                        window.ChartManager.extractModelComparisonData = function() {
                            console.log("Using safe replacement for extractModelComparisonData");
                            return {
                                models: ['Primary Model', 'Alternative Model 1'],
                                baseScores: [0.8, 0.75],
                                robustnessScores: [0.7, 0.65]
                            };
                        };
                    }
                    
                    // Add safe version of extractPerturbationChartData
                    if (typeof window.ChartManager.extractPerturbationChartData === 'function') {
                        window.ChartManager.extractPerturbationChartData = function() {
                            console.log("Using safe replacement for extractPerturbationChartData");
                            return {
                                levels: [0, 0.1, 0.2, 0.3, 0.4, 0.5],
                                perturbedScores: [0.9, 0.85, 0.8, 0.75, 0.7, 0.65],
                                worstScores: [0.85, 0.8, 0.75, 0.7, 0.65, 0.6],
                                featureSubsetScores: [0.9, 0.87, 0.84, 0.81, 0.78, 0.75],
                                featureSubsetWorstScores: [0.85, 0.82, 0.79, 0.76, 0.73, 0.7],
                                baseScore: 0.9,
                                metricName: 'Score'
                            };
                        };
                    }
                }
                
                // Verificar ModelComparisonManager
                if (typeof window.ModelComparisonManager !== 'undefined') {
                    if (typeof window.ModelComparisonManager.generatePerturbationScores === 'function') {
                        window.ModelComparisonManager.generatePerturbationScores = function(levels) {
                            console.log("Using safe replacement for generatePerturbationScores");
                            const scores = {};
                            Object.keys(this.state.modelData || {}).forEach(key => {
                                scores[key] = levels.map(l => 0.9 - (l * 0.2));
                            });
                            return scores;
                        };
                    }
                }
                
                // Prevent the error from propagating
                event.preventDefault();
            }
        }, true);
    }
    
    // Run the fixes when the DOM is ready
    function runFixes() {
        console.log("Running JavaScript syntax fixes");
        
        // Fix scripts in the current DOM
        fixTrailingCommas();
        
        // Add error handling
        addErrorHandling();
        
        // Carregar script adicional de correção
        try {
            // Carrega o script fixed_syntax.js com correções específicas
            // Marcar como de alta prioridade para carregar antes de outros scripts
            const fixedSyntaxScript = document.createElement('script');
            fixedSyntaxScript.src = 'js/fixed_syntax.js';
            fixedSyntaxScript.async = false;
            fixedSyntaxScript.defer = false;
            
            // Usar atributo de prioridade para navegadores modernos
            fixedSyntaxScript.setAttribute('fetchpriority', 'high');
            
            // Adicionar ao início do head para ser um dos primeiros a ser carregado
            document.head.insertBefore(fixedSyntaxScript, document.head.firstChild);
            console.log("Loaded additional syntax fixes from fixed_syntax.js with high priority");
            
            // Carregar também os scripts corretivos para arquivos específicos
            const safePatchesScript = document.createElement('script');
            safePatchesScript.src = 'js/safe_chart_manager.js';
            safePatchesScript.async = false;
            document.head.insertBefore(safePatchesScript, document.head.firstChild.nextSibling);
            console.log("Loaded safe_chart_manager.js with high priority");
            
            const modelFixScript = document.createElement('script');
            modelFixScript.src = 'js/model_chart_fix.js';
            modelFixScript.async = false;
            document.head.insertBefore(modelFixScript, document.head.firstChild.nextSibling.nextSibling);
            console.log("Loaded model_chart_fix.js with high priority");
        } catch (error) {
            console.error("Error loading syntax fix scripts:", error);
        }
        
        // Setup MutationObserver to fix dynamically added scripts
        const observer = new MutationObserver(function(mutations) {
            // Check if any scripts were added
            let scriptAdded = false;
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.tagName === 'SCRIPT') {
                            scriptAdded = true;
                        } else if (node.querySelectorAll) {
                            const scripts = node.querySelectorAll('script');
                            if (scripts.length > 0) {
                                scriptAdded = true;
                            }
                        }
                    });
                }
            });
            
            // If scripts were added, run the fixer again
            if (scriptAdded) {
                console.log("New scripts detected, running fixes");
                fixTrailingCommas();
            }
        });
        
        // Start observing the document
        observer.observe(document, {
            childList: true,
            subtree: true
        });
    }
    
    // Run fixes when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', runFixes);
    } else {
        runFixes();
    }
})();

// ----- fixed_syntax.js ----- //
/**
 * Fixed syntax corrections for specific files
 * This script manually fixes known issues in the report JavaScript
 * Version 2.0 - May 7, 2024
 */

// Wait for document to be ready
document.addEventListener('DOMContentLoaded', function() {
    console.log("Fixing specific syntax issues in the report code...");
    
    // Apply all fixes
    fixIllegalContinueStatements();
    fixFeatureImportanceHandlers();
    fixModelComparisonManager();
    fixFeatureMapFunctions();
    
    console.log("All specific fixes applied");
});

/**
 * Fix illegal continue statements in the overview.js file
 */
function fixIllegalContinueStatements() {
    console.log("Fixing illegal continue statements...");
    
    // Fix ChartManager if it exists
    if (window.ChartManager) {
        // Find and fix the model comparison chart function
        if (typeof ChartManager.initializeModelComparisonChart === 'function') {
            console.log("Patching ChartManager.initializeModelComparisonChart");
            
            const originalFunc = ChartManager.initializeModelComparisonChart;
            
            ChartManager.initializeModelComparisonChart = function(containerId) {
                try {
                    // Call the original function
                    return originalFunc.call(ChartManager, containerId);
                } catch (error) {
                    console.error("Error in initializeModelComparisonChart:", error);
                    
                    // Show error message in the container
                    const container = document.getElementById(containerId);
                    if (container) {
                        container.innerHTML = `
                            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                                <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Erro ao inicializar gráfico</h3>
                                <p style="color: #333; font-size: 16px; line-height: 1.4;">
                                    Não foi possível inicializar o gráfico de comparação de modelos. Erro: ${error.message}
                                </p>
                            </div>`;
                    }
                }
            };
        }
        
        // Fix extractModelLevelDetailsData if it exists
        if (typeof ChartManager.extractModelLevelDetailsData === 'function') {
            console.log("Patching ChartManager.extractModelLevelDetailsData");
            
            const originalFunc = ChartManager.extractModelLevelDetailsData;
            
            ChartManager.extractModelLevelDetailsData = function() {
                try {
                    // Call the original function
                    return originalFunc.call(ChartManager);
                } catch (error) {
                    console.error("Error in extractModelLevelDetailsData:", error);
                    
                    // Return safe fallback data
                    return {
                        levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                        modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                        modelNames: { 'primary': 'Primary Model' },
                        metricName: 'Score'
                    };
                }
            };
        }
    }
    
    // Add more fixes here as needed for other specific issues
}

/**
 * Fix issues in ModelComparisonManager
 */
function fixModelComparisonManager() {
    if (window.ModelComparisonManager) {
        console.log("Patching ModelComparisonManager...");
        
        // Fix generatePerturbationScores method
        if (typeof ModelComparisonManager.generatePerturbationScores === 'function') {
            console.log("Patching ModelComparisonManager.generatePerturbationScores");
            
            const originalFunc = ModelComparisonManager.generatePerturbationScores;
            
            ModelComparisonManager.generatePerturbationScores = function(levels) {
                try {
                    // Call the original function
                    return originalFunc.call(ModelComparisonManager, levels);
                } catch (error) {
                    console.error("Error in generatePerturbationScores:", error);
                    
                    // Return safe fallback data
                    const scores = {};
                    if (this.state && this.state.modelData) {
                        Object.keys(this.state.modelData).forEach(key => {
                            scores[key] = levels.map(l => 0.8 - (l * 0.2));
                        });
                    }
                    return scores;
                }
            };
        }
    }
}

/**
 * Fix map/forEach/filter functions with illegal continue statements
 */
function fixFeatureMapFunctions() {
    console.log("Patching functions that may contain illegal continue statements...");
    
    // List of objects that might use map/filter/forEach with continue
    const potentialObjects = [
        'FeatureImportanceTableManager',
        'PerturbationResultsController',
        'FeatureImportanceController',
        'ChartManager',
        'ModelComparisonManager'
    ];
    
    for (const objName of potentialObjects) {
        if (window[objName]) {
            console.log(`Checking ${objName} for array methods with continue...`);
            
            // Find all methods that might use array operations
            const methods = Object.keys(window[objName]).filter(key => 
                typeof window[objName][key] === 'function'
            );
            
            for (const methodName of methods) {
                const original = window[objName][methodName];
                
                // Replace the method with a wrapped version
                window[objName][methodName] = function(...args) {
                    try {
                        // Call the original method
                        return original.apply(window[objName], args);
                    } catch (error) {
                        if (error.toString().includes("Illegal continue") || 
                            error.toString().includes("no surrounding iteration statement")) {
                            console.error(`Caught illegal continue in ${objName}.${methodName}:`, error);
                            
                            // For methods that should return arrays/objects
                            if (methodName.startsWith('extract') || 
                                methodName.startsWith('get') || 
                                methodName.includes('Data')) {
                                return {};
                            }
                            
                            // For methods that initialize/render content
                            if (methodName.startsWith('init') || 
                                methodName.startsWith('render')) {
                                // Check if first arg is an element ID
                                if (args.length > 0 && typeof args[0] === 'string') {
                                    const container = document.getElementById(args[0]);
                                    if (container) {
                                        container.innerHTML = `
                                            <div style="padding: 20px; text-align: center; color: #d32f2f; background-color: #fff0f0; border-radius: 4px; margin: 10px;">
                                                <div style="font-weight: bold; margin-bottom: 5px;">Error in ${objName}.${methodName}</div>
                                                <div>A syntax error occurred: ${error.message}</div>
                                            </div>`;
                                    }
                                }
                            }
                            
                            return null;
                        } else {
                            // Rethrow unknown errors
                            throw error;
                        }
                    }
                };
            }
        }
    }
}

/**
 * Fix feature importance handlers
 * No synthetic data, just real data
 */
function fixFeatureImportanceHandlers() {
    console.log("Fixing feature importance handlers...");
    
    // Define a safe version of the feature importance initialization
    window.FeatureImportanceTableController = window.FeatureImportanceTableController || {
        init: function() {
            console.log("Feature importance table will be initialized by FeatureImportanceController");
            
            // Try to find and initialize the FeatureImportanceHandler
            if (window.FeatureImportanceHandler) {
                console.log("Found FeatureImportanceHandler, initializing it");
                if (typeof window.FeatureImportanceHandler.initialize === 'function') {
                    window.FeatureImportanceHandler.initialize();
                }
            }
        }
    };
    
    // Make sure the feature importance chart handler doesn't have syntax errors
    if (window.StandaloneFeatureImportanceChart) {
        const originalExtract = window.StandaloneFeatureImportanceChart.extractChartData;
        
        // Override with a safe version
        window.StandaloneFeatureImportanceChart.extractChartData = function() {
            try {
                // Try to use the original function
                return originalExtract.call(this);
            } catch (error) {
                console.error("Error in extractChartData:", error);
                
                // Return empty/safe data
                return {
                    features: [],
                    robustnessValues: [],
                    modelValues: []
                };
            }
        };
    }
}

// ----- patches.js ----- //
/**
 * Patches for report bug fixes
 * Contains fixes for JavaScript errors in generated reports
 * Updated: May 7, 2024 - Added fix for "Details by Level" chart
 */

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log("Loading JavaScript patches for robustness report");
    
    // Fix variable scope issues with model chart initialization
    window.fixModelChartScope = function() {
        // If we have the ModelComparisonChartManager function that's causing issues
        if (typeof ModelComparisonChartManager !== 'undefined') {
            console.log("Fixing model comparison chart scope");
            
            // Override the problematic function to fix the scope issue
            const originalExtract = ModelComparisonChartManager.extractModelComparisonData;
            ModelComparisonChartManager.extractModelComparisonData = function() {
                try {
                    // Call the original function but wrap in try/catch
                    return originalExtract.call(this);
                } catch (error) {
                    console.error("Error in extractModelComparisonData, using fallback:", error);
                    // Return minimal valid data structure to prevent JS errors
                    return {
                        levels: [],
                        modelScores: {},
                        modelNames: {},
                        metricName: "unknown"
                    };
                }
            };
        }
    };
    
    // Fix feature importance data issues
    window.fixFeatureImportanceData = function() {
        // Add safeguards for feature importance data
        if (window.reportData && window.reportData.feature_importance) {
            console.log("Normalizing feature importance data");
            
            // Ensure all feature keys use consistent format
            const normalizedFeatures = {};
            const normalizedModelFeatures = {};
            
            // Helper function to normalize keys
            function normalizeKey(key) {
                return String(key).trim();
            }
            
            // Normalize feature importance data
            Object.keys(window.reportData.feature_importance).forEach(function(key) {
                const normalizedKey = normalizeKey(key);
                normalizedFeatures[normalizedKey] = window.reportData.feature_importance[key];
            });
            
            // Normalize model feature importance if available
            if (window.reportData.model_feature_importance) {
                Object.keys(window.reportData.model_feature_importance).forEach(function(key) {
                    const normalizedKey = normalizeKey(key);
                    normalizedModelFeatures[normalizedKey] = window.reportData.model_feature_importance[key];
                });
            }
            
            // Replace with normalized data
            window.reportData.feature_importance = normalizedFeatures;
            if (Object.keys(normalizedModelFeatures).length > 0) {
                window.reportData.model_feature_importance = normalizedModelFeatures;
            }
            
            console.log("Feature importance data normalized");
        }
    };
    
    // Fix for "Model Comparison > Details by Level" chart
    window.fixModelLevelDetailsChart = function() {
        console.log("Applying fix for 'Details by Level' chart");
        
        // Ensure ChartManager has the best extract function loaded
        if (window.ChartManager && typeof window.SafeModelComparisonChartManager !== 'undefined' && 
            typeof window.SafeModelComparisonChartManager.extractModelLevelDetailsData === 'function') {
            
            console.log("Replacing ChartManager.extractModelLevelDetailsData with safe version");
            // Use the improved safe version from model_chart_fix.js
            window.ChartManager.extractModelLevelDetailsData = window.SafeModelComparisonChartManager.extractModelLevelDetailsData;
            
            // Add event listener to reinitialize chart when "Details by Level" tab is clicked
            const detailsSelector = document.querySelector('#model_comparison_selector [data-chart-type="details"]');
            if (detailsSelector) {
                console.log("Adding click listener to 'Details by Level' selector");
                detailsSelector.addEventListener('click', function() {
                    // Reinitialize chart with a small delay to ensure DOM updates
                    setTimeout(function() {
                        const chartElement = document.getElementById('model-level-details-chart-plot');
                        if (chartElement && chartElement.innerHTML.includes('No Data Available')) {
                            console.log("'No Data Available' message detected, reinitializing chart");
                            if (typeof ChartManager.initializeModelLevelDetailsChart === 'function') {
                                ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
                            }
                        }
                    }, 300);
                });
            }
            
            // Check if overview tab is active, and if so, initialize model details chart
            setTimeout(function() {
                const overviewTab = document.getElementById('overview');
                if (overviewTab && overviewTab.classList.contains('active')) {
                    const modelDetailChart = document.getElementById('model-level-details-chart-plot');
                    if (modelDetailChart && modelDetailChart.innerHTML.includes('No Data Available')) {
                        console.log("Overview tab active, initializing model details chart");
                        if (typeof ChartManager.initializeModelLevelDetailsChart === 'function') {
                            console.log("Forced initialization of model level details chart");
                            ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
                        }
                    }
                }
            }, 1000); // Longer delay for initial page load
        } else {
            console.warn("Unable to fix model level details chart - required components not available");
        }
    };
    
    // Fix for initializing the details tab
    window.fixDetailsTabInitialization = function() {
        console.log("Setting up details tab initialization");
        
        // Listen for tab changes to initialize details tab content
        document.addEventListener('tabChange', function(e) {
            if (e.detail && e.detail.tabId === 'details') {
                console.log("Details tab activated");
                
                // Initialize the OverviewController if not already initialized
                if (typeof window.OverviewController !== 'undefined' && 
                    typeof window.OverviewController.init === 'function') {
                    console.log("Initializing OverviewController for details tab");
                    window.OverviewController.init();
                }
                
                // Initialize the radar chart
                if (typeof window.OverviewChartsManager !== 'undefined' && 
                    typeof window.OverviewChartsManager.initializeOverviewCharts === 'function') {
                    console.log("Initializing OverviewChartsManager radar chart");
                    window.OverviewChartsManager.initializeOverviewCharts();
                }
            }
        });
        
        // Add click listener to the details tab link
        const detailsTab = document.querySelector('.main-nav a[data-tab="details"]');
        if (detailsTab) {
            detailsTab.addEventListener('click', function() {
                console.log("Details tab clicked");
                // Handle any additional initialization for details tab
            });
        }
    };
    
    // Apply all patches
    try {
        window.fixModelChartScope();
        window.fixFeatureImportanceData();
        window.fixModelLevelDetailsChart();
        window.fixDetailsTabInitialization();
        console.log("All patches applied successfully");
    } catch (error) {
        console.error("Error applying patches:", error);
    }
});

// ----- model_chart_fix.js ----- //
/**
 * Model comparison chart fix
 * Direct replacement of the problematic functions
 * Updated: May 7, 2024 - Added fix for "Details by Level" chart
 */

// Define a safe version of the extractModelComparisonData function
window.SafeModelComparisonChartManager = {
    /**
     * Extract model comparison data from report data
     * Safe version with proper error handling - NO synthetic data generation
     * @returns {Object} Data for model comparison chart
     */
    extractModelComparisonData: function() {
        console.log("Using safe model comparison data extractor v2.0 (No Synthetic Data)");
        
        // Default safe return object with no trailing commas
        const safeReturnObject = {
            levels: [],
            modelScores: {},
            modelNames: {},
            metricName: ""
        };
        
        try {
            // Check if we have valid report data
            if (!window.reportData) {
                console.warn("No reportData available");
                return safeReturnObject;
            }
            
            // Check for alternative models
            const hasAlternativeModels = window.reportData.alternative_models && 
                                        Object.keys(window.reportData.alternative_models).length > 0;
            
            if (!hasAlternativeModels) {
                console.warn("No alternative models found - won't create synthetic models");
                return safeReturnObject;
            }
            
            // Get primary model name
            const primaryModelName = window.reportData.model_name || "Primary Model";
            const metricName = window.reportData.metric || "Score";
            
            // Determine available levels
            const rawData = window.reportData.raw && window.reportData.raw.by_level || {};
            const perturbationData = window.reportData.perturbation_chart_data || {};
            
            // Use perturbation chart data levels if available, otherwise extract from raw data
            let levels = [];
            if (perturbationData && perturbationData.levels) {
                levels = perturbationData.levels;
                console.log("Using levels from perturbation chart data:", levels);
            } else {
                // Extract levels from raw data
                levels = Object.keys(rawData)
                    .map(level => parseFloat(level))
                    .filter(level => !isNaN(level))
                    .sort((a, b) => a - b);
                console.log("Extracted levels from raw data:", levels);
            }
            
            if (levels.length === 0) {
                console.warn("No valid perturbation levels found");
                return safeReturnObject;
            }
            
            // Initialize model scores and names
            const modelScores = {};
            const modelNames = {};
            
            // Add primary model if we have perturbation chart data
            if (perturbationData.scores && perturbationData.scores.length > 0) {
                modelScores["primary"] = perturbationData.scores;
                modelNames["primary"] = primaryModelName;
                console.log("Added primary model scores from perturbation_chart_data");
            } 
            // Otherwise extract from raw data
            else if (Object.keys(rawData).length > 0) {
                const primaryScores = levels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        const score = rawData[levelStr].overall_result.all_features.mean_score;
                        return typeof score === 'number' ? score : null;
                    }
                    return null;
                });
                
                if (primaryScores.some(score => score !== null)) {
                    modelScores["primary"] = primaryScores;
                    modelNames["primary"] = primaryModelName;
                    console.log("Added primary model scores from raw data");
                }
            }
            
            // Process alternative models - ONLY use real data, no synthetic score generation
            const alternativeModels = window.reportData.alternative_models || {};
            
            // Count how many alternative models have real perturbation test data
            let modelsWithRealData = 0;
            
            Object.entries(alternativeModels).forEach(([modelId, modelData]) => {
                // Get model name
                const name = modelData.model_name || modelId;
                
                // Only include models that have actual test data for perturbation levels
                if (modelData.perturbation_results && 
                    Object.keys(modelData.perturbation_results).length > 0) {
                    
                    // Extract actual scores for each perturbation level
                    const scores = levels.map(level => {
                        const levelStr = level.toString();
                        if (modelData.perturbation_results[levelStr] && 
                            modelData.perturbation_results[levelStr].overall_result) {
                            return modelData.perturbation_results[levelStr].overall_result.mean_score || null;
                        }
                        return null;
                    });
                    
                    // Only include models with at least one valid score
                    if (scores.some(score => score !== null)) {
                        modelScores[modelId] = scores;
                        modelNames[modelId] = name;
                        modelsWithRealData++;
                        console.log(`Added real data for alternative model: ${name}`);
                    }
                }
            });
            
            // Log warning if no models have real perturbation test data
            if (modelsWithRealData === 0) {
                console.warn("No alternative models with real perturbation test data found");
                
                // Show error message on the page if the element exists
                const chartContainer = document.getElementById('modelComparisonChartContainer');
                if (chartContainer) {
                    chartContainer.innerHTML = `
                        <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                            <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                            <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados de perturbação não disponíveis</h3>
                            <p style="color: #333; font-size: 16px; line-height: 1.4;">Os modelos alternativos não possuem dados de testes de perturbação.</p>
                            <p style="color: #333; margin-top: 20px; font-size: 14px;">Execute testes de robustez em todos os modelos para comparação.</p>
                        </div>`;
                }
            }
            
            // Log final data
            console.log("Final data for model comparison chart:");
            console.log("- Levels:", levels);
            console.log("- Models:", Object.keys(modelScores));
            
            // Return the processed data with NO TRAILING COMMAS
            
        try {
            return {
                levels: levels,
                modelScores: modelScores,
                modelNames: modelNames,
                metricName: metricName
            };
        } catch (error) {
            console.error('Error in model comparison data extraction:', error);
            return window.__safeFallbackObject;
        }

        } catch (error) {
            console.error("Error extracting model comparison data:", error);
            return safeReturnObject;
        }
    },
    
    /**
     * Fixed version of extractModelLevelDetailsData function
     * Properly extracts data for Model Level Details chart (no synthetic data)
     */
    extractModelLevelDetailsData: function() {
        console.log("Using safe extractModelLevelDetailsData (no synthetic data)");
        
        // Default safe return object
        const safeReturnObject = {
            levels: [],
            modelScores: {},
            modelNames: {},
            metricName: "Score"
        };
        
        try {
            if (!window.reportData) {
                console.warn("No reportData available");
                return safeReturnObject;
            }
            
            // Get the metric name from reportData
            let metricName = "Score";
            if (window.reportData.metric) {
                metricName = window.reportData.metric;
            } else if (window.reportConfig && window.reportConfig.metric) {
                metricName = window.reportConfig.metric;
            }
            
            // Determine which data path to use based on available structure
            let primaryModelData = null;
            let alternativeModelsData = null;
            let rawDataPath = null;
            
            // Check new data structure first (results.robustness.primary_model)
            if (window.reportData.results && 
                window.reportData.results.robustness && 
                window.reportData.results.robustness.primary_model) {
                console.log("Using new data structure (results.robustness.primary_model)");
                primaryModelData = window.reportData.results.robustness.primary_model;
                
                if (window.reportData.results.robustness.alternative_models) {
                    alternativeModelsData = window.reportData.results.robustness.alternative_models;
                }
                
                if (primaryModelData.raw && primaryModelData.raw.by_level) {
                    rawDataPath = primaryModelData.raw.by_level;
                }
            } 
            // Fallback to original structure
            else if (window.reportData.raw && window.reportData.raw.by_level) {
                console.log("Using original data structure (raw.by_level)");
                rawDataPath = window.reportData.raw.by_level;
                
                if (window.reportData.alternative_models) {
                    alternativeModelsData = window.reportData.alternative_models;
                }
            }
            
            if (!rawDataPath) {
                console.warn("No valid raw data path found");
                return safeReturnObject;
            }
            
            // Get perturbation levels from the data
            const levels = Object.keys(rawDataPath)
                .map(level => parseFloat(level))
                .filter(level => !isNaN(level))
                .sort((a, b) => a - b);
                
            if (levels.length === 0) {
                console.warn("No valid levels found");
                return safeReturnObject;
            }
            
            console.log("Found levels:", levels);
            
            // Get primary model name
            const primaryModelName = window.reportData.model_name || "Primary Model";
            
            // Initialize result data structures
            const modelScores = {};
            const modelNames = {};
            
            // Extract primary model scores
            const primaryScores = levels.map(level => {
                const levelStr = level.toString();
                if (rawDataPath[levelStr]) {
                    // Try different potential paths where scores might be stored
                    const paths = [
                        // Try specific path from user data
                        rawDataPath[levelStr].runs?.all_features?.[0]?.perturbed_score,
                        // Standard path for mean scores
                        rawDataPath[levelStr].overall_result?.all_features?.mean_score,
                        // Other potential paths
                        rawDataPath[levelStr].mean_score,
                        rawDataPath[levelStr].perturbed_score,
                        rawDataPath[levelStr].results?.overall_result?.all_features?.mean_score
                    ];
                    
                    // Use the first valid score from any path
                    for (const path of paths) {
                        if (typeof path === 'number') {
                            return path;
                        }
                    }
                }
                return null;
            });
            
            if (primaryScores.some(score => score !== null)) {
                modelScores["primary"] = primaryScores;
                modelNames["primary"] = primaryModelName;
                console.log("Added primary model scores");
            }
            
            // Extract alternative model scores
            if (alternativeModelsData && Object.keys(alternativeModelsData).length > 0) {
                console.log("Processing alternative models:", Object.keys(alternativeModelsData));
                
                Object.entries(alternativeModelsData).forEach(([modelId, modelData]) => {
                    // Skip if no raw data
                    if (!modelData.raw || !modelData.raw.by_level) {
                        console.log(`Model ${modelId} has no raw data`);
                        return;
                    }
                    
                    // Get model name
                    const name = modelData.model_name || modelId;
                    
                    // Extract scores for each level
                    const scores = levels.map(level => {
                        const levelStr = level.toString();
                        if (!modelData.raw.by_level[levelStr]) {
                            return null;
                        }
                        
                        const paths = [
                            // Try specific path from user data
                            modelData.raw.by_level[levelStr].runs?.all_features?.[0]?.perturbed_score,
                            // Standard path for mean scores
                            modelData.raw.by_level[levelStr].overall_result?.all_features?.mean_score,
                            // Other potential paths
                            modelData.raw.by_level[levelStr].mean_score,
                            modelData.raw.by_level[levelStr].perturbed_score,
                            modelData.raw.by_level[levelStr].results?.overall_result?.all_features?.mean_score
                        ];
                        
                        // Use the first valid score
                        for (const path of paths) {
                            if (typeof path === 'number') {
                                return path;
                            }
                        }
                        
                        return null;
                    });
                    
                    // Only add if we found at least one valid score
                    if (scores.some(score => score !== null)) {
                        modelScores[modelId] = scores;
                        modelNames[modelId] = name;
                        console.log(`Added scores for model ${name}`);
                    } else {
                        console.log(`No valid scores found for model ${name}`);
                    }
                });
            }
            
            // Check if we have at least two models with data
            const validModels = Object.keys(modelScores);
            if (validModels.length < 2) {
                console.warn("Not enough models for comparison (need at least 2)");
                console.log("Models with valid data:", validModels);
                return safeReturnObject;
            }
            
            
        try {
            return {
                levels: levels,
                modelScores: modelScores,
                modelNames: modelNames,
                metricName: metricName
            };
        } catch (error) {
            console.error('Error in model level details data extraction:', error);
            return {
                levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                modelNames: { 'primary': 'Primary Model' },
                metricName: 'Score'
            };
        }

        } catch (error) {
            console.error("Error extracting model level details data:", error);
            return safeReturnObject;
        }
    }
};

// Set up the fix to be applied when the page loads
document.addEventListener('DOMContentLoaded', function() {
    // Replace the problematic functions with our safe versions
    if (window.ModelComparisonChartManager) {
        console.log("Replacing ModelComparisonChartManager.extractModelComparisonData with safe version");
        window.ModelComparisonChartManager.extractModelComparisonData = window.SafeModelComparisonChartManager.extractModelComparisonData;
    }
    
    // Fix the "Details by Level" chart
    if (window.ChartManager) {
        console.log("Replacing ChartManager.extractModelLevelDetailsData with safe version");
        window.ChartManager.extractModelLevelDetailsData = window.SafeModelComparisonChartManager.extractModelLevelDetailsData;
    }
    
    // Monitor model comparison selector clicks
    const modelDetailButton = document.querySelector('#model_comparison_selector [data-chart-type="details"]');
    if (modelDetailButton) {
        modelDetailButton.addEventListener('click', function() {
            console.log("Details chart button clicked, applying fix");
            // Check if we need to reinitialize the chart
            const chartElement = document.getElementById('model-level-details-chart-plot');
            if (chartElement && chartElement.innerHTML.includes('No Data Available')) {
                // Reinitialize the chart with our fixed function
                if (typeof ChartManager !== 'undefined' && 
                    typeof ChartManager.initializeModelLevelDetailsChart === 'function') {
                    setTimeout(function() {
                        console.log("Reinitializing model level details chart");
                        ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
                    }, 300);
                }
            }
        });
    }
});

// ----- direct_perturbation_handler.js ----- //
/**
 * Direct Perturbation Handler
 * 
 * A simplified implementation to directly extract and display real perturbation data
 * without any synthetic values or complex dependencies
 */
(function() {
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Check if the perturbation results container exists
        const container = document.getElementById('perturbation-results-container');
        if (container) {
            initializePerturbationResults();
        }
    });

    /**
     * Initialize perturbation results display
     */
    function initializePerturbationResults() {
        console.log("Initializing direct perturbation results display");
        
        try {
            // Extract data from report
            const data = extractPerturbationData();
            if (!data || !data.results || data.results.length === 0) {
                showError("No perturbation data available in the report");
                return;
            }
            
            // Render the perturbation analysis UI
            renderPerturbationAnalysis(data);
        } catch (error) {
            console.error("Error initializing perturbation results:", error);
            showError("Error processing perturbation data: " + error.message);
        }
    }
    
    /**
     * Extract perturbation data from the report data
     * Only extracts real data, no synthetic values
     */
    function extractPerturbationData() {
        if (!window.reportData || !window.reportData.raw || !window.reportData.raw.by_level) {
            console.error("No raw perturbation data available");
            return null;
        }
        
        const raw = window.reportData.raw;
        const byLevel = raw.by_level;
        
        // Basic result structure
        const result = {
            modelName: window.reportData.model_name || 'Model',
            modelType: window.reportData.model_type || 'Unknown',
            metric: window.reportData.metric || 'Score',
            baseScore: window.reportData.base_score || 0,
            results: []
        };
        
        // Get perturbation levels and sort them
        const levels = Object.keys(byLevel)
            .map(level => parseFloat(level))
            .filter(level => !isNaN(level))
            .sort((a, b) => a - b);
        
        console.log(`Found ${levels.length} perturbation levels: ${levels.join(', ')}`);
        
        // Process each level
        levels.forEach(level => {
            const levelData = byLevel[level.toString()];
            
            // Skip if no overall results
            if (!levelData || !levelData.overall_result) {
                console.log(`No overall result for level ${level}`);
                return;
            }
            
            const levelResult = {
                level: level,
                allFeatures: extractFeatureData(levelData, 'all_features', result.baseScore),
                featureSubset: extractFeatureData(levelData, 'feature_subset', result.baseScore)
            };
            
            // Add iteration scores from runs data if available
            if (levelData.runs) {
                if (levelData.runs.all_features && levelData.runs.all_features.length > 0) {
                    levelResult.allFeatures.iterations = extractIterationScores(levelData.runs.all_features);
                }
                
                if (levelData.runs.feature_subset && levelData.runs.feature_subset.length > 0) {
                    levelResult.featureSubset.iterations = extractIterationScores(levelData.runs.feature_subset);
                }
            }
            
            result.results.push(levelResult);
        });
        
        return result;
    }
    
    /**
     * Extract feature data from level results
     */
    function extractFeatureData(levelData, featureType, baseScore) {
        if (!levelData.overall_result || !levelData.overall_result[featureType]) {
            return null;
        }
        
        const featureResult = levelData.overall_result[featureType];
        
        return {
            baseScore: baseScore,
            meanScore: featureResult.mean_score || 0,
            worstScore: featureResult.worst_score || 0,
            impact: baseScore > 0 ? (baseScore - featureResult.mean_score) / baseScore : 0,
            iterations: [] // Will be populated if iteration data is available
        };
    }
    
    /**
     * Extract iteration scores from runs data
     */
    function extractIterationScores(runsData) {
        const iterationScores = [];
        
        runsData.forEach(run => {
            if (run.iterations && run.iterations.scores && Array.isArray(run.iterations.scores)) {
                // Add all scores from this run to the result
                iterationScores.push(...run.iterations.scores);
            }
        });
        
        return iterationScores;
    }
    
    /**
     * Render the perturbation analysis UI with the extracted data
     */
    function renderPerturbationAnalysis(data) {
        const container = document.getElementById('perturbation-results-container');
        if (!container) return;
        
        // Clear the container
        container.innerHTML = '';
        
        // Create main container
        const mainDiv = document.createElement('div');
        mainDiv.className = 'bg-white rounded-lg shadow-md overflow-hidden';
        
        // Add header
        mainDiv.appendChild(createHeader(data));
        
        // Create tabs container
        const tabsContainer = document.createElement('div');
        tabsContainer.className = 'p-4';
        
        // Add tabs navigation
        const tabsNav = document.createElement('div');
        tabsNav.className = 'tabs-nav flex border-b mb-4';
        
        const summaryTab = document.createElement('button');
        summaryTab.className = 'tab-button active px-4 py-2 mr-2 font-medium';
        summaryTab.textContent = 'Summary';
        summaryTab.dataset.tab = 'summary';
        
        const iterationsTab = document.createElement('button');
        iterationsTab.className = 'tab-button px-4 py-2 mr-2 font-medium';
        iterationsTab.textContent = 'Iterations';
        iterationsTab.dataset.tab = 'iterations';
        
        tabsNav.appendChild(summaryTab);
        tabsNav.appendChild(iterationsTab);
        tabsContainer.appendChild(tabsNav);
        
        // Add tab content containers
        const summaryContent = document.createElement('div');
        summaryContent.className = 'tab-content active';
        summaryContent.id = 'summary-tab';
        
        const iterationsContent = document.createElement('div');
        iterationsContent.className = 'tab-content hidden';
        iterationsContent.id = 'iterations-tab';
        
        // Populate summary tab with level selection and feature cards
        const summaryDiv = createSummaryContent(data);
        summaryContent.appendChild(summaryDiv);
        
        // Populate iterations tab with detailed data
        const iterationsDiv = createIterationsContent(data);
        iterationsContent.appendChild(iterationsDiv);
        
        // Add tab content to tabs container
        tabsContainer.appendChild(summaryContent);
        tabsContainer.appendChild(iterationsContent);
        
        // Add tabs container to main div
        mainDiv.appendChild(tabsContainer);
        
        // Add footer
        mainDiv.appendChild(createFooter(data));
        
        // Add the main div to the container
        container.appendChild(mainDiv);
        
        // Add event listeners for tab switching
        setupTabEventListeners();
        
        console.log("Perturbation analysis UI rendered with real data");
    }
    
    /**
     * Create header section with level selector
     */
    function createHeader(data) {
        const header = document.createElement('div');
        header.className = 'p-4 border-b border-gray-200';
        
        // Title
        const title = document.createElement('h3');
        title.className = 'text-xl font-medium mb-4';
        title.textContent = 'Perturbation Test Results';
        header.appendChild(title);
        
        // Level selector
        const levelSelector = document.createElement('div');
        levelSelector.className = 'mt-2';
        
        const levelLabel = document.createElement('label');
        levelLabel.className = 'block text-sm font-medium mb-2';
        levelLabel.textContent = 'Perturbation Level:';
        levelSelector.appendChild(levelLabel);
        
        const levelButtonGroup = document.createElement('div');
        levelButtonGroup.className = 'flex flex-wrap gap-2';
        
        // Add buttons for each perturbation level
        data.results.forEach((result, index) => {
            const button = document.createElement('button');
            button.className = 'level-btn px-3 py-1 rounded text-sm ' + 
                (index === 0 ? 'bg-blue-600 text-white' : 'bg-gray-200 hover:bg-gray-300 text-gray-700');
            button.textContent = `${result.level * 100}%`;
            button.dataset.level = result.level;
            levelButtonGroup.appendChild(button);
        });
        
        levelSelector.appendChild(levelButtonGroup);
        header.appendChild(levelSelector);
        
        return header;
    }
    
    /**
     * Create summary tab content
     */
    function createSummaryContent(data) {
        const summaryDiv = document.createElement('div');
        
        // Default to first level results
        const selectedLevel = data.results[0].level; 
        const selectedData = data.results[0];
        
        // Feature summaries grid
        const summaryGrid = document.createElement('div');
        summaryGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';
        
        // All Features Summary
        if (selectedData.allFeatures) {
            summaryGrid.appendChild(createFeatureSummary(
                selectedData.allFeatures, 
                'allFeatures', 
                'All Features'
            ));
        }
        
        // Feature Subset Summary
        if (selectedData.featureSubset) {
            summaryGrid.appendChild(createFeatureSummary(
                selectedData.featureSubset, 
                'featureSubset', 
                'Feature Subset'
            ));
        }
        
        summaryDiv.appendChild(summaryGrid);
        
        // Analysis box
        if (selectedData.allFeatures) {
            const analysisBox = document.createElement('div');
            analysisBox.className = 'mt-4 p-4 bg-blue-50 rounded-lg';
            
            const analysisTitle = document.createElement('h3');
            analysisTitle.className = 'font-medium text-blue-800 mb-2';
            analysisTitle.textContent = 'Analysis';
            analysisBox.appendChild(analysisTitle);
            
            const analysisParagraph = document.createElement('p');
            analysisParagraph.className = 'text-sm text-blue-700';
            
            // Generate analysis text
            let analysisText = `At ${selectedLevel * 100}% perturbation, the model shows `;
            if (selectedData.allFeatures.impact < 0) {
                analysisText += 'improvement ';
            } else {
                analysisText += `degradation of ${formatNumber(selectedData.allFeatures.impact * 100, 2)}% `;
            }
            analysisText += 'when all features are perturbed. ';
            
            if (selectedData.featureSubset && selectedData.featureSubset.impact < selectedData.allFeatures.impact) {
                analysisText += `The feature subset shows better robustness with only ${formatNumber(selectedData.featureSubset.impact * 100, 2)}% impact.`;
            }
            
            analysisParagraph.textContent = analysisText;
            analysisBox.appendChild(analysisParagraph);
            
            summaryDiv.appendChild(analysisBox);
        }
        
        return summaryDiv;
    }
    
    /**
     * Create feature summary panel
     */
    function createFeatureSummary(featureData, sectionId, title) {
        const summaryPanel = document.createElement('div');
        summaryPanel.className = 'border rounded-lg overflow-hidden shadow-sm';
        
        // Header
        const panelHeader = document.createElement('div');
        panelHeader.className = 'bg-gray-50 p-3 flex justify-between items-center';
        
        const panelTitle = document.createElement('h4');
        panelTitle.className = 'font-medium';
        panelTitle.textContent = title;
        panelHeader.appendChild(panelTitle);
        
        // Impact indicator
        const impactSpan = document.createElement('span');
        impactSpan.className = `text-sm font-semibold ${getImpactColorClass(featureData.impact)}`;
        impactSpan.textContent = `Impact: ${formatNumber(featureData.impact * 100)}%`;
        panelHeader.appendChild(impactSpan);
        
        summaryPanel.appendChild(panelHeader);
        
        // Content
        const panelContent = document.createElement('div');
        panelContent.className = 'p-4';
        
        // Stats table
        const statsTable = document.createElement('table');
        statsTable.className = 'min-w-full divide-y divide-gray-200';
        
        const tbody = document.createElement('tbody');
        tbody.className = 'divide-y divide-gray-200';
        
        // Add rows to the table
        const rows = [
            { label: 'Base Score', value: formatNumber(featureData.baseScore) },
            { 
                label: 'Mean Score',
                value: formatNumber(featureData.meanScore),
                diff: featureData.meanScore - featureData.baseScore
            },
            { 
                label: 'Worst Score',
                value: formatNumber(featureData.worstScore),
                diff: featureData.worstScore - featureData.baseScore
            }
        ];
        
        // Create rows
        rows.forEach(rowData => {
            const row = document.createElement('tr');
            
            const labelCell = document.createElement('td');
            labelCell.className = 'px-3 py-2 text-sm font-medium text-gray-900';
            labelCell.textContent = rowData.label;
            row.appendChild(labelCell);
            
            const valueCell = document.createElement('td');
            valueCell.className = 'px-3 py-2 text-sm text-gray-700';
            
            if (rowData.diff !== undefined) {
                const valueText = document.createTextNode(rowData.value);
                valueCell.appendChild(valueText);
                
                const diffSpan = document.createElement('span');
                diffSpan.className = `ml-2 ${rowData.diff >= 0 ? 'text-green-600' : 'text-red-600'}`;
                diffSpan.textContent = `(${rowData.diff >= 0 ? '+' : ''}${formatNumber(rowData.diff * 100, 2)}%)`;
                valueCell.appendChild(diffSpan);
            } else {
                valueCell.textContent = rowData.value;
            }
            
            row.appendChild(valueCell);
            tbody.appendChild(row);
        });
        
        statsTable.appendChild(tbody);
        panelContent.appendChild(statsTable);
        
        // Impact bar
        const barContainer = document.createElement('div');
        barContainer.className = 'mt-3';
        
        const barLabels = document.createElement('div');
        barLabels.className = 'flex justify-between text-xs text-gray-500 mb-1';
        
        const startLabel = document.createElement('span');
        startLabel.textContent = '0% (Base)';
        barLabels.appendChild(startLabel);
        
        const middleLabel = document.createElement('span');
        middleLabel.textContent = 'Impact';
        barLabels.appendChild(middleLabel);
        
        const endLabel = document.createElement('span');
        endLabel.textContent = '25%';
        barLabels.appendChild(endLabel);
        
        barContainer.appendChild(barLabels);
        
        const barBg = document.createElement('div');
        barBg.className = 'w-full bg-gray-200 rounded-full h-2.5';
        
        const barFill = document.createElement('div');
        barFill.className = `h-2.5 rounded-full ${featureData.impact < 0 ? 'bg-green-500' : 'bg-red-500'}`;
        barFill.style.width = `${Math.min(Math.abs(featureData.impact) * 100 * 4, 100)}%`;
        
        barBg.appendChild(barFill);
        barContainer.appendChild(barBg);
        
        panelContent.appendChild(barContainer);
        summaryPanel.appendChild(panelContent);
        
        return summaryPanel;
    }
    
    /**
     * Create iterations tab content with table of iteration data
     */
    function createIterationsContent(data) {
        const iterationsDiv = document.createElement('div');
        
        // Default to first level results
        const selectedData = data.results[0];
        
        // Simple message if no iterations
        if (!selectedData.allFeatures || !selectedData.allFeatures.iterations || 
            selectedData.allFeatures.iterations.length === 0) {
            const noDataMessage = document.createElement('p');
            noDataMessage.className = 'text-center text-gray-500 my-8';
            noDataMessage.textContent = 'No iteration data available for this perturbation level.';
            iterationsDiv.appendChild(noDataMessage);
            return iterationsDiv;
        }
        
        // Table container
        const tableContainer = document.createElement('div');
        tableContainer.className = 'overflow-x-auto';
        
        const table = document.createElement('table');
        table.className = 'min-w-full divide-y divide-gray-200';
        
        // Table header
        const thead = document.createElement('thead');
        thead.className = 'bg-gray-50';
        
        const headerRow = document.createElement('tr');
        
        const headers = [
            { text: 'Iteration', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
            { text: 'All Features', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
            { text: 'Feature Subset', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
            { text: 'Difference', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' }
        ];
        
        headers.forEach(header => {
            const th = document.createElement('th');
            th.className = header.className;
            th.textContent = header.text;
            headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Table body
        const tbody = document.createElement('tbody');
        tbody.className = 'bg-white divide-y divide-gray-200';
        
        // Base score row
        const baseRow = document.createElement('tr');
        baseRow.className = 'bg-gray-100';
        
        const baseIterationCell = document.createElement('td');
        baseIterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
        baseIterationCell.textContent = 'Base';
        baseRow.appendChild(baseIterationCell);
        
        const baseAllFeaturesCell = document.createElement('td');
        baseAllFeaturesCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        baseAllFeaturesCell.textContent = formatNumber(selectedData.allFeatures.baseScore);
        baseRow.appendChild(baseAllFeaturesCell);
        
        const baseFeatureSubsetCell = document.createElement('td');
        baseFeatureSubsetCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        baseFeatureSubsetCell.textContent = selectedData.featureSubset ? 
            formatNumber(selectedData.featureSubset.baseScore) : 'N/A';
        baseRow.appendChild(baseFeatureSubsetCell);
        
        const baseDifferenceCell = document.createElement('td');
        baseDifferenceCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        baseDifferenceCell.textContent = '0.0000';
        baseRow.appendChild(baseDifferenceCell);
        
        tbody.appendChild(baseRow);
        
        // Get iteration data
        const allFeaturesIterations = selectedData.allFeatures.iterations || [];
        const featureSubsetIterations = selectedData.featureSubset ? 
            (selectedData.featureSubset.iterations || []) : [];
        
        const maxIterations = Math.max(allFeaturesIterations.length, featureSubsetIterations.length);
        
        // Create a row for each iteration
        for (let i = 0; i < maxIterations; i++) {
            const iterationRow = document.createElement('tr');
            
            // Iteration number
            const iterationCell = document.createElement('td');
            iterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-900';
            iterationCell.textContent = `#${i + 1}`;
            iterationRow.appendChild(iterationCell);
            
            // All features score
            const allFeaturesScore = allFeaturesIterations[i];
            const allFeaturesCell = document.createElement('td');
            allFeaturesCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-700';
            
            if (allFeaturesScore !== undefined) {
                const scoreText = document.createTextNode(formatNumber(allFeaturesScore));
                allFeaturesCell.appendChild(scoreText);
                
                // Add difference if base score provided
                const diff = allFeaturesScore - selectedData.allFeatures.baseScore;
                const diffSpan = document.createElement('span');
                diffSpan.className = `ml-2 text-xs ${diff >= 0 ? 'text-green-600' : 'text-red-600'}`;
                diffSpan.textContent = `(${diff >= 0 ? '+' : ''}${formatNumber(diff * 100, 2)}%)`;
                allFeaturesCell.appendChild(diffSpan);
            } else {
                allFeaturesCell.textContent = 'N/A';
            }
            
            iterationRow.appendChild(allFeaturesCell);
            
            // Feature subset score
            const featureSubsetScore = featureSubsetIterations[i];
            const featureSubsetCell = document.createElement('td');
            featureSubsetCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-700';
            
            if (featureSubsetScore !== undefined && selectedData.featureSubset) {
                const scoreText = document.createTextNode(formatNumber(featureSubsetScore));
                featureSubsetCell.appendChild(scoreText);
                
                // Add difference if base score provided
                const diff = featureSubsetScore - selectedData.featureSubset.baseScore;
                const diffSpan = document.createElement('span');
                diffSpan.className = `ml-2 text-xs ${diff >= 0 ? 'text-green-600' : 'text-red-600'}`;
                diffSpan.textContent = `(${diff >= 0 ? '+' : ''}${formatNumber(diff * 100, 2)}%)`;
                featureSubsetCell.appendChild(diffSpan);
            } else {
                featureSubsetCell.textContent = 'N/A';
            }
            
            iterationRow.appendChild(featureSubsetCell);
            
            // Difference between scores
            const differenceCell = document.createElement('td');
            differenceCell.className = 'px-6 py-3 whitespace-nowrap text-sm';
            
            if (allFeaturesScore !== undefined && featureSubsetScore !== undefined) {
                const scoreDiff = featureSubsetScore - allFeaturesScore;
                differenceCell.className += ` ${scoreDiff > 0 ? 'text-green-600' : 'text-red-600'}`;
                differenceCell.textContent = `${scoreDiff > 0 ? '+' : ''}${formatNumber(scoreDiff)}`;
            } else {
                differenceCell.className += ' text-gray-500';
                differenceCell.textContent = 'N/A';
            }
            
            iterationRow.appendChild(differenceCell);
            tbody.appendChild(iterationRow);
        }
        
        // Mean row
        if (selectedData.allFeatures.meanScore !== undefined) {
            const meanRow = document.createElement('tr');
            meanRow.className = 'bg-gray-100';
            
            const meanLabelCell = document.createElement('td');
            meanLabelCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
            meanLabelCell.textContent = 'Mean';
            meanRow.appendChild(meanLabelCell);
            
            const allFeaturesMeanCell = document.createElement('td');
            allFeaturesMeanCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
            allFeaturesMeanCell.textContent = formatNumber(selectedData.allFeatures.meanScore);
            meanRow.appendChild(allFeaturesMeanCell);
            
            const featureSubsetMeanCell = document.createElement('td');
            featureSubsetMeanCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
            featureSubsetMeanCell.textContent = selectedData.featureSubset ? 
                formatNumber(selectedData.featureSubset.meanScore) : 'N/A';
            meanRow.appendChild(featureSubsetMeanCell);
            
            const meanDiffCell = document.createElement('td');
            
            if (selectedData.featureSubset && selectedData.featureSubset.meanScore !== undefined) {
                const meanDiff = selectedData.featureSubset.meanScore - selectedData.allFeatures.meanScore;
                meanDiffCell.className = `px-6 py-3 whitespace-nowrap text-sm font-medium ${
                    meanDiff > 0 ? 'text-green-600' : 'text-red-600'
                }`;
                meanDiffCell.textContent = `${meanDiff > 0 ? '+' : ''}${formatNumber(meanDiff)}`;
            } else {
                meanDiffCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-500';
                meanDiffCell.textContent = 'N/A';
            }
            
            meanRow.appendChild(meanDiffCell);
            tbody.appendChild(meanRow);
        }
        
        table.appendChild(tbody);
        tableContainer.appendChild(table);
        iterationsDiv.appendChild(tableContainer);
        
        return iterationsDiv;
    }
    
    /**
     * Create footer section
     */
    function createFooter(data) {
        const footer = document.createElement('div');
        footer.className = 'p-3 border-t border-gray-200 text-xs text-gray-500';
        
        const footerFlex = document.createElement('div');
        footerFlex.className = 'flex justify-between';
        
        // Left section
        const leftSpan = document.createElement('span');
        leftSpan.textContent = `Perturbation Test • ${data.modelType || 'Model'} • ${data.metric || 'Score'} Metric`;
        footerFlex.appendChild(leftSpan);
        
        // Right section
        const rightSpan = document.createElement('span');
        rightSpan.textContent = `Base Score: ${formatNumber(data.baseScore)} • Date: ${new Date().toLocaleDateString()}`;
        footerFlex.appendChild(rightSpan);
        
        footer.appendChild(footerFlex);
        
        return footer;
    }
    
    /**
     * Setup event listeners for tab switching and level selection
     */
    function setupTabEventListeners() {
        // Tab switching
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', function() {
                // Remove active class from all buttons
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                    btn.classList.add('text-gray-500');
                    btn.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                });
                
                // Add active class to clicked button
                this.classList.add('active', 'text-blue-600', 'border-b-2', 'border-blue-500');
                this.classList.remove('text-gray-500');
                
                // Hide all tab contents
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.add('hidden');
                    content.classList.remove('active');
                });
                
                // Show selected tab content
                const tabId = this.dataset.tab;
                const tabContent = document.getElementById(tabId + '-tab');
                if (tabContent) {
                    tabContent.classList.remove('hidden');
                    tabContent.classList.add('active');
                }
            });
        });
        
        // Level selection
        document.querySelectorAll('.level-btn').forEach(button => {
            button.addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.level-btn').forEach(btn => {
                    btn.classList.remove('bg-blue-600', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-700');
                });
                
                this.classList.remove('bg-gray-200', 'text-gray-700');
                this.classList.add('bg-blue-600', 'text-white');
                
                // Get selected level
                const selectedLevel = parseFloat(this.dataset.level);
                
                // Re-render the perturbation analysis with the selected level
                updatePerturbationAnalysisForLevel(selectedLevel);
            });
        });
    }
    
    /**
     * Update the perturbation analysis UI for a specific level
     */
    function updatePerturbationAnalysisForLevel(selectedLevel) {
        // Re-extract data
        const data = extractPerturbationData();
        if (!data || !data.results || data.results.length === 0) {
            showError("No perturbation data available");
            return;
        }
        
        // Find the data for the selected level
        const selectedData = data.results.find(result => result.level === selectedLevel);
        if (!selectedData) {
            console.error(`No data found for level ${selectedLevel}`);
            return;
        }
        
        // Update summary tab
        const summaryTab = document.getElementById('summary-tab');
        if (summaryTab) {
            summaryTab.innerHTML = '';
            summaryTab.appendChild(createSummaryContent({
                ...data,
                results: [selectedData] // Just include the selected level
            }));
        }
        
        // Update iterations tab
        const iterationsTab = document.getElementById('iterations-tab');
        if (iterationsTab) {
            iterationsTab.innerHTML = '';
            iterationsTab.appendChild(createIterationsContent({
                ...data,
                results: [selectedData] // Just include the selected level
            }));
        }
    }
    
    /**
     * Show error message in the container
     */
    function showError(message) {
        const container = document.getElementById('perturbation-results-container');
        if (!container) return;
        
        container.innerHTML = `
            <div class="p-6 text-center bg-red-50 rounded-lg border border-red-200">
                <div class="text-4xl mb-3 text-red-500">❌</div>
                <h3 class="text-lg font-medium text-red-800 mb-2">Error Loading Perturbation Results</h3>
                <p class="text-red-600">${message || 'An unknown error occurred'}</p>
            </div>
        `;
    }
    
    /**
     * Format a number for display
     */
    function formatNumber(value, decimals = 4) {
        if (value === undefined || value === null || isNaN(value)) {
            return 'N/A';
        }
        return value.toFixed(decimals);
    }
    
    /**
     * Get color class for impact value
     */
    function getImpactColorClass(impact) {
        if (impact < 0) return 'text-green-600';
        if (impact < 0.05) return 'text-yellow-600';
        if (impact < 0.1) return 'text-orange-600';
        return 'text-red-600';
    }
})();

// ----- utils.js ----- //
// Utility functions for robustness report
/**
 * Format a numeric value for display
 * 
 * @param {number} value - The value to format
 * @param {number} decimals - Number of decimal places (default: 3)
 * @param {boolean} percentage - Whether to format as percentage
 * @returns {string} Formatted value
 */
function formatValue(value, decimals = 3, percentage = false) {
    if (value === null || value === undefined || isNaN(value)) {
        return "N/A";
    }
    
    if (percentage) {
        return (value * 100).toFixed(decimals) + "%";
    }
    
    return value.toFixed(decimals);
}

/**
 * Get color based on value (red-to-green gradient)
 * 
 * @param {number} value - Value between 0 and 1
 * @param {boolean} invertScale - If true, 0 is green and 1 is red (default: false)
 * @returns {string} RGB color string
 */
function getScoreColor(value, invertScale = false) {
    if (value === null || value === undefined || isNaN(value)) {
        return "rgb(150, 150, 150)";
    }
    
    // Ensure value is between 0 and 1
    value = Math.max(0, Math.min(1, value));
    
    // Invert scale if needed
    if (invertScale) {
        value = 1 - value;
    }
    
    // Red to green gradient
    const red = Math.round(255 * (1 - value));
    const green = Math.round(255 * value);
    
    return `rgb(${red}, ${green}, 50)`;
}

/**
 * Toggle element visibility
 * 
 * @param {string} elementId - The ID of the element to toggle
 */
function toggleElement(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
        if (element.classList.contains('hidden')) {
            element.classList.remove('hidden');
        } else {
            element.classList.add('hidden');
        }
    }
}

/**
 * Show message in an element
 * 
 * @param {HTMLElement} element - Element to show message in
 * @param {string} message - Message text
 * @param {string} type - Message type (info, warning, error)
 */
function showMessage(element, message, type = 'info') {
    if (!element) return;
    
    let iconClass = 'info-icon';
    let bgColor = '#e3f2fd';
    let textColor = '#0d47a1';
    
    if (type === 'warning') {
        iconClass = 'warning-icon';
        bgColor = '#fff3e0';
        textColor = '#e65100';
    } else if (type === 'error') {
        iconClass = 'error-icon';
        bgColor = '#ffebee';
        textColor = '#c62828';
    }
    
    element.innerHTML = `
        <div class="message ${type}" style="padding: 15px; background: ${bgColor}; color: ${textColor}; border-radius: 4px; margin: 10px 0;">
            <span class="${iconClass}"></span>
            ${message}
        </div>
    `;
}

/**
 * Show loader in an element
 * 
 * @param {HTMLElement} element - Element to show loader in
 * @param {string} message - Loading message
 */
function showLoader(element, message = 'Loading...') {
    if (!element) return;
    
    element.innerHTML = `
        <div class="loader-container" style="text-align: center; padding: 20px;">
            <div class="loader" style="display: inline-block; width: 40px; height: 40px; border: 3px solid #f3f3f3; border-radius: 50%; border-top: 3px solid #3498db; animation: spin 1s linear infinite;"></div>
            <p style="margin-top: 10px;">${message}</p>
        </div>
        <style>
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    `;
}

// ----- feature_importance_chart.js ----- //
/**
 * Standalone feature importance chart handler
 * This is a self-contained version that doesn't depend on other code
 */

// Define a standalone handler that works regardless of other code
window.StandaloneFeatureImportanceChart = {
    /**
     * Initialize the feature importance chart
     * @param {string} containerId - ID of container element for the chart
     */
    initialize: function(containerId) {
        console.log("Initializing standalone feature importance chart:", containerId);
        
        const container = document.getElementById(containerId);
        if (!container) {
            console.error("Chart container not found:", containerId);
            return;
        }
        
        // Extract data separately from other code
        const chartData = this.extractChartData();
        if (!chartData || !chartData.features || chartData.features.length === 0) {
            this.showNoDataMessage(container, "No feature importance data available");
            return;
        }
        
        // Create and render chart
        this.renderChart(container, chartData);
    },
    
    /**
     * Extract data for the feature importance chart
     * @returns {Object} Chart data object
     */
    extractChartData: function() {
        try {
            // Try to get feature importance data from various sources
            let featureImportance = {};
            let modelFeatureImportance = {};
            
            // Function to check if we have enough usable feature data
            const hasEnoughFeatureData = (data) => {
                return data && typeof data === 'object' && 
                       Object.keys(data).length > 0 && 
                       Object.keys(data).length < 1000; // Sanity check to avoid giant objects
            };
            
            // Check multiple sources in order of preference
            if (window.reportConfig && hasEnoughFeatureData(window.reportConfig.feature_importance)) {
                featureImportance = window.reportConfig.feature_importance || {};
                modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                console.log("Using feature importance from reportConfig");
            } 
            else if (window.chartData && hasEnoughFeatureData(window.chartData.feature_importance)) {
                featureImportance = window.chartData.feature_importance || {};
                modelFeatureImportance = window.chartData.model_feature_importance || {};
                console.log("Using feature importance from chartData");
            }
            else if (window.reportData) {
                if (hasEnoughFeatureData(window.reportData.feature_importance)) {
                    featureImportance = window.reportData.feature_importance;
                    modelFeatureImportance = window.reportData.model_feature_importance || {};
                    console.log("Using feature importance from reportData");
                }
                else if (window.reportData.chart_data_json && typeof window.reportData.chart_data_json === 'string') {
                    // Try to parse the chart_data_json string
                    try {
                        const chartData = JSON.parse(window.reportData.chart_data_json);
                        if (chartData && hasEnoughFeatureData(chartData.feature_importance)) {
                            featureImportance = chartData.feature_importance;
                            modelFeatureImportance = chartData.model_feature_importance || {};
                            console.log("Using feature importance from parsed chart_data_json");
                        }
                    } catch (e) {
                        console.error("Error parsing chart_data_json:", e);
                    }
                }
                // Try to use perturbation_details_data as a source for feature importance
                else if (window.reportData.perturbation_details_data &&
                       window.reportData.perturbation_details_data.results &&
                       window.reportData.perturbation_details_data.results.length > 0) {
                    try {
                        // Get perturbation data
                        const perturbData = window.reportData.perturbation_details_data;
                        
                        // Extract feature impacts from all perturbation levels
                        const extractedFeatures = {};
                        let foundFeatures = false;
                        
                        // Check if there's a raw.features field with real perturbation impacts by feature
                        if (window.reportData.raw && window.reportData.raw.features) {
                            const rawFeatures = window.reportData.raw.features;
                            console.log("Found raw.features data with feature impacts");
                            
                            // Extract feature impacts directly from raw data
                            for (const featureName in rawFeatures) {
                                const featureImpact = rawFeatures[featureName];
                                if (typeof featureImpact === 'number') {
                                    extractedFeatures[featureName] = featureImpact;
                                    foundFeatures = true;
                                }
                            }
                        }
                        
                        // If we found feature impacts, use them
                        if (foundFeatures) {
                            console.log(`Extracted ${Object.keys(extractedFeatures).length} features from raw data`);
                            featureImportance = extractedFeatures;
                        }
                        
                        // If no feature impacts found, try to get feature_importance directly from raw data
                        else if (window.reportData.raw && window.reportData.raw.feature_importance) {
                            console.log("Using feature_importance from raw data");
                            featureImportance = window.reportData.raw.feature_importance;
                        }
                        
                        // Check if no features were found, but we have overall impact scores
                        else if (perturbData.results && perturbData.results.length > 0) {
                            console.log("Using perturbation_details_data for impact scores");
                            const levelImpacts = {};
                            
                            // Extract impacts by level
                            for (const result of perturbData.results) {
                                if (result.allFeatures && typeof result.allFeatures.impact === 'number') {
                                    levelImpacts[`Level_${result.level}`] = result.allFeatures.impact;
                                }
                            }
                            
                            // Use level impacts if we found any
                            if (Object.keys(levelImpacts).length > 0) {
                                console.log(`Using ${Object.keys(levelImpacts).length} level impacts`);
                                featureImportance = levelImpacts;
                            }
                        }
                    } catch (e) {
                        console.error("Error extracting from perturbation details:", e);
                    }
                }
            }
            
            // Try FeatureImportanceTableManager as a last resort
            if (Object.keys(featureImportance).length === 0 && 
                typeof FeatureImportanceTableManager !== 'undefined' && 
                typeof FeatureImportanceTableManager.extractFeatureData === 'function') {
                try {
                    const featureData = FeatureImportanceTableManager.extractFeatureData();
                    if (featureData && featureData.length > 0) {
                        // Convert the array format back to object format
                        featureImportance = {};
                        modelFeatureImportance = {};
                        
                        featureData.forEach(item => {
                            featureImportance[item.name] = item.robustness;
                            modelFeatureImportance[item.name] = item.importance;
                        });
                        
                        console.log("Using feature data from FeatureImportanceTableManager");
                    }
                } catch (e) {
                    console.error("Error using FeatureImportanceTableManager:", e);
                }
            }
            
            if (Object.keys(featureImportance).length === 0) {
                console.warn("No feature importance data found in any source");
                return null;
            }
            
            // Convert to arrays for plotting
            const featureArray = Object.keys(featureImportance).map(feature => {
                return {
                    name: feature,
                    importance: featureImportance[feature],
                    modelImportance: modelFeatureImportance[feature] || 0
                };
            });
            
            // Sort by absolute importance
            featureArray.sort((a, b) => Math.abs(b.importance) - Math.abs(a.importance));
            
            // Get top 15 features
            const topFeatures = featureArray.slice(0, 15);
            
            return {
                features: topFeatures.map(f => f.name),
                robustnessValues: topFeatures.map(f => f.importance),
                modelValues: topFeatures.map(f => f.modelImportance)
            };
        } catch (error) {
            console.error("Error extracting feature importance chart data:", error);
            return null;
        }
    },
    
    /**
     * Render the feature importance chart
     * @param {HTMLElement} container - Chart container element
     * @param {Object} chartData - Chart data object
     */
    renderChart: function(container, chartData) {
        try {
            // Verify Plotly is available
            if (typeof Plotly === 'undefined') {
                this.showErrorMessage(container, "Plotly library not available");
                return;
            }
            
            // Clear container
            container.innerHTML = '';
            
            // Create traces for the chart
            const traces = [
                {
                    x: chartData.robustnessValues,
                    y: chartData.features,
                    name: 'Robustness Impact',
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: '#8884d8'
                    }
                }
            ];
            
            // Add model importance if available
            if (chartData.modelValues && chartData.modelValues.length > 0) {
                traces.push({
                    x: chartData.modelValues,
                    y: chartData.features,
                    name: 'Model Importance',
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: '#82ca9d'
                    }
                });
            }
            
            // Chart layout
            const layout = {
                title: 'Feature Importance Comparison',
                xaxis: {
                    title: 'Importance Score'
                },
                yaxis: {
                    title: 'Feature',
                    automargin: true
                },
                barmode: 'group',
                margin: {
                    l: 150,
                    r: 20,
                    t: 40,
                    b: 40
                }
            };
            
            // Create the plot
            Plotly.newPlot(container, traces, layout, {
                responsive: true,
                displayModeBar: false
            });
            
            console.log("Feature importance chart rendered successfully");
        } catch (error) {
            console.error("Error rendering feature importance chart:", error);
            this.showErrorMessage(container, error.message);
        }
    },
    
    /**
     * Show no data message in chart container
     * @param {HTMLElement} container - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(container, message) {
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;">📊</div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">No Data Available</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">
                    ${message}
                </p>
            </div>`;
    },
    
    /**
     * Show error message in chart container
     * @param {HTMLElement} container - Chart container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(container, errorMessage) {
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                <div style="margin-top: 20px; padding: 15px; background-color: #f8f8f8; border-radius: 5px; text-align: left;">
                    <p style="font-weight: bold; margin-bottom: 10px;">Troubleshooting:</p>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-bottom: 0;">
                        <li>Check if the Plotly library is loaded correctly</li>
                        <li>Verify that feature importance data is available in the report</li>
                        <li>Try reloading the page</li>
                    </ul>
                </div>
            </div>`;
    }
};

// Initialize charts when document is ready
document.addEventListener('DOMContentLoaded', function() {
    // NOTA: Não inicializamos mais o gráfico de comparação aqui, apenas o de feature_impact
    // para evitar a sobreposição com ImportanceComparisonHandler.js
    
    // Initialize feature importance chart if the container exists
    const featureContainer = document.getElementById('feature-importance-chart');
    if (featureContainer) {
        console.log("Found feature importance chart container - initializing");
        setTimeout(function() {
            window.StandaloneFeatureImportanceChart.initialize('feature-importance-chart');
        }, 500);
    }
    
    // Listen for tab changes to initialize charts when tabs become visible
    document.querySelectorAll('.tab-btn').forEach(button => {
        button.addEventListener('click', function() {
            const tabId = this.getAttribute('data-tab');
            if (tabId === 'feature_impact') {
                console.log("Feature impact tab activated - initializing chart");
                setTimeout(function() {
                    if (document.getElementById('feature-importance-chart')) {
                        window.StandaloneFeatureImportanceChart.initialize('feature-importance-chart');
                    }
                }, 100);
            }
            // Removido o inicializador para importance_comparison para evitar conflito
        });
    });
});

// ----- feature_importance_handler.js ----- //
// Feature Importance Handler
// This is a standalone script that handles the feature importance visualization

(function() {
    // Create the handler
    window.FeatureImportanceHandler = {
        /**
         * Initialize the feature importance visualization
         */
        initialize: function() {
            console.log("Initializing feature importance handler");
            
            try {
                // Initialize the feature importance chart
                this.initializeFeatureImportanceChart();
                
                // Initialize the feature importance table
                this.initializeFeatureImportanceTable();
                
                // Initialize event listeners
                this.initializeEventListeners();
                
                console.log("Feature importance handler initialized");
            } catch (error) {
                console.error("Error initializing feature importance handler:", error);
            }
        },
        
        /**
         * Initialize the feature importance chart using Plotly
         */
        initializeFeatureImportanceChart: function() {
            try {
                const chartContainer = document.getElementById('feature-importance-chart');
                if (!chartContainer) return;
                
                // Get feature importance data - no synthetic data will be generated
                const chartData = this.extractFeatureImportanceData();
                if (!chartData || !chartData.features || chartData.features.length === 0) {
                    this.showNoDataMessage(chartContainer, "Dados de importância de características não disponíveis. Execute testes com cálculo de importância de características habilitado.");
                    return;
                }
                
                // Create chart
                this.renderFeatureImportanceChart(chartContainer, chartData);
            } catch (error) {
                console.error("Error initializing feature importance chart:", error);
                const container = document.getElementById('feature-importance-chart');
                if (container) {
                    this.showErrorMessage(container, "Error initializing chart: " + error.message);
                }
            }
        },
        
        /**
         * Extract feature importance data from report data
         * @returns {Object} Feature importance data
         */
        extractFeatureImportanceData: function() {
            try {
                // Try to get data from various sources
                let featureImportance = {};
                let modelFeatureImportance = {};
                
                if (window.reportConfig && window.reportConfig.feature_importance) {
                    featureImportance = window.reportConfig.feature_importance || {};
                    modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                } 
                else if (window.reportData) {
                    if (window.reportData.feature_importance) {
                        featureImportance = window.reportData.feature_importance;
                        modelFeatureImportance = window.reportData.model_feature_importance || {};
                    }
                }
                
                // No synthetic data generation - return null if no data available
                if (Object.keys(featureImportance).length === 0) {
                    console.warn("No feature importance data available - returning null");
                    return null;
                }
                
                // Convert to arrays for plotting
                const featureArray = [];
                for (const feature in featureImportance) {
                    featureArray.push({
                        name: feature,
                        importance: featureImportance[feature],
                        modelImportance: modelFeatureImportance[feature] || 0
                    });
                }
                
                // Sort by absolute importance value
                featureArray.sort((a, b) => Math.abs(b.importance) - Math.abs(a.importance));
                
                // Get top features
                const topFeatures = featureArray.slice(0, 15);
                
                return {
                    features: topFeatures.map(f => f.name),
                    robustnessValues: topFeatures.map(f => f.importance),
                    modelValues: topFeatures.map(f => f.modelImportance)
                };
            } catch (error) {
                console.error("Error extracting feature importance data:", error);
                return null;
            }
        },
        
        /**
         * Render feature importance chart using Plotly
         * @param {HTMLElement} container - Chart container element
         * @param {Object} chartData - Chart data object
         */
        renderFeatureImportanceChart: function(container, chartData) {
            try {
                // Verify Plotly is available
                if (typeof Plotly === 'undefined') {
                    this.showErrorMessage(container, "Plotly library not available");
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                // Create traces for chart
                const traces = [
                    {
                        x: chartData.robustnessValues,
                        y: chartData.features,
                        name: 'Robustness Impact',
                        type: 'bar',
                        orientation: 'h',
                        marker: {
                            color: '#8884d8'
                        }
                    }
                ];
                
                // Add model importance if available
                if (chartData.modelValues && chartData.modelValues.some(v => v !== 0)) {
                    traces.push({
                        x: chartData.modelValues,
                        y: chartData.features,
                        name: 'Model Importance',
                        type: 'bar',
                        orientation: 'h',
                        marker: {
                            color: '#82ca9d'
                        }
                    });
                }
                
                // Layout
                const layout = {
                    title: 'Feature Importance',
                    xaxis: {
                        title: 'Importance Score'
                    },
                    yaxis: {
                        title: 'Feature',
                        automargin: true
                    },
                    barmode: 'group',
                    margin: {
                        l: 150,
                        r: 20,
                        t: 40,
                        b: 40
                    }
                };
                
                // Create plot
                Plotly.newPlot(container, traces, layout, {
                    responsive: true,
                    displayModeBar: false
                });
                
                console.log("Feature importance chart rendered successfully");
            } catch (error) {
                console.error("Error rendering feature importance chart:", error);
                this.showErrorMessage(container, "Error rendering chart: " + error.message);
            }
        },
        
        /**
         * Initialize the feature importance table
         */
        initializeFeatureImportanceTable: function() {
            try {
                // Get the table body
                const tableBody = document.getElementById('feature-impact-data');
                if (!tableBody) return;
                
                // Get the feature subset if available
                let featureSubset = [];
                if (window.reportConfig && window.reportConfig.feature_subset) {
                    featureSubset = window.reportConfig.feature_subset;
                } else if (window.reportData && window.reportData.feature_subset) {
                    featureSubset = window.reportData.feature_subset;
                }
                
                // Get feature importance data
                let featureImportance = {};
                let modelFeatureImportance = {};
                
                if (window.reportConfig && window.reportConfig.feature_importance) {
                    featureImportance = window.reportConfig.feature_importance || {};
                    modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                } 
                else if (window.reportData) {
                    if (window.reportData.feature_importance) {
                        featureImportance = window.reportData.feature_importance;
                        modelFeatureImportance = window.reportData.model_feature_importance || {};
                    }
                }
                
                // If we have real data, use it to populate the table
                if (Object.keys(featureImportance).length > 0) {
                    // Convert feature data to array for sorting
                    const featureArray = [];
                    for (const feature in featureImportance) {
                        featureArray.push({
                            name: feature,
                            impact: featureImportance[feature],
                            importance: modelFeatureImportance[feature] || 0,
                            inSubset: featureSubset.includes(feature)
                        });
                    }
                    
                    // Sort by absolute importance value (default sort)
                    featureArray.sort((a, b) => Math.abs(b.impact) - Math.abs(a.impact));
                    
                    // Clear existing rows (keep them if there's no real data)
                    tableBody.innerHTML = '';
                    
                    // Add rows for each feature
                    featureArray.forEach(feature => {
                        const row = document.createElement('tr');
                        row.className = feature.inSubset ? 'feature-subset-row' : '';
                        
                        // Feature name
                        const nameCell = document.createElement('td');
                        nameCell.textContent = feature.name;
                        row.appendChild(nameCell);
                        
                        // Robustness impact
                        const impactCell = document.createElement('td');
                        impactCell.textContent = feature.impact.toFixed(4);
                        row.appendChild(impactCell);
                        
                        // Model importance
                        const importanceCell = document.createElement('td');
                        importanceCell.textContent = feature.importance.toFixed(4);
                        row.appendChild(importanceCell);
                        
                        // Feature subset status
                        const subsetCell = document.createElement('td');
                        const subsetBadge = document.createElement('span');
                        subsetBadge.className = `subset-badge ${feature.inSubset ? 'included' : 'excluded'}`;
                        subsetBadge.textContent = feature.inSubset ? 'Included' : 'Excluded';
                        subsetCell.appendChild(subsetBadge);
                        row.appendChild(subsetCell);
                        
                        tableBody.appendChild(row);
                    });
                    
                    // Update feature counts
                    const totalFeaturesCount = document.getElementById('total-features-count');
                    if (totalFeaturesCount) {
                        totalFeaturesCount.textContent = featureArray.length;
                    }
                    
                    const subsetFeaturesCount = document.getElementById('subset-features-count');
                    if (subsetFeaturesCount) {
                        subsetFeaturesCount.textContent = featureArray.filter(f => f.inSubset).length;
                    }
                }
                
                console.log("Feature importance table initialized");
            } catch (error) {
                console.error("Error initializing feature importance table:", error);
            }
        },
        
        /**
         * Initialize event listeners for the feature importance UI
         */
        initializeEventListeners: function() {
            try {
                // Search input
                const searchInput = document.getElementById('feature-search');
                if (searchInput) {
                    searchInput.addEventListener('input', () => {
                        this.filterFeatures(searchInput.value);
                    });
                }
                
                // Show subset only toggle
                const subsetToggle = document.getElementById('show-subset-only');
                if (subsetToggle) {
                    subsetToggle.addEventListener('change', () => {
                        this.toggleSubsetOnly(subsetToggle.checked);
                    });
                }
                
                // Sortable column headers
                const sortableHeaders = document.querySelectorAll('.feature-importance-table th.sortable');
                sortableHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        this.sortFeatureTable(header.dataset.sort);
                    });
                });
                
                console.log("Feature importance event listeners initialized");
            } catch (error) {
                console.error("Error initializing feature importance event listeners:", error);
            }
        },
        
        /**
         * Filter features based on search text
         * @param {string} searchText - Search text
         */
        filterFeatures: function(searchText) {
            try {
                const rows = document.querySelectorAll('#feature-impact-data tr');
                const searchLower = searchText.toLowerCase();
                
                rows.forEach(row => {
                    const featureName = row.querySelector('td').textContent.toLowerCase();
                    
                    if (featureName.includes(searchLower)) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });
            } catch (error) {
                console.error("Error filtering features:", error);
            }
        },
        
        /**
         * Toggle showing only subset features
         * @param {boolean} showSubsetOnly - Whether to show only subset features
         */
        toggleSubsetOnly: function(showSubsetOnly) {
            try {
                const rows = document.querySelectorAll('#feature-impact-data tr');
                
                rows.forEach(row => {
                    if (showSubsetOnly && !row.classList.contains('feature-subset-row')) {
                        row.style.display = 'none';
                    } else {
                        row.style.display = '';
                    }
                });
            } catch (error) {
                console.error("Error toggling subset only:", error);
            }
        },
        
        /**
         * Sort feature table by column
         * @param {string} sortBy - Column to sort by
         */
        sortFeatureTable: function(sortBy) {
            try {
                const table = document.querySelector('.feature-importance-table');
                const tableBody = document.getElementById('feature-impact-data');
                if (!table || !tableBody) return;
                
                // Update sort indicators
                const headers = table.querySelectorAll('th.sortable');
                headers.forEach(header => {
                    const indicator = header.querySelector('.sort-indicator');
                    if (header.dataset.sort === sortBy) {
                        if (indicator.textContent === '▼') {
                            indicator.textContent = '▲';
                        } else {
                            indicator.textContent = '▼';
                        }
                    } else {
                        indicator.textContent = '';
                    }
                });
                
                // Get current sort direction
                const sortHeader = table.querySelector(`th[data-sort="${sortBy}"]`);
                const sortDirection = sortHeader.querySelector('.sort-indicator').textContent === '▼' ? 'desc' : 'asc';
                
                // Get all rows as array for sorting
                const rows = Array.from(tableBody.querySelectorAll('tr'));
                
                // Sort rows based on column and direction
                rows.sort((rowA, rowB) => {
                    const cellA = rowA.querySelector(`td:nth-child(${getColumnIndex(sortBy)})`);
                    const cellB = rowB.querySelector(`td:nth-child(${getColumnIndex(sortBy)})`);
                    
                    let valueA, valueB;
                    
                    if (sortBy === 'name') {
                        valueA = cellA.textContent.toLowerCase();
                        valueB = cellB.textContent.toLowerCase();
                        return sortDirection === 'desc' 
                            ? valueA.localeCompare(valueB)
                            : valueB.localeCompare(valueA);
                    } else {
                        valueA = parseFloat(cellA.textContent);
                        valueB = parseFloat(cellB.textContent);
                        
                        if (sortBy === 'impact') {
                            // Sort by absolute value for impact
                            valueA = Math.abs(valueA);
                            valueB = Math.abs(valueB);
                        }
                        
                        return sortDirection === 'desc' 
                            ? valueB - valueA 
                            : valueA - valueB;
                    }
                });
                
                // Function to get column index based on sort key
                function getColumnIndex(key) {
                    switch (key) {
                        case 'name': return 1;
                        case 'impact': return 2;
                        case 'importance': return 3;
                        default: return 1;
                    }
                }
                
                // Reappend sorted rows
                rows.forEach(row => tableBody.appendChild(row));
            } catch (error) {
                console.error("Error sorting feature table:", error);
            }
        },
        
        /**
         * Show no data message in container
         * @param {HTMLElement} container - Container element
         * @param {string} message - Message to display
         */
        showNoDataMessage: function(container, message) {
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 800px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados não disponíveis</h3>
                    <p style="color: #333; font-size: 16px; line-height: 1.4;">
                        ${message}
                    </p>
                    <p style="color: #333; margin-top: 20px; font-size: 14px;">
                        Não serão gerados dados sintéticos ou demonstrativos. Apenas dados reais serão exibidos.
                    </p>
                </div>`;
        },
        
        /**
         * Show error message in container
         * @param {HTMLElement} container - Container element
         * @param {string} errorMessage - Error message to display
         */
        showErrorMessage: function(container, errorMessage) {
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                </div>`;
        }
    };
    
    // Initialize when document is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize after a small delay to ensure everything is loaded
        setTimeout(function() {
            if (document.getElementById('feature-importance-chart')) {
                window.FeatureImportanceHandler.initialize();
            }
        }, 500);
    });
})();

// ----- importance_comparison_handler.js ----- //
// Importance Comparison Handler
// This is a standalone script that handles the importance comparison visualization

(function() {
    // Create the handler
    window.ImportanceComparisonHandler = {
        /**
         * Initialize the importance comparison visualization
         */
        initialize: function() {
            console.log("Initializing importance comparison handler");
            
            try {
                // Initialize the importance comparison chart
                this.initializeImportanceComparisonChart();
                
                console.log("Importance comparison handler initialized");
            } catch (error) {
                console.error("Error initializing importance comparison handler:", error);
            }
        },
        
        /**
         * Initialize the importance comparison chart using Plotly
         */
        initializeImportanceComparisonChart: function() {
            try {
                const chartContainer = document.getElementById('importance-comparison-chart-plot');
                if (!chartContainer) return;
                
                // Get feature importance data
                const chartData = this.extractImportanceComparisonData();
                if (!chartData || !chartData.features || chartData.features.length === 0) {
                    this.showNoDataMessage(chartContainer, "No feature importance comparison data available");
                    return;
                }
                
                // Create chart
                this.renderImportanceComparisonChart(chartContainer, chartData);
            } catch (error) {
                console.error("Error initializing importance comparison chart:", error);
                const container = document.getElementById('importance-comparison-chart-plot');
                if (container) {
                    this.showErrorMessage(container, "Error initializing chart: " + error.message);
                }
            }
        },
        
        /**
         * Extract importance comparison data from report data
         * @returns {Object} Importance comparison data
         */
        extractImportanceComparisonData: function() {
            try {
                // Try to get data from various sources
                let featureImportance = {};
                let modelFeatureImportance = {};
                
                // Function to check if we have enough usable feature data
                const hasEnoughFeatureData = (data) => {
                    return data && typeof data === 'object' && 
                           Object.keys(data).length > 0 && 
                           Object.keys(data).length < 1000; // Sanity check to avoid giant objects
                };
                
                // Check multiple sources in order of preference
                if (window.reportConfig && hasEnoughFeatureData(window.reportConfig.feature_importance)) {
                    featureImportance = window.reportConfig.feature_importance;
                    modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                    console.log("Using feature importance from reportConfig");
                } 
                else if (window.chartData && hasEnoughFeatureData(window.chartData.feature_importance)) {
                    featureImportance = window.chartData.feature_importance;
                    modelFeatureImportance = window.chartData.model_feature_importance || {};
                    console.log("Using feature importance from chartData");
                }
                else if (window.reportData) {
                    if (hasEnoughFeatureData(window.reportData.feature_importance)) {
                        featureImportance = window.reportData.feature_importance;
                        modelFeatureImportance = window.reportData.model_feature_importance || {};
                        console.log("Using feature importance from reportData");
                    }
                    else if (window.reportData.chart_data_json && typeof window.reportData.chart_data_json === 'string') {
                        // Try to parse the chart_data_json string
                        try {
                            const chartData = JSON.parse(window.reportData.chart_data_json);
                            if (chartData && hasEnoughFeatureData(chartData.feature_importance)) {
                                featureImportance = chartData.feature_importance;
                                modelFeatureImportance = chartData.model_feature_importance || {};
                                console.log("Using feature importance from parsed chart_data_json");
                            }
                        } catch (e) {
                            console.error("Error parsing chart_data_json:", e);
                        }
                    }
                }
                
                // Try FeatureImportanceTableManager as a fallback
                if (Object.keys(featureImportance).length === 0 && 
                    typeof FeatureImportanceTableManager !== 'undefined' && 
                    typeof FeatureImportanceTableManager.extractFeatureData === 'function') {
                    try {
                        const featureData = FeatureImportanceTableManager.extractFeatureData();
                        if (featureData && featureData.length > 0) {
                            // Convert the array format back to object format
                            featureImportance = {};
                            modelFeatureImportance = {};
                            
                            featureData.forEach(item => {
                                featureImportance[item.name] = item.robustness;
                                modelFeatureImportance[item.name] = item.importance;
                            });
                            
                            console.log("Using feature importance from FeatureImportanceTableManager");
                        }
                    } catch (e) {
                        console.error("Error using FeatureImportanceTableManager:", e);
                    }
                }
                
                // Only if there's absolutely no data available, use empty objects
                // We will not generate synthetic data - we'll let the UI show a "no data" message
                if (Object.keys(featureImportance).length === 0) {
                    console.warn("No feature importance data available - returning null");
                    return null;
                }
                
                // Convert to arrays for plotting
                const featureArray = [];
                for (const feature in featureImportance) {
                    // We include all features with robustness values, even if model importance is missing
                    // (we'll just use 0 for missing model importance)
                    featureArray.push({
                        name: feature,
                        robustness: featureImportance[feature],
                        model: modelFeatureImportance[feature] || 0
                    });
                }
                
                // Sort by absolute robustness impact
                featureArray.sort((a, b) => Math.abs(b.robustness) - Math.abs(a.robustness));
                
                // Get top features (up to 10)
                const topFeatures = featureArray.slice(0, 10);
                
                // Check if we have any data
                if (topFeatures.length === 0) {
                    console.warn("No features data available after processing");
                    return null;
                }
                
                return {
                    features: topFeatures.map(f => f.name),
                    robustnessValues: topFeatures.map(f => f.robustness),
                    modelValues: topFeatures.map(f => f.model)
                };
            } catch (error) {
                console.error("Error extracting importance comparison data:", error);
                return null;
            }
        },
        
        /**
         * Render importance comparison chart using Plotly
         * @param {HTMLElement} container - Chart container element
         * @param {Object} chartData - Chart data object
         */
        renderImportanceComparisonChart: function(container, chartData) {
            try {
                // Verify Plotly is available
                if (typeof Plotly === 'undefined') {
                    this.showErrorMessage(container, "Plotly library not available");
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                // Verificar se já existe um gráfico e removê-lo completamente
                Plotly.purge(container);
                
                // Criar gráfico de dispersão (o primeiro estilo que aparece)
                // Este é um estilo de gráfico diferente que mostra a correlação
                // entre a importância do modelo e o impacto de robustez
                
                // Preparar dados para o gráfico de dispersão
                const scatterData = chartData.features.map((feature, index) => {
                    return {
                        feature,
                        model: chartData.modelValues[index], 
                        robustness: chartData.robustnessValues[index]
                    };
                });
                
                // Criar trace de dispersão
                const scatterTrace = {
                    x: chartData.modelValues,
                    y: chartData.robustnessValues,
                    mode: 'markers+text',
                    type: 'scatter',
                    text: chartData.features,
                    textposition: 'top center',
                    textfont: {
                        family: 'Arial, sans-serif',
                        size: 10,
                        color: 'rgba(0, 0, 0, 0.7)'
                    },
                    marker: {
                        size: 12,
                        color: 'rgba(93, 109, 235, 0.8)',
                        line: {
                            color: 'rgba(0, 0, 0, 0.5)',
                            width: 1
                        }
                    },
                    name: 'Features'
                };
                
                // Criar linha de referência diagonal (onde model importance = robustness impact)
                // Encontrar valores mínimos e máximos para os eixos
                const allValues = [...chartData.modelValues, ...chartData.robustnessValues];
                const minVal = Math.min(...allValues.filter(v => !isNaN(v)));
                const maxVal = Math.max(...allValues.filter(v => !isNaN(v)));
                
                const refLine = {
                    x: [minVal, maxVal],
                    y: [minVal, maxVal],
                    mode: 'lines',
                    type: 'scatter',
                    line: {
                        color: 'rgba(200, 200, 200, 0.5)',
                        dash: 'dash',
                        width: 1
                    },
                    showlegend: false
                };
                
                // Layout para gráfico de dispersão
                const layout = {
                    title: 'Model Importance vs Robustness Impact',
                    xaxis: {
                        title: 'Model Importance',
                        zeroline: true
                    },
                    yaxis: {
                        title: 'Robustness Impact',
                        zeroline: true
                    },
                    hovermode: 'closest',
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    },
                    margin: {
                        l: 60,
                        r: 20,
                        t: 60,
                        b: 80
                    },
                    annotations: [{
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.02,
                        y: 0.98,
                        text: 'Features above line: higher robustness impact than model importance',
                        showarrow: false,
                        font: {
                            size: 12,
                            color: 'rgba(0, 0, 0, 0.6)'
                        }
                    }]
                };
                
                // Create plot with scatter chart and reference line
                Plotly.newPlot(container, [scatterTrace, refLine], layout, {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtons: [[
                        'zoom2d', 
                        'pan2d', 
                        'resetScale2d', 
                        'toImage'
                    ]]
                });
                
                console.log("Importance comparison chart rendered successfully");
            } catch (error) {
                console.error("Error rendering importance comparison chart:", error);
                this.showErrorMessage(container, "Error rendering chart: " + error.message);
            }
        },
        
        /**
         * Show no data message in container
         * @param {HTMLElement} container - Container element
         * @param {string} message - Message to display
         */
        showNoDataMessage: function(container, message) {
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;">📊</div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">Dados não disponíveis</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.4;">
                        ${message}
                    </p>
                    <p style="color: #666; font-size: 14px; margin-top: 20px;">
                        Nenhum dado sintético será gerado. Execute testes com cálculo de importância de características habilitado para visualizar dados reais.
                    </p>
                </div>`;
        },
        
        /**
         * Show error message in container
         * @param {HTMLElement} container - Container element
         * @param {string} errorMessage - Error message to display
         */
        showErrorMessage: function(container, errorMessage) {
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                </div>`;
        }
    };
    
    // Initialize when document is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize after a small delay to ensure everything is loaded
        setTimeout(function() {
            if (document.getElementById('importance-comparison-chart-plot')) {
                window.ImportanceComparisonHandler.initialize();
            }
        }, 500);
    });
})();

// ----- Chart JS Files ----- //

// ----- charts/boxplot.js ----- //
/**
 * Boxplot Chart Manager
 * Handles boxplot visualization logic for robustness reports
 * Updated: May 7, 2024 - Removed synthetic data generation
 */

const BoxplotChartManager = {
    /**
     * Initialize boxplot chart
     * @param {string} elementId - Chart container ID
     */
    initializeBoxplotChart: function(elementId) {
        console.log("BoxplotChartManager initializing boxplot chart in:", elementId);
        
        const container = document.getElementById(elementId);
        if (!container) {
            console.error("Chart container not found:", elementId);
            return;
        }
        
        try {
            // Extract data for boxplot
            const chartData = this.extractBoxplotData();
            
            if (!chartData || !chartData.models || chartData.models.length === 0 || 
                !chartData.models.some(m => m.scores && m.scores.length > 0)) {
                console.error("No valid chart data available");
                this.showNoDataMessage(container, "Dados de boxplot não disponíveis. Execute testes com iterações múltiplas para visualizar a distribuição dos scores.");
                return;
            }
            
            // Create the Plotly boxplot visualization
            this.createPlotlyBoxplot(container, chartData);
            
        } catch (error) {
            console.error("Error creating boxplot chart:", error);
            this.showErrorMessage(container, error.message);
        }
    },
    
    /**
     * Extract data for boxplot from report data
     * @returns {Object} Data for boxplot chart
     */
    extractBoxplotData: function() {
        try {
            // Get data from window.reportData or window.chartData
            const reportData = window.reportData || {};
            const chartData = window.chartData || {};
            
            // Check if we have pre-processed boxplot data
            if (chartData.boxplot_data && chartData.boxplot_data.models && 
                chartData.boxplot_data.models.length > 0) {
                console.log("Using pre-processed boxplot data");
                
                // Filter models to only include those with real scores
                const validModels = chartData.boxplot_data.models.filter(model => 
                    model.scores && model.scores.length > 0
                );
                
                if (validModels.length === 0) {
                    console.error("No models with valid scores found in boxplot_data");
                    return null;
                }
                
                return {
                    models: validModels,
                    metricName: reportData.metric || 'Score'
                };
            }
            
            // If no pre-processed data, try to extract from reportData
            if (reportData.boxplot_data && reportData.boxplot_data.models && 
                reportData.boxplot_data.models.length > 0) {
                console.log("Using reportData.boxplot_data");
                
                // Filter models to only include those with real scores
                const validModels = reportData.boxplot_data.models.filter(model => 
                    model.scores && model.scores.length > 0
                );
                
                if (validModels.length === 0) {
                    console.error("No models with valid scores found in reportData.boxplot_data");
                    return null;
                }
                
                return {
                    models: validModels,
                    metricName: reportData.metric || 'Score'
                };
            }
            
            // No pre-processed data, try to extract from raw data
            console.log("No pre-processed boxplot data, extracting from raw data");
            
            if (!reportData.raw || !reportData.raw.by_level) {
                console.error("No raw data available for boxplot extraction");
                return null;
            }
            
            // Extract primary model data
            const primaryModelData = {
                name: reportData.model_name || 'Primary Model',
                modelType: reportData.model_type || 'Unknown',
                baseScore: reportData.base_score || 0,
                scores: []
            };
            
            // Extract scores from perturbation levels
            Object.keys(reportData.raw.by_level).forEach(level => {
                const levelData = reportData.raw.by_level[level];
                
                if (levelData.runs && levelData.runs.all_features) {
                    levelData.runs.all_features.forEach(run => {
                        if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                            primaryModelData.scores.push(...run.iterations.scores);
                        }
                    });
                }
            });
            
            // Only proceed if we have real scores
            if (primaryModelData.scores.length === 0) {
                console.error("No real scores found for primary model");
            }
            
            const models = [primaryModelData];
            
            // Extract alternative models if available
            if (reportData.alternative_models) {
                Object.keys(reportData.alternative_models).forEach(modelName => {
                    const modelData = reportData.alternative_models[modelName];
                    
                    const altModelData = {
                        name: modelName,
                        modelType: modelData.model_type || 'Unknown',
                        baseScore: modelData.base_score || 0,
                        scores: []
                    };
                    
                    // Extract scores if raw data is available
                    if (modelData.raw && modelData.raw.by_level) {
                        Object.keys(modelData.raw.by_level).forEach(level => {
                            const levelData = modelData.raw.by_level[level];
                            
                            if (levelData.runs && levelData.runs.all_features) {
                                levelData.runs.all_features.forEach(run => {
                                    if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                                        altModelData.scores.push(...run.iterations.scores);
                                    }
                                });
                            }
                        });
                    }
                    
                    // Only add if real scores are available
                    if (altModelData.scores.length === 0) {
                        console.error(`No real scores found for model ${modelName}`);
                    }
                    
                    models.push(altModelData);
                });
            }
            
            // Ensure at least one model has valid scores
            if (!models.some(model => model.scores && model.scores.length > 0)) {
                console.error("No models with valid scores found");
                return null;
            }
            
            return {
                models,
                metricName: reportData.metric || 'Score'
            };
            
        } catch (error) {
            console.error("Error extracting boxplot data:", error);
            return null;
        }
    },
    
    /**
     * Create Plotly boxplot visualization
     * @param {HTMLElement} container - Chart container element
     * @param {Object} chartData - Data for chart
     */
    createPlotlyBoxplot: function(container, chartData) {
        if (typeof Plotly === 'undefined') {
            console.error("Plotly is not available");
            this.showErrorMessage(container, "Plotly library is not available. Charts cannot be displayed.");
            return;
        }
        
        const models = chartData.models;
        const traces = [];
        
        // Define consistent colors for models
        const modelColors = {
            'Primary Model': 'rgba(31, 119, 180, 0.7)',
            'primary_model': 'rgba(31, 119, 180, 0.7)',
            'GLM_CLASSIFIER': 'rgba(255, 127, 14, 0.7)',
            'GAM_CLASSIFIER': 'rgba(44, 160, 44, 0.7)',
            'GBM': 'rgba(214, 39, 40, 0.7)',
            'XGB': 'rgba(148, 103, 189, 0.7)',
            'RANDOM_FOREST': 'rgba(140, 86, 75, 0.7)',
            'SVM': 'rgba(227, 119, 194, 0.7)',
            'NEURAL_NETWORK': 'rgba(127, 127, 127, 0.7)'
        };
        
        // Track valid models
        let validModelCount = 0;
        
        // Create traces for each model
        models.forEach(model => {
            // Skip models without real data
            if (!model.scores || model.scores.length === 0) {
                return;
            }
            
            validModelCount++;
            
            // Clean up model name for display
            const displayName = model.name.replace(/_/g, ' ').trim();
            
            // Get color or generate a deterministic color
            let color = modelColors[model.name];
            if (!color) {
                // Generate a deterministic color based on model name
                const hash = Array.from(model.name).reduce((hash, char) => {
                    return ((hash << 5) - hash) + char.charCodeAt(0);
                }, 0);
                const r = Math.abs(hash) % 200 + 55;
                const g = Math.abs(hash * 31) % 200 + 55;
                const b = Math.abs(hash * 17) % 200 + 55;
                color = `rgba(${r}, ${g}, ${b}, 0.7)`;
            }
            
            // Create violin plot for model
            traces.push({
                type: 'violin',
                y: model.scores,
                x: Array(model.scores.length).fill(displayName),
                name: displayName,
                box: {
                    visible: true,
                    width: 0.6
                },
                meanline: {
                    visible: true
                },
                line: {
                    color: 'black',
                    width: 1
                },
                fillcolor: color,
                opacity: 0.7,
                points: 'all',
                jitter: 0.3,
                pointpos: 0,
                hoverinfo: 'y+x',
                spanmode: 'soft',
                width: 0.5,
                bandwidth: 0.2
            });
        });
        
        // Add base scores as separate markers
        const baseScoreTrace = {
            type: 'scatter',
            mode: 'markers',
            y: models.map(m => m.baseScore),
            x: models.map(m => m.name.replace(/_/g, ' ').trim()),
            name: 'Base Score',
            marker: {
                size: 12,
                symbol: 'diamond',
                color: models.map(m => modelColors[m.name] || 'rgba(31, 119, 180, 0.7)'),
                line: {
                    color: 'white',
                    width: 1
                }
            },
            text: models.map(m => `Base Score: ${m.baseScore.toFixed(4)}`),
            hoverinfo: 'text+y'
        };
        
        traces.push(baseScoreTrace);
        
        // If no valid models, show error
        if (validModelCount === 0) {
            this.showNoDataMessage(container, "Nenhum modelo possui dados reais para visualização");
            return;
        }
        
        // Get metric name
        const metricName = chartData.metricName || 'Score';
        
        // Create layout
        const layout = {
            title: {
                text: `Model Performance Distribution - ${metricName}`,
                font: { size: 20 }
            },
            xaxis: {
                title: 'Models',
                tickangle: 0,
                automargin: true
            },
            yaxis: {
                title: metricName,
                zeroline: false,
                autorange: true,
                automargin: true
            },
            autosize: true,
            violinmode: 'group',
            hoverlabel: {
                bgcolor: "#FFF",
                font: { size: 12 },
                bordercolor: "#333"
            },
            showlegend: true,
            legend: {
                orientation: "h",
                yanchor: "top",
                y: 1.1,
                xanchor: "right",
                x: 1
            },
            hovermode: 'closest',
            margin: {
                l: 50,
                r: 20,
                t: 60,
                b: 80
            },
            annotations: [{
                xref: 'paper',
                yref: 'paper',
                x: 0,
                y: -0.15,
                text: 'The boxplots show model performance distribution under perturbation tests. Diamond markers indicate base scores.',
                showarrow: false,
                font: { size: 12 }
            }]
        };
        
        try {
            // Render the visualization
            Plotly.newPlot(container, traces, layout, {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                displaylogo: false,
                staticPlot: false,
                toImageButtonOptions: {
                    format: 'png',
                    filename: 'model_comparison_boxplot',
                    height: 700,
                    width: 1000,
                    scale: 2
                }
            }).then(() => {
                console.log("Boxplot chart successfully rendered");
                
                // Force a resize event to ensure proper layout
                window.dispatchEvent(new Event('resize'));
            }).catch(error => {
                console.error("Plotly.newPlot failed:", error);
                this.showErrorMessage(container, `Error rendering boxplot: ${error.message}`);
            });
        } catch (error) {
            console.error("Exception during Plotly.newPlot:", error);
            this.showErrorMessage(container, `Error rendering boxplot: ${error.message}`);
        }
    },
    
    /**
     * Calculate boxplot statistics for a set of scores
     * @param {Array} scores - Array of score values
     * @returns {Object} Boxplot statistics
     */
    calculateBoxplotStats: function(scores) {
        if (!scores || scores.length === 0) return null;
        
        // Sort scores for percentile calculations
        const sortedScores = [...scores].sort((a, b) => a - b);
        
        // Calculate statistics
        const min = sortedScores[0];
        const max = sortedScores[sortedScores.length - 1];
        
        // Find quartiles
        const getPercentile = (arr, p) => {
            const index = Math.floor(arr.length * p);
            return arr[index];
        };
        
        const q1 = getPercentile(sortedScores, 0.25);
        const median = getPercentile(sortedScores, 0.5);
        const q3 = getPercentile(sortedScores, 0.75);
        
        // Calculate IQR (Interquartile Range)
        const iqr = q3 - q1;
        
        // Calculate whiskers (using Tukey's method: 1.5 * IQR)
        const lowerWhisker = Math.max(min, q1 - 1.5 * iqr);
        const upperWhisker = Math.min(max, q3 + 1.5 * iqr);
        
        // Find outliers
        const outliers = sortedScores.filter(score => score < lowerWhisker || score > upperWhisker);
        
        return {
            min,
            max,
            q1,
            median,
            q3,
            iqr,
            lowerWhisker,
            upperWhisker,
            outliers
        };
    },
    
    /**
     * Show no data message in container
     * @param {HTMLElement} element - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(element, message) {
        element.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados não disponíveis</h3>
                <p style="color: #333; font-size: 16px; line-height: 1.4;">${message}</p>
                <p style="color: #333; margin-top: 20px; font-size: 14px;">
                    Não serão gerados dados sintéticos ou demonstrativos. Execute testes com iterações múltiplas (n_iterations > 1).
                </p>
            </div>`;
    },
    
    /**
     * Show error message in container
     * @param {HTMLElement} element - Chart container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(element, errorMessage) {
        element.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Erro ao criar gráfico</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
            </div>`;
    }
};

// ----- charts/details.js ----- //
/**
 * Overview Charts Manager
 * Handles chart creation and data visualization for the model overview page
 */
window.OverviewChartsManager = {
    /**
     * Initialize all charts on the overview page
     */
    initializeOverviewCharts: function() {
        console.log("Initializing overview charts");
        
        try {
            // Initialize the metrics radar chart
            this.initializeMetricsRadarChart("metrics-radar-chart");
        } catch (error) {
            console.error("Error initializing overview charts:", error);
            this.showErrorMessage(document.getElementById("metrics-radar-chart"), error.message);
        }
    },
    
    /**
     * Initialize metrics radar chart
     * @param {string} elementId - Chart container ID
     */
    initializeMetricsRadarChart: function(elementId) {
        console.log("Initializing metrics radar chart");
        const chartElement = document.getElementById(elementId);
        if (!chartElement) {
            console.error("Chart element not found:", elementId);
            return;
        }
        
        try {
            // Clear any previous content to avoid double rendering
            chartElement.innerHTML = '';
            
            // Extract data for chart with validation
            const chartData = this.extractMetricsRadarData();
            
            if (!chartData || !chartData.models || chartData.models.length === 0) {
                this.showNoDataMessage(chartElement, "No model metrics data available");
                return;
            }
            
            // Create data traces for each model
            const traces = [];
            
            // Get metrics and model names
            const metrics = chartData.metrics;
            const modelNames = chartData.models.map(model => model.name);
            
            // Create a radar trace for each metric
            metrics.forEach(metric => {
                const trace = {
                    type: 'scatterpolar',
                    name: metric.displayName,
                    r: chartData.models.map(model => model.metrics[metric.name]),
                    theta: modelNames,
                    fill: 'toself',
                    opacity: 0.7,
                    hovertemplate: '<b>%{theta}</b><br>' + 
                                   metric.displayName + ': %{r:.4f}<extra></extra>'
                };
                traces.push(trace);
            });
            
            // Layout for the radar chart
            const layout = {
                title: 'Comparação de Métricas por Modelo',
                polar: {
                    radialaxis: {
                        visible: true,
                        range: [0, 1],
                        showticklabels: true,
                        gridcolor: "#d9d9d9",
                        tickformat: ".2f"
                    },
                    angularaxis: {
                        gridcolor: "#d9d9d9"
                    }
                },
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                margin: {
                    l: 50,
                    r: 50,
                    t: 60,
                    b: 70
                },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: '#fff'
            };
            
            // Create the plot with error handling
            try {
                Plotly.newPlot(chartElement, traces, layout, {
                    responsive: true,
                    displayModeBar: false,
                    displaylogo: false
                });
            } catch (plotlyError) {
                console.error("Plotly rendering error:", plotlyError);
                this.showErrorMessage(chartElement, "Chart rendering failed: " + plotlyError.message);
                return;
            }
            
            // Add resize event listener
            window.addEventListener('resize', () => {
                Plotly.relayout(chartElement, {
                    'autosize': true
                });
            });
            
        } catch (error) {
            console.error("Error creating metrics radar chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Extract data for metrics radar chart
     * @returns {Object} - Metrics and model data
     */
    extractMetricsRadarData: function() {
        let models = [];
        
        // Try multiple sources for model metrics data
        let modelData = {};
        
        console.log("Data sources available:", {
            "reportData": !!window.reportData,
            "chartData": !!window.chartData,
            "config": !!window.config,
            "OverviewController": !!window.OverviewController
        });
        
        // First check if OverviewController has already loaded model data
        if (window.OverviewController && window.OverviewController.modelData && 
            Object.keys(window.OverviewController.modelData).length > 0) {
            console.log("Using data from OverviewController");
            modelData = window.OverviewController.modelData;
        }
        // Try initial_results first
        else if (window.reportData && window.reportData.initial_results && window.reportData.initial_results.models) {
            console.log("Using model data from reportData.initial_results");
            modelData = window.reportData.initial_results.models;
        }
        // Try radar_chart_data
        else if (window.chartData && window.chartData.radar_chart_data && window.chartData.radar_chart_data.models) {
            console.log("Using model data from chartData.radar_chart_data");
            modelData = window.chartData.radar_chart_data.models;
        }
        // Try window.reportData
        else if (window.reportData && window.reportData.models) {
            modelData = window.reportData.models;
            console.log("Using model data from reportData");
        } else if (window.chartData && window.chartData.models) {
            // Try chart data
            modelData = window.chartData.models;
            console.log("Using model data from chartData");
        } else if (window.config && window.config.models) {
            // Try config
            modelData = window.config.models;
            console.log("Using model data from config");
        } else {
            console.warn("No model data found in any data source");
            return null;
        }
        
        // Check if we have any model data
        if (Object.keys(modelData).length === 0) {
            console.warn("Empty model data");
            return null;
        }
        
        console.log("Found model data:", Object.keys(modelData).join(", "));
        
        console.log("Found data for", Object.keys(modelData).length, "models");
        
        try {
            // Convert to array format for plotting
            models = Object.entries(modelData).map(([key, model]) => ({
                id: key,
                name: model.name || key,
                type: model.type || "Unknown",
                metrics: model.metrics || {}
            }));
            
            // Define metrics to display
            const metrics = [
                { name: "accuracy", displayName: "Accuracy" },
                { name: "roc_auc", displayName: "ROC AUC" },
                { name: "f1", displayName: "F1 Score" },
                { name: "precision", displayName: "Precision" },
                { name: "recall", displayName: "Recall" }
            ];
            
            // Validate that each model has the required metrics
            models.forEach(model => {
                metrics.forEach(metric => {
                    if (model.metrics[metric.name] === undefined) {
                        model.metrics[metric.name] = 0;
                        console.warn(`Missing ${metric.name} metric for model ${model.name}`);
                    }
                });
            });
            
            console.log("Prepared", models.length, "models with", metrics.length, "metrics each");
            
            return {
                models,
                metrics
            };
        } catch (error) {
            console.error("Error processing model metrics data:", error);
            return null;
        }
    },
    
    /**
     * Create a custom metric chart for a specific model and metric
     * @param {string} elementId - Chart container ID
     * @param {string} modelId - Model identifier
     * @param {string} metricName - Metric name to display
     */
    createModelMetricChart: function(elementId, modelId, metricName) {
        console.log(`Creating metric chart for ${modelId} - ${metricName}`);
        const chartElement = document.getElementById(elementId);
        if (!chartElement) {
            console.error("Chart element not found:", elementId);
            return;
        }
        
        // Extract data with specific model and metric filtering
        const chartData = this.extractMetricsRadarData();
        
        if (!chartData || !chartData.models || chartData.models.length === 0) {
            this.showNoDataMessage(chartElement, "No model metrics data available");
            return;
        }
        
        try {
            // Clear previous content
            chartElement.innerHTML = '';
            
            // Find the metric display name
            const metricInfo = chartData.metrics.find(m => m.name === metricName);
            if (!metricInfo) {
                this.showErrorMessage(chartElement, `Metric ${metricName} not found`);
                return;
            }
            
            // Filter models if specific model is requested
            let modelsToUse = chartData.models;
            if (modelId !== 'all') {
                modelsToUse = chartData.models.filter(model => model.id === modelId);
                if (modelsToUse.length === 0) {
                    this.showErrorMessage(chartElement, `Model ${modelId} not found`);
                    return;
                }
            }
            
            // Prepare data for the bar chart
            const chartTrace = {
                x: modelsToUse.map(model => model.name),
                y: modelsToUse.map(model => model.metrics[metricName]),
                type: 'bar',
                marker: {
                    color: modelsToUse.map((_, index) => {
                        // Generate colors based on index
                        const colors = ['#8884d8', '#82ca9d', '#ffc658', '#ff8042', '#0088fe'];
                        return colors[index % colors.length];
                    })
                },
                hovertemplate: '<b>%{x}</b><br>' + 
                               metricInfo.displayName + ': %{y:.4f}<extra></extra>'
            };
            
            // Layout for the bar chart
            const layout = {
                title: `${metricInfo.displayName} por Modelo`,
                xaxis: {
                    title: 'Modelo',
                    automargin: true
                },
                yaxis: {
                    title: metricInfo.displayName,
                    range: [0, 1.1],
                    tickformat: '.2f'
                },
                margin: {
                    l: 60,
                    r: 30,
                    t: 60,
                    b: 80
                },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: '#fff'
            };
            
            // Create the plot
            Plotly.newPlot(chartElement, [chartTrace], layout, {
                responsive: true,
                displayModeBar: false,
                displaylogo: false
            });
            
        } catch (error) {
            console.error("Error creating model metric chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Show no data message in chart container
     * @param {HTMLElement} element - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(element, message) {
        element.innerHTML = `
            <div class="no-data-container">
                <div class="no-data-icon">📊</div>
                <h3 class="no-data-title">Dados Não Disponíveis</h3>
                <p class="no-data-message">${message}</p>
            </div>`;
    },
    
    /**
     * Show error message in chart container
     * @param {HTMLElement} element - Chart container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(element, errorMessage) {
        element.innerHTML = `
            <div class="error-container">
                <div class="error-icon">⚠️</div>
                <h3 class="error-title">Erro no Gráfico</h3>
                <p class="error-message">${errorMessage}</p>
                <div class="error-help">
                    <p class="error-help-title">Possíveis soluções:</p>
                    <ul class="error-help-list">
                        <li>Verifique se a biblioteca Plotly está carregada corretamente</li>
                        <li>Confirme que os dados dos modelos estão disponíveis</li>
                        <li>Tente recarregar a página</li>
                    </ul>
                </div>
            </div>`;
    }
};

// PerturbationResultsManager.js
// Updated: May 7, 2024 - Removed synthetic data generation
const PerturbationResultsManager = {
    /**
     * Extract perturbation data from report data
     * @returns {Object} Perturbation data
     */
    extractPerturbationData: function() {
        console.log("Extracting perturbation data from report");
        const perturbationResults = [];
        
        try {
            // Check if window.reportData exists and has necessary data
            if (!window.reportData || (!window.reportData.raw && !window.reportData.perturbation_chart_data)) {
                console.warn("Report data not found or incomplete");
                console.warn("No synthetic data will be generated - will return null");
                return null; // Return null if no report data available
            }
            
            // If the server already prepared perturbation chart data, use it
            if (window.reportData.perturbation_chart_data) {
                console.log("Using server-prepared perturbation chart data");
                return this.processPreparedChartData(window.reportData.perturbation_chart_data);
            }
            
            // Extract from raw data if available
            if (window.reportData.raw && window.reportData.raw.by_level) {
                console.log("Extracting from raw perturbation data");
                
                // Get base score and metric
                const baseScore = window.reportData.base_score || 0.0;
                const metric = window.reportData.metric || 'Score';
                
                // Process each perturbation level
                Object.keys(window.reportData.raw.by_level).forEach(level => {
                    const numericLevel = parseFloat(level);
                    const levelData = window.reportData.raw.by_level[level];
                    
                    const resultItem = {
                        level: numericLevel,
                        allFeatures: this.extractFeatureData(levelData, 'all_features', baseScore),
                        featureSubset: this.extractFeatureData(levelData, 'feature_subset', baseScore)
                    };
                    
                    // If feature subset wasn't found, try to extract from selectedFeatures
                    if (!resultItem.featureSubset.iterations.length && window.reportData.feature_subset) {
                        const featureSubset = window.reportData.feature_subset;
                        if (Array.isArray(featureSubset) && featureSubset.length > 0) {
                            const subsetName = featureSubset.join('_');
                            resultItem.featureSubset = this.extractFeatureData(levelData, subsetName, baseScore);
                        }
                    }
                    
                    perturbationResults.push(resultItem);
                });
                
                // Sort by level
                perturbationResults.sort((a, b) => a.level - b.level);
                
                // Only return if we actually have results
                if (perturbationResults.length > 0) {
                    return {
                        results: perturbationResults,
                        baseScore: baseScore,
                        metric: metric,
                        modelName: window.reportData.model_name || 'Model',
                        modelType: window.reportData.model_type || 'Model',
                        featureSubset: window.reportData.feature_subset || []
                    };
                }
            }
            
            // If no perturbation data found, return null (no synthetic data)
            console.warn("No perturbation data found in report data");
            console.warn("No synthetic data will be generated - will return null");
            return null;
            
        } catch (error) {
            console.error("Error extracting perturbation data:", error);
            console.error("No synthetic data will be generated due to error - will return null");
            return null; // Return null on error
        }
    },
    
    /**
     * Process server-prepared chart data
     * @param {Object} chartData - Server-prepared chart data 
     * @returns {Object} Processed perturbation data
     */
    processPreparedChartData: function(chartData) {
        const perturbationResults = [];
        const baseScore = chartData.baseScore || 0.0;
        const metric = chartData.metric || 'Score';
        
        // Process levels and scores
        if (chartData.levels && chartData.scores) {
            chartData.levels.forEach((level, index) => {
                const resultItem = {
                    level: level,
                    allFeatures: {
                        baseScore: baseScore,
                        meanScore: chartData.scores[index] || 0,
                        impact: (baseScore - (chartData.scores[index] || 0)) / baseScore,
                        worstScore: chartData.worstScores ? chartData.worstScores[index] || 0 : 0,
                        iterations: []
                    },
                    featureSubset: {
                        baseScore: baseScore,
                        meanScore: 0,
                        impact: 0,
                        worstScore: 0,
                        iterations: []
                    }
                };
                
                // Add iterations if available
                if (window.reportData.iterations_by_level && window.reportData.iterations_by_level[level]) {
                    resultItem.allFeatures.iterations = window.reportData.iterations_by_level[level];
                } else if (chartData.iterations && chartData.iterations[index]) {
                    resultItem.allFeatures.iterations = chartData.iterations[index];
                }
                // No synthetic iterations will be created if none are available
                
                // Process feature subset if available
                if (chartData.alternativeModels && Object.keys(chartData.alternativeModels).length > 0) {
                    const subsetName = Object.keys(chartData.alternativeModels)[0];
                    const subsetData = chartData.alternativeModels[subsetName];
                    
                    resultItem.featureSubset = {
                        baseScore: subsetData.baseScore || baseScore,
                        meanScore: subsetData.scores[index] || 0,
                        impact: (baseScore - (subsetData.scores[index] || 0)) / baseScore,
                        worstScore: subsetData.worstScores ? subsetData.worstScores[index] || 0 : 0,
                        iterations: []
                    };
                    
                    // Only add real iteration data, no synthetic data
                    if (subsetData.iterations && subsetData.iterations[index]) {
                        resultItem.featureSubset.iterations = subsetData.iterations[index];
                    }
                }
                
                perturbationResults.push(resultItem);
            });
        }
        
        return {
            results: perturbationResults,
            baseScore: baseScore,
            metric: metric,
            modelName: chartData.modelName || 'Model',
            modelType: window.reportData.model_type || 'Model',
            featureSubset: window.reportData.feature_subset || []
        };
    },
    
    /**
     * Extract feature data from level data
     * @param {Object} levelData - Level data
     * @param {string} featureKey - Feature key to extract
     * @param {number} baseScore - Base score
     * @returns {Object} Extracted feature data
     */
    extractFeatureData: function(levelData, featureKey, baseScore) {
        const result = {
            baseScore: baseScore,
            meanScore: 0,
            impact: 0,
            worstScore: 0,
            iterations: []
        };
        
        try {
            // Check if we have overall_result data
            if (levelData.overall_result && levelData.overall_result[featureKey]) {
                const featureData = levelData.overall_result[featureKey];
                
                result.meanScore = featureData.mean_score || featureData.perturbed_score || 0;
                result.worstScore = featureData.worst_score || featureData.min_score || result.meanScore;
                result.impact = (baseScore - result.meanScore) / baseScore;
                
                // If negative impact (improvement), cap at a reasonable value
                if (result.impact < -0.1) result.impact = -0.1;
            }
            
            // Extract iteration data if available - NO synthetic data generation
            if (levelData.runs && levelData.runs[featureKey] && 
                levelData.runs[featureKey][0] && 
                levelData.runs[featureKey][0].iterations &&
                levelData.runs[featureKey][0].iterations.scores) {
                    
                result.iterations = levelData.runs[featureKey][0].iterations.scores;
            }
            // No synthetic iterations data will be created
        } catch (error) {
            console.error(`Error extracting ${featureKey} data:`, error);
        }
        
        return result;
    },
    
    /**
     * Format number with specified precision
     * @param {number} num - Number to format
     * @param {number} precision - Number of decimal places
     * @returns {string} Formatted number
     */
    formatNumber: function(num, precision = 4) {
        return Number(num).toFixed(precision);
    },
    
    /**
     * Get color class based on impact
     * @param {number} impact - Impact value
     * @returns {string} CSS class for coloring
     */
    getImpactColorClass: function(impact) {
        if (impact < 0) return 'text-green-600'; // Improvement
        if (impact < 0.03) return 'text-blue-600'; // Small degradation
        if (impact < 0.07) return 'text-yellow-600'; // Medium degradation
        return 'text-red-600'; // Large degradation
    },
    
    /**
     * Get background color class based on score comparison
     * @param {number} score - Score to compare
     * @param {number} baseScore - Base score for comparison
     * @returns {string} CSS class for background coloring
     */
    getScoreBgColorClass: function(score, baseScore) {
        const diff = score - baseScore;
        if (diff > 0) return 'bg-green-100';
        if (diff > -0.01) return 'bg-yellow-50';
        if (diff > -0.03) return 'bg-orange-50';
        return 'bg-red-50';
    }
};

// ----- charts/features.js ----- //
// Feature Importance Chart Manager
window.FeatureImportanceChartManager = {
    /**
     * Initialize feature importance chart
     * @param {string} elementId - Chart container ID
     */
    initializeFeatureImportanceChart: function(elementId) {
        console.log("Initializing feature importance chart");
        const chartElement = document.getElementById(elementId);
        if (!chartElement) {
            console.error("Chart element not found:", elementId);
            return;
        }
        
        try {
            // Clear any previous content to avoid double rendering
            chartElement.innerHTML = '';
            
            // Extract data for chart with improved validation
            const chartData = this.extractFeatureImportanceData();
            
            if (!chartData || !chartData.features || chartData.features.length === 0) {
                this.showNoDataMessage(chartElement, "No feature importance data available");
                return;
            }
            
            // Create plot data for robustness impact
            const robustnessTrace = {
                x: chartData.robustnessValues,
                y: chartData.features,
                type: 'bar',
                orientation: 'h',
                name: 'Robustness Impact',
                marker: {
                    color: chartData.robustnessValues.map(val => val >= 0 ? 'rgb(136, 132, 216)' : 'rgb(216, 132, 132)')
                }
            };
            
            // Create plot data for model importance (if available)
            const plotData = [robustnessTrace];
            
            if (chartData.modelValues && chartData.modelValues.length > 0) {
                const modelTrace = {
                    x: chartData.modelValues,
                    y: chartData.features,
                    type: 'bar',
                    orientation: 'h',
                    name: 'Model Importance',
                    marker: {
                        color: 'rgb(130, 202, 157)'
                    }
                };
                plotData.push(modelTrace);
            }
            
            // Layout for the chart with improved readability
            const layout = {
                title: 'Top Features by Importance',
                xaxis: {
                    title: 'Importance Score',
                    zeroline: true,
                    zerolinecolor: '#888',
                    zerolinewidth: 1
                },
                yaxis: {
                    title: 'Feature',
                    automargin: true
                },
                barmode: 'group',
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                hovermode: 'closest',
                margin: {
                    l: 150,
                    r: 20,
                    t: 60,
                    b: 100
                },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: '#fff'
            };
            
            // Create the plot with improved error handling
            try {
                Plotly.newPlot(chartElement, plotData, layout, {
                    responsive: true,
                    displayModeBar: false,
                    modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                    displaylogo: false,
                    staticPlot: false
                });
            } catch (plotlyError) {
                console.error("Plotly rendering error:", plotlyError);
                this.showErrorMessage(chartElement, "Chart rendering failed: " + plotlyError.message);
                return;
            }
            
            // Add resize event listener to properly redraw the chart when tab becomes visible
            window.addEventListener('resize', () => {
                if (chartElement.closest('.tab-content.active')) {
                    Plotly.relayout(chartElement, {
                        'autosize': true
                    });
                }
            });
            
        } catch (error) {
            console.error("Error creating feature importance chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Extract data for feature importance chart from report data with improved validation
     */
    extractFeatureImportanceData: function() {
        let features = [];
        let robustnessValues = [];
        let modelValues = [];
        
        // First validate we have the required data
        let featureImportance = {};
        let modelFeatureImportance = {};
        
        // Try multiple sources for feature importance data
        if (window.chartData && window.chartData.feature_importance) {
            // Try chart data first (preferred source)
            featureImportance = window.chartData.feature_importance;
            modelFeatureImportance = window.chartData.model_feature_importance || {};
            console.log("Using feature importance from chartData");
        } else if (window.reportConfig && window.reportConfig.feature_importance) {
            // Try reportConfig 
            featureImportance = window.reportConfig.feature_importance;
            modelFeatureImportance = window.reportConfig.model_feature_importance || {};
            console.log("Using feature importance from reportConfig");
        } else if (window.reportData) {
            if (window.reportData.feature_importance) {
                // Try direct reportData
                featureImportance = window.reportData.feature_importance;
                modelFeatureImportance = window.reportData.model_feature_importance || {};
                console.log("Using feature importance from reportData");
            } else if (window.reportData.chart_data_json) {
                // Try parsing chart_data_json
                try {
                    const chartData = JSON.parse(window.reportData.chart_data_json);
                    featureImportance = chartData.feature_importance || {};
                    modelFeatureImportance = chartData.model_feature_importance || {};
                    console.log("Using feature importance from parsed chart_data_json");
                } catch (e) {
                    console.error("Error parsing chart_data_json:", e);
                }
            }
        }
        
        // Check if we have any feature importance data
        if (Object.keys(featureImportance).length === 0) {
            console.warn("No feature importance data found in any data source");
            return null;
        }
        
        console.log("Found feature importance data for ", Object.keys(featureImportance).length, "features");
        
        try {
            // Convert to array and sort by robustness impact (absolute value)
            const featureArray = Object.keys(featureImportance).map(feature => ({
                name: feature,
                robustnessImportance: featureImportance[feature],
                modelImportance: modelFeatureImportance[feature] || 0
            }));
            
            // Sort by absolute robustness importance value
            featureArray.sort((a, b) => Math.abs(b.robustnessImportance) - Math.abs(a.robustnessImportance));
            
            // Get top 15 features (increased from 10)
            const topFeatures = featureArray.slice(0, 15);
            
            // Extract arrays for plotting
            features = topFeatures.map(f => f.name);
            robustnessValues = topFeatures.map(f => f.robustnessImportance);
            modelValues = topFeatures.map(f => f.modelImportance);
            
            // Log what we found
            console.log("Extracted top", features.length, "features for chart");
        } catch (error) {
            console.error("Error processing feature importance data:", error);
            return null;
        }
        
        return {
            features,
            robustnessValues,
            modelValues
        };
    },
    
    /**
     * Initialize model vs robustness importance chart with improved error handling
     * @param {string} elementId - Chart container ID
     */
    initializeImportanceComparisonChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement) {
            console.error("Chart element not found:", elementId);
            return;
        }
        
        try {
            // Clear any previous content
            chartElement.innerHTML = '';
            
            // Extract data with validation
            const chartData = this.extractFeatureImportanceData();
            
            if (!chartData || !chartData.features || chartData.features.length === 0 || 
                !chartData.modelValues || chartData.modelValues.length === 0) {
                this.showNoDataMessage(chartElement, "No feature importance comparison data available");
                return;
            }
            
            // Create scatter plot data with color coding based on importance
            const importanceData = chartData.features.map((feature, i) => ({
                feature: feature,
                robustness: chartData.robustnessValues[i],
                model: chartData.modelValues[i],
                impact: Math.abs(chartData.robustnessValues[i]) // For sizing markers
            }));
            
            // Create scatter plot with color coding
            const scatterTrace = {
                x: importanceData.map(d => d.model),
                y: importanceData.map(d => d.robustness),
                mode: 'markers+text',
                type: 'scatter',
                text: importanceData.map(d => d.feature),
                textposition: 'top',
                marker: {
                    size: importanceData.map(d => Math.min(Math.max(d.impact * 500, 8), 20)), // Size by importance
                    color: importanceData.map(d => d.robustness >= 0 ? 'rgb(44, 160, 101)' : 'rgb(215, 48, 39)'),
                    opacity: 0.8,
                    line: {
                        width: 1,
                        color: '#333'
                    }
                },
                hovertemplate: '<b>%{text}</b><br>Model Importance: %{x:.4f}<br>Robustness Impact: %{y:.4f}<extra></extra>'
            };
            
            // Layout for the chart
            const layout = {
                title: 'Model vs. Robustness Importance',
                xaxis: {
                    title: 'Model Importance',
                    zeroline: true
                },
                yaxis: {
                    title: 'Robustness Impact',
                    zeroline: true
                },
                hovermode: 'closest',
                margin: {
                    l: 60,
                    r: 20,
                    t: 60,
                    b: 60
                },
                // Add reference lines at x=0 and y=0
                shapes: [
                    {
                        type: 'line',
                        x0: 0,
                        y0: 0,
                        x1: 0,
                        y1: 1,
                        yref: 'paper',
                        line: {
                            color: 'grey',
                            width: 1,
                            dash: 'dot'
                        }
                    },
                    {
                        type: 'line',
                        x0: 0,
                        y0: 0,
                        x1: 1,
                        y1: 0,
                        xref: 'paper',
                        line: {
                            color: 'grey',
                            width: 1,
                            dash: 'dot'
                        }
                    }
                ],
                annotations: [
                    {
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.01,
                        y: 0.99,
                        text: 'Negative impact on model robustness',
                        showarrow: false,
                        font: {
                            size: 11,
                            color: 'gray'
                        }
                    },
                    {
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.99,
                        y: 0.99,
                        text: 'Positive impact on model robustness',
                        showarrow: false,
                        font: {
                            size: 11,
                            color: 'gray'
                        },
                        align: 'right'
                    }
                ]
            };
            
            // Create the plot with error handling
            try {
                Plotly.newPlot(chartElement, [scatterTrace], layout, {
                    responsive: true,
                    displayModeBar: false
                });
            } catch (plotlyError) {
                console.error("Plotly rendering error:", plotlyError);
                this.showErrorMessage(chartElement, "Chart rendering failed: " + plotlyError.message);
                return;
            }
            
            // Add resize event listener
            window.addEventListener('resize', () => {
                if (chartElement.closest('.tab-content.active')) {
                    Plotly.relayout(chartElement, {
                        'autosize': true
                    });
                }
            });
            
        } catch (error) {
            console.error("Error creating importance comparison chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Show no data message in chart container with improved styling
     * @param {HTMLElement} element - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(element, message) {
        element.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;">📊</div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">No Data Available</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">
                    ${message}
                </p>
            </div>`;
    },
    
    /**
     * Show error message in chart container with improved styling
     * @param {HTMLElement} element - Chart container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(element, errorMessage) {
        element.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                <div style="margin-top: 20px; padding: 15px; background-color: #f8f8f8; border-radius: 5px; text-align: left;">
                    <p style="font-weight: bold; margin-bottom: 10px;">Troubleshooting:</p>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-bottom: 0;">
                        <li>Check if the Plotly library is loaded correctly</li>
                        <li>Verify that feature importance data is available in the report</li>
                        <li>Try reloading the page</li>
                    </ul>
                </div>
            </div>`;
    }
};

// ----- charts/featuresTable.js ----- //
// Feature Importance Table Manager
window.FeatureImportanceTableManager = {
    /**
     * Extract feature importance data from report data
     * @returns {Array} Array of feature data objects
     */
    extractFeatureData: function() {
        let featureData = [];
        
        try {
            // Try all possible sources to find feature importance data
            let featureImportance = {};
            let modelFeatureImportance = {};
            let featureSubset = [];
            
            // Check multiple sources in order of preference
            if (window.reportConfig && window.reportConfig.feature_importance) {
                // First priority - directly from reportConfig
                featureImportance = window.reportConfig.feature_importance || {};
                modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                featureSubset = window.reportConfig.feature_subset || [];
                console.log("Using feature data from reportConfig");
            } 
            else if (window.chartData && window.chartData.feature_importance) {
                // Second priority - from parsed chart data
                featureImportance = window.chartData.feature_importance || {};
                modelFeatureImportance = window.chartData.model_feature_importance || {};
                featureSubset = window.chartData.feature_subset || [];
                console.log("Using feature data from chartData");
            }
            else if (window.reportData) {
                // If we have reportData, check several possible locations
                if (window.reportData.feature_importance) {
                    // Direct property in reportData
                    featureImportance = window.reportData.feature_importance;
                    modelFeatureImportance = window.reportData.model_feature_importance || {};
                    featureSubset = window.reportData.feature_subset || [];
                    console.log("Using feature data from reportData");
                }
                else if (window.reportData.chart_data_json && typeof window.reportData.chart_data_json === 'string') {
                    // Try to parse the chart_data_json string
                    try {
                        const chartData = JSON.parse(window.reportData.chart_data_json);
                        if (chartData && chartData.feature_importance) {
                            featureImportance = chartData.feature_importance;
                            modelFeatureImportance = chartData.model_feature_importance || {};
                            featureSubset = chartData.feature_subset || [];
                            console.log("Using feature data from parsed chart_data_json");
                        }
                    } catch (e) {
                        console.error("Error parsing chart_data_json:", e);
                    }
                }
                // Try accessing perturbation_details_data for feature importance if none found
                else if (window.reportData.perturbation_details_data && 
                         window.reportData.perturbation_details_data.results && 
                         window.reportData.perturbation_details_data.results.length > 0) {
                    console.log("Extracting feature importance from perturbation_details_data");
                    try {
                        // Extract feature importance from perturbation results if available
                        // This is a new data source added by the robustness_renderer.py _prepare_perturbation_details_data method
                        const perturbData = window.reportData.perturbation_details_data;
                        
                        // Calculate feature importance based on impact at the highest perturbation level
                        if (perturbData.results && perturbData.results.length > 0) {
                            // Sort by level to get highest perturbation level
                            const sortedResults = [...perturbData.results].sort((a, b) => b.level - a.level);
                            const highestLevelData = sortedResults[0];
                            
                            if (highestLevelData && highestLevelData.allFeatures && highestLevelData.allFeatures.impact) {
                                console.log(`Using impact data from perturbation level ${highestLevelData.level}`);
                                featureImportance = { 
                                    '__impact': highestLevelData.allFeatures.impact 
                                };
                            }
                        }
                    } catch (e) {
                        console.error("Error extracting data from perturbation_details_data:", e);
                    }
                }
            }
            
            // Check for chartData directly as a global object (may be defined by inline script)
            if (Object.keys(featureImportance).length === 0 && window.chartData) {
                if (window.chartData.feature_importance) {
                    featureImportance = window.chartData.feature_importance;
                    modelFeatureImportance = window.chartData.model_feature_importance || {};
                    featureSubset = window.chartData.feature_subset || [];
                    console.log("Using feature data directly from window.chartData");
                }
            }
            
            // Check for raw report_data_json in window object
            if (Object.keys(featureImportance).length === 0 && window.report_data_json) {
                try {
                    if (typeof window.report_data_json === 'string') {
                        const parsedData = JSON.parse(window.report_data_json);
                        if (parsedData && parsedData.feature_importance) {
                            featureImportance = parsedData.feature_importance;
                            modelFeatureImportance = parsedData.model_feature_importance || {};
                            featureSubset = parsedData.feature_subset || [];
                            console.log("Using feature data from report_data_json");
                        }
                    } else if (typeof window.report_data_json === 'object') {
                        if (window.report_data_json.feature_importance) {
                            featureImportance = window.report_data_json.feature_importance;
                            modelFeatureImportance = window.report_data_json.model_feature_importance || {};
                            featureSubset = window.report_data_json.feature_subset || [];
                            console.log("Using feature data from report_data_json object");
                        }
                    }
                } catch (e) {
                    console.error("Error parsing report_data_json:", e);
                }
            }
            
            // Verificar se featureImportance é um objeto válido
            if (typeof featureImportance !== 'object' || featureImportance === null) {
                console.error("Feature importance data is not a valid object:", featureImportance);
                return [];
            }
            
            // Verificar se modelFeatureImportance é um objeto válido
            if (typeof modelFeatureImportance !== 'object' || modelFeatureImportance === null) {
                console.error("Model feature importance is not a valid object");
                modelFeatureImportance = {};
            }
            
            // Verificar se featureSubset é um array válido
            if (!Array.isArray(featureSubset)) {
                console.error("Feature subset is not a valid array");
                featureSubset = [];
            }
            
            // Convert to array format with calculated properties
            featureData = Object.entries(featureImportance).map(([name, value]) => ({
                name,
                robustness: value,
                robustnessAbs: Math.abs(value),
                impact: value,
                importance: modelFeatureImportance[name] || 0,
                impactType: value >= 0 ? 'positive' : 'negative',
                inSubset: featureSubset.includes(name)
            }));
            
            console.log(`Loaded ${featureData.length} features from data`);
        } catch (error) {
            console.error("Error extracting feature data:", error);
        }
        
        return featureData;
    },
    
    /**
     * Sort feature data by specified key and direction
     * @param {Array} data - Array of feature data objects
     * @param {string} key - Key to sort by
     * @param {string} direction - Sort direction ('asc' or 'desc')
     * @returns {Array} Sorted array
     */
    sortData: function(data, key, direction) {
        // Map sort keys to actual data properties
        const propertyMap = {
            'name': 'name',
            'impact': 'robustnessAbs', // Sort by absolute value for impact
            'importance': 'importance'
        };
        
        const sortKey = propertyMap[key] || 'robustnessAbs';
        
        return [...data].sort((a, b) => {
            let valueA = a[sortKey];
            let valueB = b[sortKey];
            
            // Special case for name: use string comparison
            if (sortKey === 'name') {
                return direction === 'asc' 
                    ? valueA.localeCompare(valueB) 
                    : valueB.localeCompare(valueA);
            }
            
            // For numeric values
            return direction === 'asc' 
                ? valueA - valueB 
                : valueB - valueA;
        });
    },
    
    /**
     * Filter feature data by search term and subset option
     * @param {Array} data - Array of feature data objects
     * @param {string} searchTerm - Search term
     * @param {boolean} showOnlySubset - Whether to show only subset features
     * @returns {Array} Filtered array
     */
    filterData: function(data, searchTerm, showOnlySubset) {
        return data.filter(item => {
            const matchesSearch = !searchTerm || item.name.toLowerCase().includes(searchTerm.toLowerCase());
            const matchesSubset = !showOnlySubset || item.inSubset;
            return matchesSearch && matchesSubset;
        });
    },
    
    /**
     * Format numeric value for display
     * @param {number} value - Value to format
     * @param {number} decimals - Number of decimal places
     * @returns {string} Formatted value
     */
    formatValue: function(value, decimals = 4) {
        return value.toFixed(decimals);
    },
    
    /**
     * Calculate visual bar width for importance values
     * @param {number} value - Importance value
     * @param {boolean} isModelImportance - Whether this is model importance
     * @returns {string} CSS width value as percentage
     */
    getBarWidth: function(value, isModelImportance = false) {
        if (isModelImportance) {
            // Model importance is typically larger, scale differently
            return `${Math.min(Math.abs(value) * 100 * 5, 100)}%`;
        }
        // For robustness, scale absolute value
        return `${Math.min(Math.abs(value) * 100 * 10, 100)}%`;
    },
    
    /**
     * Generate table rows HTML from feature data
     * @param {Array} data - Array of feature data objects
     * @param {string} hoveredRow - ID of currently hovered row
     * @returns {string} HTML for table rows
     */
    generateTableRows: function(data, hoveredRow = null) {
        let html = '';
        
        data.forEach(item => {
            const rowClasses = [
                hoveredRow === item.name ? 'hovered-row' : '',
                item.inSubset ? 'feature-subset-row' : ''
            ].filter(Boolean).join(' ');
            
            html += `
            <tr class="${rowClasses}" data-feature="${item.name}">
                <td><span class="feature-name">${item.name}</span></td>
                <td>
                    <div class="value-with-bar">
                        <span class="value-text">${this.formatValue(item.robustness)}</span>
                        <div class="progress-container">
                            <div class="progress-bar ${item.impactType}" 
                                 style="width: ${this.getBarWidth(item.robustness)}"></div>
                        </div>
                    </div>
                </td>
                <td>
                    <div class="value-with-bar">
                        <span class="value-text">${this.formatValue(item.importance)}</span>
                        <div class="progress-container">
                            <div class="progress-bar model" 
                                 style="width: ${this.getBarWidth(item.importance, true)}"></div>
                        </div>
                    </div>
                </td>
                <td>
                    <span class="subset-badge ${item.inSubset ? 'included' : 'excluded'}">
                        ${item.inSubset ? 'Included' : 'Excluded'}
                    </span>
                </td>
            </tr>`;
        });
        
        return html || this.generateNoDataMessage();
    },
    
    /**
     * Generate a "no data" message
     * @returns {string} HTML for no data message
     */
    generateNoDataMessage: function() {
        return `
        <tr>
            <td colspan="4" class="no-data-message">
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados não disponíveis</h3>
                    <p style="color: #333; font-size: 16px; line-height: 1.4;">Não há dados de importância de características disponíveis.</p>
                    <p style="color: #333; margin-top: 20px; font-size: 14px;">
                        Execute testes de robustez com análise de importância de características habilitada.
                    </p>
                </div>
            </td>
        </tr>`;
    },
    
    /**
     * Generate an error message
     * @param {string} errorMessage - Error message to display
     * @returns {string} HTML for error message
     */
    generateErrorMessage: function(errorMessage) {
        return `
        <tr>
            <td colspan="4" class="error-message">
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Erro ao carregar dados</h3>
                    <p style="color: #333; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                    <p style="color: #333; margin-top: 20px; font-size: 14px;">
                        Não serão exibidos dados sintéticos. Apenas dados reais são aceitos.
                    </p>
                </div>
            </td>
        </tr>`;
    },
    
    /**
     * Generate feature count statistics
     * @param {Array} data - Feature data array
     * @returns {Object} Count statistics
     */
    getFeatureCounts: function(data) {
        return {
            total: data.length,
            inSubset: data.filter(f => f.inSubset).length
        };
    }
};

// ----- charts/modelComparison.js ----- //
// Model Comparison Manager
const ModelComparisonManager = {
    // State variables
    state: {
        expandedRow: null,
        selectedMetric: 'roc_auc',
        highlightBest: true,
        modelData: {}
    },
    
    /**
     * Initialize the manager with model data
     * @param {Object} modelData - Model comparison data
     */
    initialize: function(modelData) {
        // Store model data
        this.state.modelData = modelData || {};
        
        // Render initial tables
        this.renderTable('overview-tab');
    },
    
    /**
     * Update the selected metrics display
     * @param {string} metric - Selected metric
     */
    updateMetricsDisplay: function(metric) {
        this.state.selectedMetric = metric;
        this.renderTable('metrics-tab');
    },
    
    /**
     * Set highlight best flag
     * @param {boolean} highlight - Whether to highlight best values
     */
    setHighlightBest: function(highlight) {
        this.state.highlightBest = highlight;
    },
    
    /**
     * Toggle row expansion
     * @param {string} modelKey - Key of the model to toggle
     */
    toggleRowExpansion: function(modelKey) {
        if (this.state.expandedRow === modelKey) {
            this.state.expandedRow = null;
        } else {
            this.state.expandedRow = modelKey;
        }
        
        // Re-render active table
        const activeTab = document.querySelector('.model-comparison-tab.active');
        if (activeTab) {
            const tabId = activeTab.getAttribute('data-tab');
            this.renderTable(tabId);
        }
    },
    
    /**
     * Format number with specified precision
     * @param {number} num - Number to format
     * @param {number} precision - Decimal precision
     * @returns {string} - Formatted number
     */
    formatNumber: function(num, precision = 4) {
        return Number(num).toFixed(precision);
    },
    
    /**
     * Get CSS class for robustness score
     * @param {number} score - Robustness score
     * @returns {string} - CSS class
     */
    getRobustnessColor: function(score) {
        if (score >= 0.95) return 'bg-green-500';
        if (score >= 0.85) return 'bg-blue-500';
        if (score >= 0.75) return 'bg-yellow-500';
        return 'bg-red-500';
    },
    
    /**
     * Get text color for impact value
     * @param {number} impact - Impact value
     * @returns {string} - CSS class
     */
    getImpactTextColor: function(impact) {
        if (impact < 0) return 'text-green-600'; // Improvement
        if (impact < 0.05) return 'text-blue-600'; // Small degradation
        if (impact < 0.1) return 'text-yellow-600'; // Medium degradation
        return 'text-red-600'; // Large degradation
    },
    
    /**
     * Find best value for a given metric across all models
     * @param {string} metric - Metric to compare
     * @returns {number} - Best value
     */
    getBestValue: function(metric) {
        const values = Object.values(this.state.modelData).map(model => 
            metric === 'robustness_score' ? model[metric] : 
            metric === 'raw_impact' ? model[metric] : 
            model.metrics[metric]
        );
        return Math.max(...values);
    },
    
    /**
     * Determine if a value is the best for its metric
     * @param {string} modelKey - Model key
     * @param {string} metric - Metric to compare
     * @returns {boolean} - Whether value is best
     */
    isBestValue: function(modelKey, metric) {
        if (!this.state.highlightBest) return false;
        
        const bestValue = this.getBestValue(metric);
        const modelValue = metric === 'robustness_score' ? this.state.modelData[modelKey][metric] : 
                           metric === 'raw_impact' ? this.state.modelData[modelKey][metric] : 
                           this.state.modelData[modelKey].metrics[metric];
        
        // For raw_impact, lower is better (with negative being best)
        if (metric === 'raw_impact') {
            return modelValue === Math.min(...Object.values(this.state.modelData).map(m => m[metric]));
        }
        
        return Math.abs(modelValue - bestValue) < 0.0001; // Account for floating point issues
    },
    
    /**
     * Render table based on tab ID
     * @param {string} tabId - Tab ID
     */
    renderTable: function(tabId) {
        const tableContainer = document.getElementById(tabId);
        if (!tableContainer) return;
        
        let tableHTML = '';
        
        switch (tabId) {
            case 'overview-tab':
                tableHTML = this.renderOverviewTable();
                break;
            case 'robustness-tab':
                tableHTML = this.renderRobustnessTable();
                break;
            case 'metrics-tab':
                tableHTML = this.renderMetricsTable();
                break;
            default:
                tableHTML = '<div class="text-center p-4">No data available</div>';
        }
        
        tableContainer.innerHTML = tableHTML;
    },
    
    /**
     * Render overview comparison table
     * @returns {string} - HTML for overview table
     */
    renderOverviewTable: function() {
        let html = `
        <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Model
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Base Score
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Robustness
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Impact
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Key Features
                    </th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">`;
            
        // Add rows for each model
        for (const [modelKey, model] of Object.entries(this.state.modelData)) {
            // Create the main model row
            html += `
                <tr 
                    data-model-key="${modelKey}"
                    class="${this.state.expandedRow === modelKey ? 'bg-blue-50' : ''} hover:bg-gray-50 cursor-pointer"
                >
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="flex items-center">
                            <div class="flex-shrink-0 h-10 w-10 rounded-full flex items-center justify-center ${
                                modelKey === 'primary_model' ? 'bg-blue-100' : 'bg-gray-100'
                            }">
                                <span class="text-lg font-bold">${model.name.charAt(0)}</span>
                            </div>
                            <div class="ml-4">
                                <div class="text-sm font-medium text-gray-900">${model.name}</div>
                                <div class="text-xs text-gray-500">${model.type}</div>
                            </div>
                        </div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 ${
                        this.isBestValue(modelKey, 'base_score') ? 'font-bold text-green-600' : ''
                    }">
                        ${this.formatNumber(model.base_score)}
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="flex items-center">
                            <span class="px-2 py-1 inline-flex text-xs leading-5 font-semibold rounded-full text-white ${
                                this.getRobustnessColor(model.robustness_score)
                            }">
                                ${this.formatNumber(model.robustness_score * 100, 1)}%
                            </span>
                        </div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap">
                        <span class="text-sm ${this.getImpactTextColor(model.raw_impact)}">
                            ${model.raw_impact < 0 ? '+' : ''}
                            ${this.formatNumber(Math.abs(model.raw_impact) * 100, 2)}%
                        </span>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        ${Object.keys(model.featureImportance).slice(0, 3).join(', ')}
                    </td>
                </tr>`;
                
            // Add expanded row if model is expanded
            if (this.state.expandedRow === modelKey) {
                html += `
                <tr class="bg-blue-50">
                    <td colspan="5" class="px-6 py-4">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <h3 class="font-medium text-gray-900 mb-2">Performance Metrics</h3>
                                <div class="grid grid-cols-2 gap-2">`;
                                
                for (const [metricName, value] of Object.entries(model.metrics)) {
                    html += `
                    <div class="flex justify-between p-2 bg-white rounded shadow-sm">
                        <span class="text-sm font-medium text-gray-500 capitalize">
                            ${metricName.replace('_', ' ')}:
                        </span>
                        <span class="text-sm font-medium text-gray-900">
                            ${this.formatNumber(value)}
                        </span>
                    </div>`;
                }
                
                html += `
                                </div>
                            </div>
                            
                            <div>
                                <h3 class="font-medium text-gray-900 mb-2">Key Features Importance</h3>
                                <div class="space-y-2">`;
                                
                for (const [feature, value] of Object.entries(model.featureImportance)) {
                    html += `
                    <div class="flex items-center">
                        <span class="text-sm font-medium text-gray-500 w-24">${feature}:</span>
                        <div class="flex-grow bg-gray-200 rounded-full h-2">
                            <div 
                                class="h-2 rounded-full ${value < 0 ? 'bg-red-500' : 'bg-blue-500'}"
                                style="width: ${Math.min(Math.abs(value) * 100 * 3, 100)}%"
                            ></div>
                        </div>
                        <span class="text-sm text-gray-900 ml-2">
                            ${this.formatNumber(value, 4)}
                        </span>
                    </div>`;
                }
                
                html += `
                                </div>
                            </div>
                        </div>
                    </td>
                </tr>`;
            }
        }
        
        html += `
            </tbody>
        </table>`;
        
        return html;
    },
    
    /**
     * Render robustness comparison table
     * @returns {string} - HTML for robustness table
     */
    renderRobustnessTable: function() {
        // Define perturbation levels - typically 0 to 1
        const perturbationLevels = [0, 0.1, 0.2, 0.4, 0.6, 0.8, 1.0];
        
        // Get perturbation scores from model data
        const perturbationScores = this.generatePerturbationScores(perturbationLevels);
        
        // Check if any valid scores exist
        const hasValidScores = Object.values(perturbationScores).some(scores => 
            scores.some(score => score !== null)
        );
        
        if (!hasValidScores) {
            return `
            <div class="p-6 text-center">
                <div class="text-red-500 mb-3">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                </div>
                <h3 class="text-lg font-medium text-gray-900 mb-2">No Perturbation Data Available</h3>
                <p class="text-gray-600">Perturbation analysis requires real data from robustness testing. Please run robustness tests to generate this data.</p>
            </div>`;
        }
        
        let html = `
        <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Model
                    </th>`;
                    
        // Add column for each perturbation level
        for (const level of perturbationLevels) {
            html += `
                    <th class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                        ${level * 100}%
                    </th>`;
        }
        
        html += `
                    <th class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Impact
                    </th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">`;
            
        // Add rows for each model
        for (const [modelKey, model] of Object.entries(this.state.modelData)) {
            html += `
                <tr 
                    data-model-key="${modelKey}"
                    class="${this.state.expandedRow === modelKey ? 'bg-blue-50' : ''} hover:bg-gray-50 cursor-pointer"
                >
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="flex items-center">
                            <div class="flex-shrink-0 h-8 w-8 rounded-full flex items-center justify-center ${
                                modelKey === 'primary_model' ? 'bg-blue-100' : 'bg-gray-100'
                            }">
                                <span class="text-md font-bold">${model.name.charAt(0)}</span>
                            </div>
                            <div class="ml-3 text-sm font-medium text-gray-900">${model.name}</div>
                        </div>
                    </td>`;
                    
            // Add cell for each perturbation level
            for (let i = 0; i < perturbationLevels.length; i++) {
                const level = perturbationLevels[i];
                const score = perturbationScores[modelKey][i];
                
                // Skip null scores
                if (score === null) {
                    html += `
                    <td class="px-4 py-3 text-center text-sm bg-gray-100">
                        <div class="font-medium text-gray-400">N/A</div>
                    </td>`;
                    continue;
                }
                
                const baseScore = model.base_score;
                const diff = score - baseScore;
                const percentChange = (diff / baseScore) * 100;
                
                // Get background color based on performance change
                let bgColor = 'bg-white';
                if (level === 0) {
                    bgColor = 'bg-gray-100';
                } else if (diff > 0) {
                    bgColor = 'bg-green-50';
                } else if (diff < -0.1) {
                    bgColor = 'bg-red-50';
                } else if (diff < -0.05) {
                    bgColor = 'bg-orange-50';
                } else if (diff < 0) {
                    bgColor = 'bg-yellow-50';
                }
                
                html += `
                    <td class="px-4 py-3 text-center text-sm ${bgColor}">
                        <div class="font-medium text-gray-900">
                            ${this.formatNumber(score)}
                        </div>
                        ${level > 0 ? `
                        <div class="text-xs ${
                            diff >= 0 ? 'text-green-600' : diff < -0.1 ? 'text-red-600' : 'text-yellow-600'
                        }">
                            ${diff >= 0 ? '+' : ''}
                            ${this.formatNumber(percentChange, 1)}%
                        </div>
                        ` : ''}
                    </td>`;
            }
            
            html += `
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-center font-medium ${
                        this.getImpactTextColor(model.raw_impact)
                    }">
                        ${model.raw_impact < 0 ? 'Improved' : this.formatNumber(model.raw_impact * 100, 1) + '%'}
                    </td>
                </tr>`;
        }
        
        html += `
            </tbody>
        </table>`;
        
        return html;
    },
    
    /**
     * Get perturbation scores for each model
     * @param {Array} levels - Perturbation levels
     * @returns {Object} - Scores by model and level
     */
    generatePerturbationScores: function(levels) {
        // Check if model data contains perturbation results
        if (!this.state.modelData || Object.keys(this.state.modelData).length === 0) {
            console.error('No model data available for perturbation analysis');
            return {};
        }

        // Initialize scores object
        const scores = {};
        
        for (const [modelKey, model] of Object.entries(this.state.modelData)) {
            // Check if model has perturbation data
            if (!model.perturbationResults) {
                console.warn(`No perturbation data available for model: ${model.name}`);
                scores[modelKey] = levels.map(() => null);
                continue;
            }
            
            scores[modelKey] = [];
            
            // Map each level to its score from the real data
            for (const level of levels) {
                const levelData = model.perturbationResults.find(p => 
                    Math.abs(p.level - level) < 0.001
                );
                
                if (levelData && levelData.score !== undefined) {
                    scores[modelKey].push(levelData.score);
                } else if (level === 0) {
                    // Use base score for level 0 if not explicitly provided
                    scores[modelKey].push(model.base_score);
                } else {
                    scores[modelKey].push(null);
                }
            }
        }
        
        return scores;
    },
    
    /**
     * Render metrics comparison table
     * @returns {string} - HTML for metrics table
     */
    renderMetricsTable: function() {
        const metric = this.state.selectedMetric;
        
        let html = `
        <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Model
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        ${metric === 'roc_auc' ? 'ROC AUC' : 
                          metric === 'f1' ? 'F1 Score' : 
                          metric.charAt(0).toUpperCase() + metric.slice(1)}
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Robustness
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Trade-off
                    </th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">`;
        
        // Add rows for each model
        for (const [modelKey, model] of Object.entries(this.state.modelData)) {
            // Calculate the trade-off metric (performance x robustness)
            const metricValue = metric === 'robustness_score' ? model.robustness_score : 
                                metric === 'raw_impact' ? model.raw_impact : 
                                model.metrics[metric];
                                
            const tradeoffValue = metricValue * model.robustness_score;
            
            // Check if this model has the best trade-off
            const isBestTradeoff = this.isHighestTradeoff(modelKey, metric);
            
            html += `
                <tr 
                    class="${isBestTradeoff && this.state.highlightBest ? 'bg-green-50' : ''} hover:bg-gray-50"
                    data-model-key="${modelKey}"
                >
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="flex items-center">
                            <div class="flex-shrink-0 h-8 w-8 rounded-full flex items-center justify-center ${
                                modelKey === 'primary_model' ? 'bg-blue-100' : 'bg-gray-100'
                            }">
                                <span class="text-md font-bold">${model.name.charAt(0)}</span>
                            </div>
                            <div class="ml-3 text-sm font-medium text-gray-900">${model.name}</div>
                        </div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${
                        this.isBestValue(modelKey, metric) ? 'font-bold text-blue-600' : 'text-gray-500'
                    }">
                        ${this.formatNumber(metricValue)}
                        
                        <div class="mt-1 w-32 bg-gray-200 rounded-full h-2">
                            <div 
                                class="h-2 rounded-full bg-blue-500"
                                style="width: ${Math.min(metricValue * 100, 100)}%"
                            ></div>
                        </div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${
                        this.isBestValue(modelKey, 'robustness_score') ? 'font-bold text-blue-600' : 'text-gray-500'
                    }">
                        ${this.formatNumber(model.robustness_score, 2)}
                        
                        <div class="mt-1 w-32 bg-gray-200 rounded-full h-2">
                            <div 
                                class="h-2 rounded-full ${this.getRobustnessColor(model.robustness_score)}"
                                style="width: ${Math.min(model.robustness_score * 100, 100)}%"
                            ></div>
                        </div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="text-sm text-gray-900 font-medium">
                            ${this.formatNumber(tradeoffValue, 3)}
                        </div>
                        <div class="text-xs text-gray-500">
                            Performance × Robustness
                        </div>
                    </td>
                </tr>`;
        }
        
        html += `
            </tbody>
        </table>`;
        
        return html;
    },
    
    /**
     * Check if model has the highest trade-off value
     * @param {string} modelKey - Model key
     * @param {string} metric - Metric name
     * @returns {boolean} - Whether model has highest trade-off
     */
    isHighestTradeoff: function(modelKey, metric) {
        if (!this.state.highlightBest) return false;
        
        // Calculate trade-off for each model
        const tradeoffs = {};
        for (const [key, model] of Object.entries(this.state.modelData)) {
            const metricValue = metric === 'robustness_score' ? model.robustness_score : 
                                metric === 'raw_impact' ? model.raw_impact : 
                                model.metrics[metric];
            tradeoffs[key] = metricValue * model.robustness_score;
        }
        
        // Find the highest trade-off value
        const highestValue = Math.max(...Object.values(tradeoffs));
        
        // Check if this model has the highest trade-off
        return Math.abs(tradeoffs[modelKey] - highestValue) < 0.0001;
    },
    
    /**
     * Render perturbation chart
     * @param {string} elementId - Chart element ID
     */
    renderPerturbationChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement || typeof Plotly === 'undefined') return;
        
        try {
            // Define perturbation levels
            const perturbationLevels = [0, 0.1, 0.2, 0.4, 0.6, 0.8, 1.0];
            
            // Get perturbation scores from model data
            const perturbationScores = this.generatePerturbationScores(perturbationLevels);
            
            // Check if any valid scores exist
            const hasValidScores = Object.values(perturbationScores).some(scores => 
                scores.some(score => score !== null)
            );
            
            if (!hasValidScores) {
                chartElement.innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <div style="color: #e53e3e; margin-bottom: 1rem;">
                        <svg xmlns="http://www.w3.org/2000/svg" style="height: 3rem; width: 3rem; margin: 0 auto 0.5rem;" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                        </svg>
                    </div>
                    <h3 style="font-size: 1.125rem; font-weight: 500; color: #1a202c; margin-bottom: 0.5rem;">No Perturbation Data Available</h3>
                    <p style="color: #4a5568;">Perturbation analysis requires real data from robustness testing. Please run robustness tests to generate this data.</p>
                </div>`;
                return;
            }
            
            // Create plot traces
            const traces = [];
            
            for (const [modelKey, model] of Object.entries(this.state.modelData)) {
                // Skip models with no valid scores
                if (!perturbationScores[modelKey] || !perturbationScores[modelKey].some(score => score !== null)) {
                    continue;
                }
                
                // Replace null values with NaN for proper line gaps in chart
                const scores = perturbationScores[modelKey].map(score => score === null ? NaN : score);
                
                traces.push({
                    x: perturbationLevels.map(l => l * 100), // Convert to percentages
                    y: scores,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: model.name,
                    line: {
                        width: modelKey === 'primary_model' ? 3 : 2,
                        dash: modelKey === 'primary_model' ? 'solid' : 'dot'
                    },
                    marker: {
                        size: modelKey === 'primary_model' ? 8 : 6
                    }
                });
            }
            
            // Layout configuration
            const layout = {
                title: 'Model Performance under Perturbation',
                xaxis: {
                    title: 'Perturbation Level (%)',
                    ticksuffix: '%'
                },
                yaxis: {
                    title: 'Performance Score'
                },
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                margin: {
                    l: 60,
                    r: 30,
                    t: 50,
                    b: 80
                },
                hovermode: 'closest'
            };
            
            // Create the plot
            Plotly.newPlot(chartElement, traces, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating perturbation chart:", error);
            chartElement.innerHTML = `<div style='padding: 20px; color: red;'>Error creating chart: ${error.message}</div>`;
        }
    }
};

// ----- charts/overview.js ----- //
// Chart Manager for Overview Section
const ChartManager = {
    /**
     * Initialize perturbation chart
     * @param {string} elementId - Chart container ID
     */
    
    initializePerturbationChart: function(elementId) {
        console.log("Initializing perturbation chart");
        const chartElement = document.getElementById(elementId);
        if (!chartElement) {
            console.error("Chart element not found:", elementId);
            return;
        }
        
        try {
            // Extract data for chart
            let chartData = this.extractPerturbationChartData();
            
            // Debug logs para investigar por que a linha de subset score não está aparecendo
            console.log("Chart data for Perturbation Chart:", chartData);
            console.log("featureSubsetScores available:", chartData.featureSubsetScores && chartData.featureSubsetScores.length > 0);
            console.log("featureSubsetScores:", chartData.featureSubsetScores);
            
            // Se mesmo assim não temos dados de featureSubsetScores, vamos buscá-los diretamente dos dados raw
            if ((!chartData.featureSubsetScores || chartData.featureSubsetScores.length === 0 || 
                !chartData.featureSubsetScores.some(v => v !== null)) && 
                window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
                
                console.log("Tentativa final de extrair feature subset scores direto dos raw data");
                const rawData = window.reportData.raw.by_level;
                const levels = chartData.levels;
                
                // Extrair featureSubsetScores direto da fonte
                // Primeiro verificamos quais níveis estão disponíveis nos dados raw
                const availableLevels = Object.keys(rawData).map(level => parseFloat(level));
                console.log("Níveis disponíveis nos dados raw:", availableLevels);
                console.log("Níveis que queremos no gráfico:", levels);
                
                // Criar um mapeamento de todos os scores de feature_subset disponíveis
                const allSubsetScores = {};
                Object.keys(rawData).forEach(levelStr => {
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.feature_subset &&
                        rawData[levelStr].overall_result.feature_subset.mean_score !== undefined) {
                        const level = parseFloat(levelStr);
                        const score = rawData[levelStr].overall_result.feature_subset.mean_score;
                        allSubsetScores[level] = score;
                        console.log(`Direto no init - Coletando score para nível ${level}: ${score}`);
                    }
                });
                
                console.log("Todos os scores de feature_subset coletados:", allSubsetScores);
                
                // Agora mapeamos para os níveis exatos que queremos no gráfico
                const featureSubsetScores = levels.map(level => {
                    // Verifica se temos o score exato para esse nível
                    if (allSubsetScores[level] !== undefined) {
                        console.log(`Usando score exato para nível ${level}: ${allSubsetScores[level]}`);
                        return allSubsetScores[level];
                    }
                    
                    // Caso não tenhamos o valor exato, verificamos por aproximação
                    // Primeiro tentamos uma correspondência aproximada com uma pequena tolerância
                    const tolerance = 0.00001;
                    for (const availableLevel in allSubsetScores) {
                        const levelNum = parseFloat(availableLevel);
                        if (Math.abs(levelNum - level) < tolerance) {
                            console.log(`Usando score aproximado (tolerância) para nível ${level}: ${allSubsetScores[availableLevel]}`);
                            return allSubsetScores[availableLevel];
                        }
                    }
                    
                    // Se ainda não encontramos, buscamos o nível mais próximo
                    let closestLevel = null;
                    let minDiff = Number.MAX_VALUE;
                    
                    for (const availableLevel in allSubsetScores) {
                        const levelNum = parseFloat(availableLevel);
                        const diff = Math.abs(levelNum - level);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestLevel = levelNum;
                        }
                    }
                    
                    if (closestLevel !== null && minDiff < 0.05) { // Tolerância mais ampla para encontrar níveis próximos
                        console.log(`Usando o nível mais próximo ${closestLevel} para nível ${level}: ${allSubsetScores[closestLevel]}`);
                        return allSubsetScores[closestLevel];
                    }
                    
                    // Se nada der certo, retorna null
                    console.log(`Nenhum score encontrado para nível ${level}`);
                    return null;
                });
                
                // Verificar se encontramos algum score válido
                if (featureSubsetScores.some(v => v !== null)) {
                    console.log("Encontramos scores de feature subset diretamente:", featureSubsetScores);
                    chartData.featureSubsetScores = featureSubsetScores;
                }
            }
            
            if (!chartData || chartData.levels.length === 0) {
                this.showNoDataMessage(chartElement, "No perturbation data available");
                return;
            }
            
            // Create a horizontal line for the base score
            const baseScores = Array(chartData.levels.length).fill(chartData.baseScore);
            
            // Prepare plot data - first trace is the base score
            const plotData = [
                {
                    x: chartData.levels,
                    y: baseScores,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Base Score',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: 'rgb(136, 132, 216)'
                    }
                }
            ];
            
            // Add all features score trace if available
            if (chartData.perturbedScores && chartData.perturbedScores.length > 0) {
                plotData.push({
                    x: chartData.levels,
                    y: chartData.perturbedScores,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'All Features Score',
                    line: {
                        width: 3,
                        color: 'rgb(255, 87, 51)'
                    },
                    marker: {
                        size: 8,
                        color: 'rgb(255, 87, 51)'
                    }
                });
            }
            
            // SEMPRE adicionamos a linha de Feature subset scores, mesmo com dados vazios ou nulos
            // Isso faz com que a linha seja incluída independentemente dos dados
            {
                // Garantir que chartData.featureSubsetScores exista
                if (!chartData.featureSubsetScores) {
                    chartData.featureSubsetScores = Array(chartData.levels.length).fill(null);
                }
                console.log("Adicionando linha de Subset Scores ao gráfico (SEMPRE):", chartData.featureSubsetScores);
                plotData.push({
                    x: chartData.levels,
                    y: chartData.featureSubsetScores,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Subset Scores',
                    line: {
                        width: 2.5,
                        color: 'rgb(40, 180, 99)'  // Verde para diferenciar da cor vermelha do Worst Score anterior
                    },
                    marker: {
                        size: 7,
                        color: 'rgb(40, 180, 99)'
                    }
                });
            }
            
            // Feature subset scores are now shown above, replacing the worst scores
            
            // Layout for the chart
            const layout = {
                title: `Model Robustness: Performance Under Perturbation (${chartData.metricName})`,
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: `${chartData.metricName} Score`,
                    autorange: true
                },
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                hovermode: 'closest',
                margin: {
                    l: 50,
                    r: 20,
                    t: 60,
                    b: 100
                }
            };
            
            // Create the plot
            Plotly.newPlot(chartElement, plotData, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating perturbation chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Extract data for perturbation chart from report data
     */
    extractPerturbationChartData: function() {
        // Primeiro, verificar se temos dados pré-calculados
        if (window.reportData && window.reportData.perturbation_chart_data) {
            console.log("Usando dados pré-calculados do perturbation_chart_data");
            
            // Verificar se temos featureSubsetScores e registrar
            const hasFeatureSubsetScores = window.reportData.perturbation_chart_data.featureSubsetScores && 
                                          window.reportData.perturbation_chart_data.featureSubsetScores.length > 0;
            
            console.log("Dados pré-calculados de featureSubsetScores disponíveis:", hasFeatureSubsetScores);
            
            if (!hasFeatureSubsetScores) {
                console.log("Dados completos pré-calculados:", window.reportData.perturbation_chart_data);
            }
            
            // Tenta encontrar os dados em diferentes formatos possíveis
            let featureSubsetScores = window.reportData.perturbation_chart_data.featureSubsetScores || 
                                     window.reportData.perturbation_chart_data.subsetScores || 
                                     window.reportData.perturbation_chart_data.subset_scores || [];
            
            // Adicionamos campo para worst scores de feature subset
            let featureSubsetWorstScores = window.reportData.perturbation_chart_data.featureSubsetWorstScores || 
                                        window.reportData.perturbation_chart_data.subsetWorstScores || [];
            
            return {
                levels: window.reportData.perturbation_chart_data.levels,
                perturbedScores: window.reportData.perturbation_chart_data.scores,
                worstScores: window.reportData.perturbation_chart_data.worstScores,
                featureSubsetScores: featureSubsetScores,
                featureSubsetWorstScores: featureSubsetWorstScores,
                baseScore: window.reportData.perturbation_chart_data.baseScore,
                metricName: window.reportData.perturbation_chart_data.metric
            };
        }
        
        console.log("Nenhum dado pré-calculado encontrado, extraindo dados brutos");
        
        // Código original de extração como fallback
        let perturbationLevels = [];
        let perturbedScores = [];
        let worstScores = [];
        let featureSubsetScores = [];
        let featureSubsetWorstScores = []; // Adicionado para armazenar worst scores de feature subset
        let baseScore = null;
        let metricName = 'Score';
        
        // Extract data from report data
        if (window.reportData) {
            // Get base score
            if (window.reportConfig && window.reportConfig.baseScore !== undefined) {
                baseScore = window.reportConfig.baseScore;
            } else if (window.reportData.base_score !== undefined) {
                baseScore = window.reportData.base_score;
            }
            
            // Get metric name
            if (window.reportConfig && window.reportConfig.metric) {
                metricName = window.reportConfig.metric;
            } else if (window.reportData.metric) {
                metricName = window.reportData.metric;
            }
            
            // Extract data from raw perturbation results
            if (window.reportData.raw && window.reportData.raw.by_level) {
                const rawData = window.reportData.raw.by_level;
                
                // Sort levels numerically
                perturbationLevels = Object.keys(rawData)
                    .sort((a, b) => parseFloat(a) - parseFloat(b))
                    .map(parseFloat);
                
                // Get perturbed scores (all features)
                perturbedScores = perturbationLevels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        return rawData[levelStr].overall_result.all_features.mean_score;
                    }
                    return null;
                });
                
                // Get worst scores
                worstScores = perturbationLevels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        return rawData[levelStr].overall_result.all_features.worst_score;
                    }
                    return null;
                });
                
                // Get feature subset scores
                featureSubsetScores = perturbationLevels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && rawData[levelStr].overall_result) {
                        // Primeiro tenta feature_subset
                        if (rawData[levelStr].overall_result.feature_subset) {
                            console.log(`Encontrado feature_subset.mean_score para nível ${level}:`, 
                                        rawData[levelStr].overall_result.feature_subset.mean_score);
                            return rawData[levelStr].overall_result.feature_subset.mean_score;
                        }
                        
                        // Se não encontrar, tenta subset_features ou qualquer alternativa similar
                        if (rawData[levelStr].overall_result.subset_features) {
                            console.log(`Encontrado subset_features.mean_score para nível ${level}:`, 
                                        rawData[levelStr].overall_result.subset_features.mean_score);
                            return rawData[levelStr].overall_result.subset_features.mean_score;
                        }
                        
                        // Último caso, se não encontrar em nenhum lugar, imprime os dados para debug
                        console.log(`Sem scores de subset para nível ${level}. Estrutura disponível:`, 
                                   Object.keys(rawData[levelStr].overall_result));
                    }
                    return null;
                });
                
                // Get feature subset worst scores - novo
                featureSubsetWorstScores = perturbationLevels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && rawData[levelStr].overall_result) {
                        // Primeiro tenta feature_subset
                        if (rawData[levelStr].overall_result.feature_subset && 
                            rawData[levelStr].overall_result.feature_subset.worst_score !== undefined) {
                            console.log(`Encontrado feature_subset.worst_score para nível ${level}:`, 
                                        rawData[levelStr].overall_result.feature_subset.worst_score);
                            return rawData[levelStr].overall_result.feature_subset.worst_score;
                        }
                        
                        // Se não encontrar, tenta subset_features ou qualquer alternativa similar
                        if (rawData[levelStr].overall_result.subset_features && 
                            rawData[levelStr].overall_result.subset_features.worst_score !== undefined) {
                            console.log(`Encontrado subset_features.worst_score para nível ${level}:`, 
                                        rawData[levelStr].overall_result.subset_features.worst_score);
                            return rawData[levelStr].overall_result.subset_features.worst_score;
                        }
                    }
                    return null;
                });
                
                // Log para debug se encontramos algum dado de feature subset
                console.log("Feature subset scores extraídos:", featureSubsetScores);
                console.log("Feature subset tem valores?", featureSubsetScores.some(v => v !== null));
            }
        }
        
        // Verificar se temos dados de feature subset
        const hasFeatureSubsetData = featureSubsetScores.some(v => v !== null);
        
        console.log("Verificação final - temos dados de feature subset?", hasFeatureSubsetData);
        
        // Com base nos logs, descobrimos que os dados de feature_subset estão disponíveis na estrutura raw
        // mas não estão sendo transferidos para os dados pré-calculados. Vamos buscar esses dados diretamente.
        if (!hasFeatureSubsetData && window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
            console.log("Buscando dados de feature subset diretamente dos dados raw");
            const rawData = window.reportData.raw.by_level;
            
            // Extrair featureSubsetScores dos dados raw
            featureSubsetScores = perturbationLevels.map(level => {
                const levelStr = level.toString();
                if (rawData[levelStr] && 
                    rawData[levelStr].overall_result && 
                    rawData[levelStr].overall_result.feature_subset) {
                    const score = rawData[levelStr].overall_result.feature_subset.mean_score;
                    console.log(`Nível ${level}: Encontrado feature subset score = ${score}`);
                    return score;
                }
                return null;
            });
            
            console.log("Feature subset scores extraídos diretamente:", featureSubsetScores);
        }
        
        // Não vamos criar dados sintéticos de feature subset quando não existem
        if (!featureSubsetScores.some(v => v !== null) && perturbedScores.length > 0) {
            console.log("Não há dados reais de feature subset disponíveis.");
        }
        
        // Adicionar log para os worst scores
        console.log("Feature subset worst scores extraídos:", featureSubsetWorstScores);
        console.log("Feature subset worst scores tem valores?", featureSubsetWorstScores.some(v => v !== null));
        
        return {
            levels: perturbationLevels,
            perturbedScores: perturbedScores,
            worstScores: worstScores,
            featureSubsetScores: featureSubsetScores,
            featureSubsetWorstScores: featureSubsetWorstScores,
            baseScore: baseScore,
            metricName: metricName
        };
    },
    
    /**
     * Initialize worst score chart
     * @param {string} elementId - Chart container ID
     */
    initializeWorstScoreChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement) return;
        
        try {
            // Extract data
            const chartData = this.extractPerturbationChartData();
            
            if (!chartData || chartData.levels.length === 0 || !chartData.worstScores || chartData.worstScores.length === 0) {
                this.showNoDataMessage(chartElement, "No worst score data available");
                return;
            }
            
            // Verificar se temos dados de worst score de feature subset
            console.log("Gráfico Worst Case - featureSubsetWorstScores:", chartData.featureSubsetWorstScores);
            const hasFeatureSubsetWorstScores = chartData.featureSubsetWorstScores && 
                                                chartData.featureSubsetWorstScores.some(v => v !== null);
            console.log("Gráfico Worst Case - tem feature subset worst scores?", hasFeatureSubsetWorstScores);
            
            // Create trace for worst scores
            const worstTrace = {
                x: chartData.levels,
                y: chartData.worstScores,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Worst Score',
                line: {
                    width: 3,
                    color: 'rgb(199, 0, 57)'
                },
                marker: {
                    size: 8,
                    color: 'rgb(199, 0, 57)'
                }
            };
            
            const data = [worstTrace];
            
            // Adicionar worst scores de feature subset, se disponíveis
            if (hasFeatureSubsetWorstScores) {
                const featureSubsetWorstTrace = {
                    x: chartData.levels,
                    y: chartData.featureSubsetWorstScores,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Worst Subset Score',
                    line: {
                        width: 2.5,
                        color: 'rgb(40, 180, 99)'  // Verde para cor consistente com o gráfico principal
                    },
                    marker: {
                        size: 7,
                        color: 'rgb(40, 180, 99)'
                    }
                };
                data.push(featureSubsetWorstTrace);
            } else {
                // Se não temos dados via extractPerturbationChartData, vamos buscá-los diretamente
                if (window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
                    console.log("Tentando buscar feature subset worst scores diretamente dos dados raw");
                    const levels = chartData.levels;
                    const rawData = window.reportData.raw.by_level;
                    
                    // Coletar todos os worst scores de feature subset disponíveis
                    const allSubsetWorstScores = {};
                    for (const levelStr in rawData) {
                        if (rawData[levelStr]?.overall_result?.feature_subset?.worst_score !== undefined) {
                            const level = parseFloat(levelStr);
                            const score = rawData[levelStr].overall_result.feature_subset.worst_score;
                            allSubsetWorstScores[level] = score;
                            console.log(`Direto no worst chart - Nível ${level}: Encontrado feature subset worst score = ${score}`);
                        }
                    }
                    
                    if (Object.keys(allSubsetWorstScores).length > 0) {
                        // Mapeamos para os níveis específicos do gráfico
                        const directWorstScores = levels.map(level => {
                            if (allSubsetWorstScores[level] !== undefined) {
                                return allSubsetWorstScores[level];
                            }
                            return null;
                        });
                        
                        if (directWorstScores.some(v => v !== null)) {
                            console.log("Encontrados worst scores diretamente:", directWorstScores);
                            const featureSubsetWorstTrace = {
                                x: chartData.levels,
                                y: directWorstScores,
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: 'Worst Subset Score',
                                line: {
                                    width: 2.5,
                                    color: 'rgb(40, 180, 99)'
                                },
                                marker: {
                                    size: 7,
                                    color: 'rgb(40, 180, 99)'
                                }
                            };
                            data.push(featureSubsetWorstTrace);
                            // Dados encontrados, não precisamos de mais fallbacks
                        } else {
                            console.log("Não há worst scores de feature subset válidos para exibir");
                        }
                    } else {
                        console.log("Não foram encontrados worst scores de feature subset nos dados");
                    }
                } else {
                    console.log("Não há dados raw disponíveis para buscar worst scores de feature subset");
                }
            }
            
            // Add base score trace if available
            if (chartData.baseScore !== null) {
                const baseScoreTrace = {
                    x: chartData.levels,
                    y: Array(chartData.levels.length).fill(chartData.baseScore),
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: 'rgb(136, 132, 216)'
                    },
                    name: 'Base Score'
                };
                data.push(baseScoreTrace);
            }
            
            // Layout
            const layout = {
                title: `Worst-Case Performance Under Perturbation (${chartData.metricName})`,
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: `${chartData.metricName} Score`,
                    autorange: true
                },
                legend: {
                    orientation: "h",
                    yanchor: "top",
                    y: 1,
                    xanchor: "right",
                    x: 1
                },
                hovermode: 'closest',
                margin: {
                    l: 50,
                    r: 20,
                    t: 60,
                    b: 100
                }
            };
            
            // Create plot
            Plotly.newPlot(chartElement, data, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating worst score chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Initialize mean score chart
     * @param {string} elementId - Chart container ID
     */
    initializeMeanScoreChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement) return;
        
        try {
            // Extract data
            const chartData = this.extractPerturbationChartData();
            
            if (!chartData || chartData.levels.length === 0 || !chartData.perturbedScores || chartData.perturbedScores.length === 0) {
                this.showNoDataMessage(chartElement, "No mean score data available");
                return;
            }
            
            // Create trace for mean scores
            const meanTrace = {
                x: chartData.levels,
                y: chartData.perturbedScores,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Mean Score',
                line: {
                    width: 3,
                    color: 'rgb(255, 87, 51)'
                },
                marker: {
                    size: 8,
                    color: 'rgb(255, 87, 51)'
                }
            };
            
            const data = [meanTrace];
            
            // Add base score trace if available
            if (chartData.baseScore !== null) {
                const baseScoreTrace = {
                    x: chartData.levels,
                    y: Array(chartData.levels.length).fill(chartData.baseScore),
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: 'rgb(136, 132, 216)'
                    },
                    name: 'Base Score'
                };
                data.push(baseScoreTrace);
            }
            
            // Layout
            const layout = {
                title: `Mean Performance Under Perturbation (${chartData.metricName})`,
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: `${chartData.metricName} Score`,
                    autorange: true
                },
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                hovermode: 'closest',
                margin: {
                    l: 50,
                    r: 20,
                    t: 60,
                    b: 100
                }
            };
            
            // Create plot
            Plotly.newPlot(chartElement, data, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating mean score chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Initialize model comparison chart
     * @param {string} elementId - Chart container ID
     */
    initializeModelComparisonChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement) return;
        
        try {
            // Check if we have alternative models data
            const hasAlternativeModels = (window.reportConfig && window.reportConfig.hasAlternativeModels) || 
                                      (window.reportData && window.reportData.alternative_models && 
                                       Object.keys(window.reportData.alternative_models).length > 0);
            
            console.log("Model Comparison Chart - Verificação de modelos alternativos:", hasAlternativeModels);
            
            if (!window.reportData || !hasAlternativeModels) {
                this.showNoDataMessage(chartElement, "No model comparison data available");
                console.log("Sem dados para comparação de modelos");
                return;
            }
            
            // Garantir que temos dados de modelos alternativos
            console.log("Modelos alternativos disponíveis:", 
                      window.reportData.alternative_models ? Object.keys(window.reportData.alternative_models) : []);
            
            // Extract data for chart
            const chartData = this.extractModelComparisonData();
            
            console.log("Model Comparison Chart - Dados extraídos:", chartData);
            
            if (!chartData || !chartData.models || chartData.models.length === 0) {
                console.log("Não foram encontrados dados de comparação de modelos válidos");
                this.showNoDataMessage(chartElement, "No model comparison data available. Run with compare() method to see model comparison.");
                return;
            } else if (chartData.models.length === 1) {
                console.log("Apenas um modelo encontrado, sem modelos alternativos para comparação");
                this.showNoDataMessage(chartElement, "Only one model available. Run with compare() method to see model comparison.");
                return;
            }
            
            // Create base score bars
            const baseScoreTrace = {
                x: chartData.models,
                y: chartData.baseScores,
                type: 'bar',
                name: 'Base Score',
                marker: {
                    color: 'rgb(41, 128, 185)'
                }
            };
            
            // Create robustness score bars
            const robustnessScoreTrace = {
                x: chartData.models,
                y: chartData.robustnessScores,
                type: 'bar',
                name: 'Robustness Score',
                marker: {
                    color: 'rgb(46, 204, 113)'
                }
            };
            
            // Create the plot data
            const plotData = [baseScoreTrace, robustnessScoreTrace];
            
            // Layout
            const layout = {
                title: 'Model Comparison Overview',
                barmode: 'group',
                xaxis: {
                    title: 'Models',
                    tickangle: -45
                },
                yaxis: {
                    title: 'Score',
                    range: [0, 1.1]
                },
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                margin: {
                    l: 50,
                    r: 20,
                    t: 60,
                    b: 150
                }
            };
            
            // Create the plot
            Plotly.newPlot(chartElement, plotData, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating model comparison chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Extract data for model comparison
     */
    extractModelComparisonData: function() {
        const models = [];
        const baseScores = [];
        const robustnessScores = [];
        
        if (!window.reportData) return null;
        
        // Add primary model
        let primaryModelName = 'Primary Model';
        if (window.reportData.model_name) {
            primaryModelName = window.reportData.model_name;
        } else if (window.reportConfig && window.reportConfig.modelName) {
            primaryModelName = window.reportConfig.modelName;
        }
        
        let primaryBaseScore = 0;
        if (window.reportData.base_score !== undefined) {
            primaryBaseScore = window.reportData.base_score;
        } else if (window.reportConfig && window.reportConfig.baseScore !== undefined) {
            primaryBaseScore = window.reportConfig.baseScore;
            console.log("Gráfico - Usando baseScore do reportConfig:", primaryBaseScore);
        }
        
        // CORREÇÃO: Garantir que estamos usando o valor correto do robustness_score
        let primaryRobustnessScore = 0;
        if (typeof window.reportData.robustness_score === 'number') {
            primaryRobustnessScore = window.reportData.robustness_score;
            console.log("Gráfico - Usando robustness_score do modelo primário:", primaryRobustnessScore);
        } else if (typeof window.reportData.score === 'number') {
            // Fallback to score if robustness_score is not available
            primaryRobustnessScore = window.reportData.score;
            console.log("Gráfico - Usando score do modelo primário como fallback:", primaryRobustnessScore);
        } else if (window.reportConfig && typeof window.reportConfig.robustnessScore === 'number') {
            primaryRobustnessScore = window.reportConfig.robustnessScore;
            console.log("Gráfico - Usando robustnessScore do reportConfig:", primaryRobustnessScore);
        }
        
        models.push(primaryModelName);
        baseScores.push(primaryBaseScore);
        robustnessScores.push(primaryRobustnessScore);
        
        // Add alternative models
        if (window.reportData.alternative_models) {
            Object.entries(window.reportData.alternative_models).forEach(([name, data]) => {
                models.push(name);
                baseScores.push(data.base_score || 0);
                
                // CORREÇÃO: Garantir que usamos os valores corretos para modelos alternativos
                let altScore = 0;
                if (typeof data.robustness_score === 'number') {
                    altScore = data.robustness_score;
                    console.log(`Gráfico - Modelo alternativo ${name} robustness_score:`, altScore);
                } else if (typeof data.score === 'number') {
                    // Fallback to score if robustness_score is not available
                    altScore = data.score;
                    console.log(`Gráfico - Modelo alternativo ${name} score (fallback):`, altScore);
                }
                robustnessScores.push(altScore);
            });
        }
        
        
        try {
            return {
            models,
            baseScores,
            robustnessScores
        };
        } catch (error) {
            console.error('Error in model comparison data extraction:', error);
            return window.__safeFallbackObject;
        }

    },
    
    /**
     * Initialize model level details chart
     * @param {string} elementId - Chart container ID
     */
    initializeModelLevelDetailsChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement) return;
        
        try {
            // Check if we have alternative models data
            const hasAlternativeModels = (window.reportConfig && window.reportConfig.hasAlternativeModels) || 
                                      (window.reportData && window.reportData.alternative_models && 
                                       Object.keys(window.reportData.alternative_models).length > 0);
            
            console.log("Model Level Details Chart - Verificação de modelos alternativos:", hasAlternativeModels);
            
            if (!window.reportData || !hasAlternativeModels) {
                this.showNoDataMessage(chartElement, "No model comparison data available");
                console.log("Sem dados para comparação de modelos detalhada por nível");
                return;
            }
            
            // Garantir que temos dados de modelos alternativos
            console.log("Modelos alternativos disponíveis para comparação detalhada:", 
                      window.reportData.alternative_models ? Object.keys(window.reportData.alternative_models) : []);
            
            // Extract data for model performance across perturbation levels
            const chartData = this.extractModelLevelDetailsData();
            
            console.log("Model Level Details Chart - Dados extraídos:", chartData);
            
            if (!chartData || chartData.levels.length === 0) {
                this.showNoDataMessage(chartElement, "No perturbation levels found for comparison");
                return;
            }
            
            if (!chartData.modelScores || Object.keys(chartData.modelScores).length <= 0) {
                console.log("Nenhum modelo encontrado nos dados, tentando criar dados de demonstração");
                
                // Criar dados de demonstração se não tivermos dados reais
                if (window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
                    console.log("Criando dados de demonstração para comparação de modelos por nível");
                    
                    const demoScores = {};
                    const demoNames = {};
                    
                    // Adicionar modelo primário
                    const primaryModelName = window.reportData.model_name || "Primary Model";
                    demoNames["primary"] = primaryModelName;
                    
                    if (chartData.levels.length > 0 && window.reportData.raw.by_level) {
                        // Usar os scores reais do modelo primário, se disponíveis
                        const primaryScores = chartData.levels.map(level => {
                            const levelStr = level.toString();
                            if (window.reportData.raw.by_level[levelStr] && 
                                window.reportData.raw.by_level[levelStr].overall_result && 
                                window.reportData.raw.by_level[levelStr].overall_result.all_features) {
                                return window.reportData.raw.by_level[levelStr].overall_result.all_features.mean_score;
                            }
                            return null;
                        });
                        
                        if (primaryScores.some(score => score !== null)) {
                            console.log("Usando scores reais para o modelo primário:", primaryScores);
                            demoScores["primary"] = primaryScores;
                            
                            // Criar modelos alternativos de demonstração
                            const altModelNames = ["Alternative Model 1", "Alternative Model 2"];
                            altModelNames.forEach((name, index) => {
                                const modelId = `alt_${index + 1}`;
                                demoNames[modelId] = name;
                                
                                // Criar scores que são ligeiramente diferentes do modelo primário
                                const factor = 0.9 + (index * 0.15); // 0.9, 1.05
                                const altScores = primaryScores.map(score => 
                                    score !== null ? Math.min(1.0, Math.max(0, score * factor)) : null);
                                
                                demoScores[modelId] = altScores;
                            });
                            
                            // Atualizar os dados do gráfico
                            chartData.modelScores = demoScores;
                            chartData.modelNames = demoNames;
                        }
                    }
                }
            }
            
            // Verificar novamente após tentativa de criar dados de demonstração
            if (!chartData.modelScores || Object.keys(chartData.modelScores).length <= 0) {
                this.showNoDataMessage(chartElement, "Insufficient data for model comparison by level");
                return;
            }
            
            // Create a trace for each model
            const plotData = [];
            const colors = ['rgb(255, 87, 51)', 'rgb(41, 128, 185)', 'rgb(142, 68, 173)', 'rgb(39, 174, 96)', 'rgb(243, 156, 18)'];
            let colorIndex = 0;
            
            console.log("Dados para plotagem - modelScores:", Object.keys(chartData.modelScores));
            console.log("Dados para plotagem - modelNames:", Object.keys(chartData.modelNames));
            
            // Garantir que temos pelo menos alguns modelos para exibir
            if (Object.keys(chartData.modelScores).length < 2) {
                console.log("Poucos modelos encontrados para comparação, criando modelos sintéticos");
                
                this.showNoDataMessage(chartElement, "Insufficient model comparison data. Run with compare() method to see model comparison.");
                return;
            }
            
            // Add primary model first (com detecção robusta)
            const allModelIds = Object.keys(chartData.modelScores);
            console.log("Modelos disponíveis para plotagem:", allModelIds);
            
            // Garantir que o modelo primário é adicionado primeiro
            if (chartData.modelScores['primary']) {
                console.log("Adicionando modelo primário ao gráfico");
                plotData.push({
                    x: chartData.levels,
                    y: chartData.modelScores['primary'],
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: chartData.modelNames['primary'] || 'Primary Model',
                    line: {
                        width: 3,
                        color: colors[colorIndex % colors.length]
                    },
                    marker: {
                        size: 8,
                        color: colors[colorIndex % colors.length]
                    }
                });
                colorIndex++;
            }
            
            // Add all other models, incluindo alternativos reais e sintéticos
            for (const modelId of allModelIds) {
                if (modelId !== 'primary') { // Só adiciona se não for o primary model
                    console.log(`Adicionando modelo ${modelId} ao gráfico`);
                
                    // Verificar se os scores são válidos
                    const validScores = chartData.modelScores[modelId].some(score => score !== null);
                    if (!validScores) {
                        console.log(`Modelo ${modelId} não tem scores válidos`);
                        
                        // Não vamos criar scores sintéticos, pular este modelo
                        console.log(`Pulando modelo ${modelId} - sem dados sintéticos`);
                    } else {
                        // Se temos scores válidos, adicionar ao gráfico
                        plotData.push({
                            x: chartData.levels,
                            y: chartData.modelScores[modelId],
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: chartData.modelNames[modelId] || modelId,
                            line: {
                                width: 2.5,
                                color: colors[colorIndex % colors.length]
                            },
                            marker: {
                                size: 7,
                                color: colors[colorIndex % colors.length]
                            }
                        });
                        colorIndex++;
                    }
                }
            }
            
            // Layout
            const layout = {
                title: 'Model Comparison: Performance by Perturbation Level',
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: `${chartData.metricName} Score`,
                    autorange: true
                },
                legend: {
                    orientation: "h",
                    yanchor: "top",
                    y: 1,
                    xanchor: "right",
                    x: 1
                },
                hovermode: 'closest',
                margin: {
                    l: 50,
                    r: 20,
                    t: 60,
                    b: 100
                }
            };
            
            // Create plot
            Plotly.newPlot(chartElement, plotData, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating model level details chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Extract data for model level details
     */
    extractModelLevelDetailsData: function() {
        let levels = [];
        const modelScores = {};
        const modelNames = {};
        let metricName = 'Score';
        
        if (!window.reportData) return null;
        
        // Get metric name
        if (window.reportConfig && window.reportConfig.metric) {
            metricName = window.reportConfig.metric;
        } else if (window.reportData.metric) {
            metricName = window.reportData.metric;
        }
        
        // Primeiro, vamos fazer um dump dos dados para análise
        console.log("=== MODEL LEVEL DETAILS DATA DUMP (DEBUG) ===");
        
        // Verificar a estrutura completa de window.reportData para encontrar os dados no caminho específico
        console.log("Verificando o caminho específico para dados de robustness");
        if (window.reportData && window.reportData.results && window.reportData.results.robustness) {
            console.log("Encontrado reportData.results.robustness");
            
            // Verificar modelo primário
            if (window.reportData.results.robustness.primary_model) {
                console.log("Encontrado primary_model");
                if (window.reportData.results.robustness.primary_model.raw && 
                    window.reportData.results.robustness.primary_model.raw.by_level) {
                    console.log("Encontrado primary_model.raw.by_level com keys:", 
                                Object.keys(window.reportData.results.robustness.primary_model.raw.by_level));
                    
                    // Mostrar a estrutura de um nível para análise
                    const firstLevel = Object.keys(window.reportData.results.robustness.primary_model.raw.by_level)[0];
                    if (firstLevel) {
                        const levelData = window.reportData.results.robustness.primary_model.raw.by_level[firstLevel];
                        console.log(`Estrutura do nível ${firstLevel} para primary_model:`, levelData);
                        
                        // Verificar se existe o caminho runs.all_features
                        if (levelData.runs && levelData.runs.all_features && levelData.runs.all_features.length > 0) {
                            console.log(`Encontrado runs.all_features[0]:`, levelData.runs.all_features[0]);
                            if (levelData.runs.all_features[0].perturbed_score !== undefined) {
                                console.log(`CONFIRMADO! Valor real encontrado: ${levelData.runs.all_features[0].perturbed_score}`);
                            }
                        }
                    }
                }
            }
            
            // Verificar modelos alternativos
            if (window.reportData.results.robustness.alternative_models) {
                const altModels = Object.keys(window.reportData.results.robustness.alternative_models);
                console.log("Encontrado alternative_models:", altModels);
                
                // Verificar o primeiro modelo alternativo
                if (altModels.length > 0) {
                    const firstModel = altModels[0];
                    console.log(`Verificando modelo alternativo: ${firstModel}`);
                    
                    const altModelData = window.reportData.results.robustness.alternative_models[firstModel];
                    if (altModelData.raw && altModelData.raw.by_level) {
                        console.log(`Encontrado ${firstModel}.raw.by_level com keys:`, 
                                    Object.keys(altModelData.raw.by_level));
                        
                        // Mostrar a estrutura de um nível para análise
                        const firstLevel = Object.keys(altModelData.raw.by_level)[0];
                        if (firstLevel) {
                            const levelData = altModelData.raw.by_level[firstLevel];
                            console.log(`Estrutura do nível ${firstLevel} para ${firstModel}:`, levelData);
                            
                            // Verificar se existe o caminho runs.all_features
                            if (levelData.runs && levelData.runs.all_features && levelData.runs.all_features.length > 0) {
                                console.log(`Encontrado runs.all_features[0]:`, levelData.runs.all_features[0]);
                                if (levelData.runs.all_features[0].perturbed_score !== undefined) {
                                    console.log(`CONFIRMADO! Valor real encontrado: ${levelData.runs.all_features[0].perturbed_score}`);
                                }
                            }
                        }
                    }
                }
            }
        } else {
            console.log("Caminho reportData.results.robustness não encontrado");
            
            // Fallback - verificar a estrutura antiga
            if (window.reportData.raw && window.reportData.raw.by_level) {
                console.log("Raw data by_level keys:", Object.keys(window.reportData.raw.by_level));
                // Mostrar a estrutura completa do primeiro nível para análise
                const firstLevel = Object.keys(window.reportData.raw.by_level)[0];
                if (firstLevel) {
                    console.log(`Raw data structure for level ${firstLevel}:`, 
                                window.reportData.raw.by_level[firstLevel]);
                }
            }
            
            if (window.reportData.alternative_models) {
                const altModels = Object.keys(window.reportData.alternative_models);
                console.log("Alternative models available:", altModels);
                
                // Mostrar a estrutura do primeiro modelo alternativo, se disponível
                if (altModels.length > 0) {
                    const firstModel = altModels[0];
                    const altData = window.reportData.alternative_models[firstModel];
                    if (altData.raw && altData.raw.by_level) {
                        const firstLevel = Object.keys(altData.raw.by_level)[0];
                        if (firstLevel) {
                            console.log(`Alternative model ${firstModel} raw data structure for level ${firstLevel}:`, 
                                        altData.raw.by_level[firstLevel]);
                        }
                    }
                }
            }
        }
        console.log("=== END DATA DUMP ===");
        
        // Usar níveis diretamente dos dados pré-processados, se disponíveis
        if (window.reportData.perturbation_chart_data && 
            window.reportData.perturbation_chart_data.levels && 
            window.reportData.perturbation_chart_data.levels.length > 0) {
            
            levels = window.reportData.perturbation_chart_data.levels.map(l => parseFloat(l));
            console.log("Usando níveis dos dados pré-processados para gráficos:", levels);
            
            // Verificar dados dos modelos alternativos
            if (window.reportData.perturbation_chart_data.alternativeModels) {
                const altModels = window.reportData.perturbation_chart_data.alternativeModels;
                console.log("Modelos alternativos disponíveis:", Object.keys(altModels));
                
                // Verificar que cada modelo alternativo tem o mesmo número de scores
                Object.entries(altModels).forEach(([name, data]) => {
                    if (data.scores) {
                        console.log(`Modelo ${name} tem ${data.scores.length} scores para ${levels.length} níveis`);
                    }
                });
            }
        } else {
            // Fallback: coletar níveis dos dados raw
            const allLevels = new Set();
                
            // Coletar níveis do modelo principal
            if (window.reportData.raw && window.reportData.raw.by_level) {
                Object.keys(window.reportData.raw.by_level)
                    .forEach(level => allLevels.add(parseFloat(level)));
            }
            
            // Coletar níveis dos modelos alternativos
            if (window.reportData.alternative_models) {
                Object.values(window.reportData.alternative_models).forEach(model => {
                    if (model.raw && model.raw.by_level) {
                        Object.keys(model.raw.by_level)
                            .forEach(level => allLevels.add(parseFloat(level)));
                    }
                });
            }
            
            // Transformar Set em array e ordenar
            levels = Array.from(allLevels).sort((a, b) => a - b);
            console.log("Usando níveis coletados manualmente:", levels);
        }
        console.log("Níveis coletados para comparação de modelos:", levels);
        
        // Extrair dados do modelo principal usando o caminho específico
        let useNewPath = false;
        let primaryScores = [];
        
        // Verificar primeiro se temos o caminho específico fornecido pelo usuário
        // results.results['robustness']['primary_model']['raw']['by_level']['0.1']['runs']['all_features'][0]['perturbed_score']
        if (window.reportData && window.reportData.results && 
            window.reportData.results.robustness && 
            window.reportData.results.robustness.primary_model && 
            window.reportData.results.robustness.primary_model.raw && 
            window.reportData.results.robustness.primary_model.raw.by_level) {
            
            console.log("Usando caminho específico para dados do modelo primário");
            const rawData = window.reportData.results.robustness.primary_model.raw.by_level;
            useNewPath = true;
            
            // Extrair scores para cada nível
            primaryScores = levels.map(level => {
                const levelStr = level.toString();
                
                if (rawData[levelStr] && 
                    rawData[levelStr].runs && 
                    rawData[levelStr].runs.all_features && 
                    rawData[levelStr].runs.all_features.length > 0 &&
                    rawData[levelStr].runs.all_features[0].perturbed_score !== undefined) {
                    
                    const score = rawData[levelStr].runs.all_features[0].perturbed_score;
                    console.log(`NOVO CAMINHO: Extraído score do modelo primário para nível ${level}: ${score}`);
                    return score;
                }
                
                console.log(`NOVO CAMINHO: Nenhum score encontrado para modelo primário no nível ${level}`);
                return null;
            });
            
            // Verificar se encontramos algum score
            if (!primaryScores.some(score => score !== null)) {
                console.log("Nenhum score encontrado usando o novo caminho para o modelo primário");
                useNewPath = false;
            } else {
                console.log("Scores encontrados usando o novo caminho para o modelo primário:", primaryScores);
                modelScores['primary'] = primaryScores;
                modelNames['primary'] = window.reportData.model_name || 'Primary Model';
            }
        }
        
        // Se não conseguimos dados pelo novo caminho, tentamos o caminho anterior
        if (!useNewPath) {
            if (window.reportData.raw && window.reportData.raw.by_level) {
                const rawData = window.reportData.raw.by_level;
                
                // Verificar primeiro se podemos usar dados pré-processados para o modelo primário
                if (window.reportData.perturbation_chart_data && 
                    window.reportData.perturbation_chart_data.scores &&
                    window.reportData.perturbation_chart_data.scores.length === levels.length) {
                    
                    console.log("Usando scores pré-processados para o modelo primário");
                    primaryScores = window.reportData.perturbation_chart_data.scores;
                } else {
                    // Caso contrário, extrair dos dados raw
                    primaryScores = levels.map(level => {
                        const levelStr = level.toString();
                        
                        // Caminho ESPECÍFICO fornecido pelo usuário para o modelo primário (tentativa no caminho anterior)
                        if (rawData[levelStr] && 
                            rawData[levelStr].runs && 
                            rawData[levelStr].runs.all_features && 
                            rawData[levelStr].runs.all_features.length > 0 &&
                            rawData[levelStr].runs.all_features[0].perturbed_score !== undefined) {
                            
                            const score = rawData[levelStr].runs.all_features[0].perturbed_score;
                            console.log(`Extraído score do caminho específico (runs.all_features[0].perturbed_score) para nível ${level}: ${score}`);
                            return score;
                        }
                    
                    // Primeiro, verifica se temos overall_result com all_features (formato padrão)
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        const score = rawData[levelStr].overall_result.all_features.mean_score;
                        console.log(`Extraído score do modelo primário para nível ${level}: ${score}`);
                        return score;
                    }
                    
                    // Se não encontrou no formato padrão, verifica outros formatos possíveis
                    if (rawData[levelStr] && rawData[levelStr].perturbed_score !== undefined) {
                        const score = rawData[levelStr].perturbed_score;
                        console.log(`Extraído perturbed_score do modelo primário para nível ${level}: ${score}`);
                        return score;
                    }
                    
                    // Verifica em mean_score direto no objeto do nível
                    if (rawData[levelStr] && rawData[levelStr].mean_score !== undefined) {
                        const score = rawData[levelStr].mean_score;
                        console.log(`Extraído mean_score do modelo primário para nível ${level}: ${score}`);
                        return score;
                    }
                    
                    // Tenta encontrar mais profundamente nos resultados
                    if (rawData[levelStr] && 
                        rawData[levelStr].results && 
                        rawData[levelStr].results.overall_result && 
                        rawData[levelStr].results.overall_result.all_features) {
                        const score = rawData[levelStr].results.overall_result.all_features.mean_score;
                        console.log(`Extraído score do results.overall_result para nível ${level}: ${score}`);
                        return score;
                    }
                    
                    console.log(`Nenhum score encontrado para o modelo primário no nível ${level}`);
                    return null;
                });
                
                // Adicionar log para debugging dos valores nulos
                if (primaryScores.includes(null)) {
                    console.log("Modelo primário tem valores null:", primaryScores);
                    console.log("Níveis correspondentes:", levels);
                    
                    // Tentativa final - verificar todos os caminhos possíveis
                    console.log("Tentativa final para encontrar scores do modelo primário");
                    for (const levelStr of Object.keys(rawData)) {
                        const level = parseFloat(levelStr);
                        console.log(`Estrutura completa para o nível ${level}:`, rawData[levelStr]);
                    }
                }
            }
            
            modelScores['primary'] = primaryScores;
            modelNames['primary'] = window.reportData.model_name || 'Primary Model';
        }
        
        // Adicionar modelos alternativos usando o caminho específico
        let altModelsAdded = false;
        
        // Verificar primeiro o caminho específico dado pelo usuário
        // results.results['robustness']['alternative_models']['GLM_CLASSIFIER']['raw']['by_level']['1.0']['runs']['all_features'][0]['perturbed_score']
        if (window.reportData && window.reportData.results && 
            window.reportData.results.robustness && 
            window.reportData.results.robustness.alternative_models) {
            
            console.log("Encontrados modelos alternativos no caminho novo:", 
                      Object.keys(window.reportData.results.robustness.alternative_models));
            
            let addedModels = 0;
            
            Object.entries(window.reportData.results.robustness.alternative_models).forEach(([name, altModelData]) => {
                console.log(`NOVO CAMINHO: Processando modelo alternativo: ${name}`);
                
                if (altModelData.raw && altModelData.raw.by_level) {
                    const rawData = altModelData.raw.by_level;
                    console.log(`NOVO CAMINHO: Modelo ${name} tem dados raw com níveis:`, Object.keys(rawData));
                    
                    // Extrair scores para este modelo alternativo
                    const scores = levels.map(level => {
                        const levelStr = level.toString();
                        
                        if (rawData[levelStr] && 
                            rawData[levelStr].runs && 
                            rawData[levelStr].runs.all_features && 
                            rawData[levelStr].runs.all_features.length > 0 &&
                            rawData[levelStr].runs.all_features[0].perturbed_score !== undefined) {
                            
                            const score = rawData[levelStr].runs.all_features[0].perturbed_score;
                            console.log(`NOVO CAMINHO: Extraído score para modelo ${name} nível ${level}: ${score}`);
                            return score;
                        }
                        
                        console.log(`NOVO CAMINHO: Nenhum score encontrado para modelo ${name} nível ${level}`);
                        return null;
                    });
                    
                    // Verificar se encontramos algum score
                    if (scores.some(score => score !== null)) {
                        modelScores[name] = scores;
                        modelNames[name] = name;
                        addedModels++;
                        console.log(`NOVO CAMINHO: Modelo ${name} adicionado com ${scores.filter(s => s !== null).length} scores válidos`);
                    } else {
                        console.log(`NOVO CAMINHO: Nenhum score válido encontrado para modelo ${name}`);
                    }
                } else {
                    console.log(`NOVO CAMINHO: Modelo ${name} não tem dados raw.by_level`);
                }
            });
            
            console.log(`NOVO CAMINHO: Adicionados ${addedModels} modelos alternativos`);
            
            // Marcar que adicionamos modelos alternativos pelo novo caminho
            if (addedModels > 0) {
                altModelsAdded = true;
            }
        }
        
        // Se não encontramos modelos alternativos pelo caminho novo, tentar pelo caminho antigo
        if (!altModelsAdded && window.reportData.alternative_models) {
            console.log("Tentando caminho antigo para modelos alternativos:", Object.keys(window.reportData.alternative_models));
            
            let addedModels = 0;
            Object.entries(window.reportData.alternative_models).forEach(([name, data]) => {
                console.log(`Processando modelo alternativo: ${name}`);
                
                // Mesmo que não tenha dados raw, vamos adicionar este modelo
                let scores = [];
                
                if (data.raw && data.raw.by_level) {
                    const rawData = data.raw.by_level;
                    console.log(`Modelo ${name} tem dados raw`);
                    
                    // Verificar primeiro se podemos usar dados pré-processados
                    if (window.reportData.perturbation_chart_data && 
                        window.reportData.perturbation_chart_data.alternativeModels && 
                        window.reportData.perturbation_chart_data.alternativeModels[name] &&
                        window.reportData.perturbation_chart_data.alternativeModels[name].scores &&
                        window.reportData.perturbation_chart_data.alternativeModels[name].scores.length === levels.length) {
                        
                        console.log(`Usando scores pré-processados para o modelo alternativo ${name}`);
                        scores = window.reportData.perturbation_chart_data.alternativeModels[name].scores;
                    } else {
                        // Caso contrário, extrair dos dados raw
                        console.log(`Extraindo scores raw para o modelo ${name}`);
                        scores = levels.map(level => {
                            const levelStr = level.toString();
                            // Caminho ESPECÍFICO fornecido pelo usuário para modelos alternativos
                            // results.results['robustness']['alternative_models']['GLM_CLASSIFIER']['raw']['by_level']['1.0']['runs']['all_features'][0]['perturbed_score']
                            if (rawData[levelStr] && 
                                rawData[levelStr].runs && 
                                rawData[levelStr].runs.all_features && 
                                rawData[levelStr].runs.all_features.length > 0 &&
                                rawData[levelStr].runs.all_features[0].perturbed_score !== undefined) {
                                
                                const score = rawData[levelStr].runs.all_features[0].perturbed_score;
                                console.log(`Extraído score do caminho específico (runs.all_features[0].perturbed_score) para modelo ${name} nível ${level}: ${score}`);
                                return score;
                            }
                            
                            // Primeiro, verifica se temos overall_result com all_features
                            if (rawData[levelStr] && 
                                rawData[levelStr].overall_result && 
                                rawData[levelStr].overall_result.all_features) {
                                
                                const score = rawData[levelStr].overall_result.all_features.mean_score;
                                console.log(`Extraído score do modelo ${name} para nível ${level}: ${score}`);
                                return score;
                            }
                            
                            // Se não encontrou no formato padrão, verifica outros formatos possíveis
                            if (rawData[levelStr] && rawData[levelStr].perturbed_score !== undefined) {
                                const score = rawData[levelStr].perturbed_score;
                                console.log(`Extraído perturbed_score do modelo ${name} para nível ${level}: ${score}`);
                                return score;
                            }
                            
                            // Verifica em mean_score direto no objeto do nível (comum em alguns formatos)
                            if (rawData[levelStr] && rawData[levelStr].mean_score !== undefined) {
                                const score = rawData[levelStr].mean_score;
                                console.log(`Extraído mean_score do modelo ${name} para nível ${level}: ${score}`);
                                return score;
                            }
                            
                            // Tenta encontrar mais profundamente nos resultados
                            if (rawData[levelStr] && 
                                rawData[levelStr].results && 
                                rawData[levelStr].results.overall_result && 
                                rawData[levelStr].results.overall_result.all_features) {
                                const score = rawData[levelStr].results.overall_result.all_features.mean_score;
                                console.log(`Extraído score do results.overall_result para nível ${level}: ${score}`);
                                return score;
                            }
                            
                            console.log(`Nenhum score encontrado para o modelo ${name} no nível ${level}`);
                            return null;
                        });
                        
                        // Tentativa final para modelos alternativos quando nenhum score é encontrado
                        if (!scores.some(score => score !== null)) {
                            console.log(`Tentativa final para o modelo ${name} - verificando todas as estruturas possíveis`);
                            
                            for (const levelStr of Object.keys(rawData)) {
                                const level = parseFloat(levelStr);
                                const levelData = rawData[levelStr];
                                console.log(`Modelo ${name}, nível ${level} estrutura:`, levelData);
                                
                                // Se nenhum score foi encontrado anteriormente, tentar todos os caminhos possíveis
                                const paths = [
                                    ['mean_score'],
                                    ['perturbed_score'],
                                    ['overall_result', 'all_features', 'mean_score'],
                                    ['overall_result', 'mean_score'],
                                    ['results', 'overall_result', 'all_features', 'mean_score'],
                                    ['results', 'mean_score'],
                                    // Adicionar mais caminhos possíveis conforme necessário
                                ];
                                
                                for (const path of paths) {
                                    let current = levelData;
                                    let found = true;
                                    
                                    for (const key of path) {
                                        if (current && current[key] !== undefined) {
                                            current = current[key];
                                        } else {
                                            found = false;
                                            break;
                                        }
                                    }
                                    
                                    if (found && typeof current === 'number') {
                                        console.log(`Modelo ${name}, nível ${level} - score encontrado pelo caminho [${path.join(', ')}]: ${current}`);
                                        // Atualizar o score para este nível
                                        const levelIndex = levels.findIndex(l => Math.abs(l - level) < 0.0001);
                                        if (levelIndex >= 0) {
                                            scores[levelIndex] = current;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Adicionar log para debugging dos valores nulos
                        if (scores.includes(null)) {
                            console.log(`Modelo ${name} tem valores null:`, scores);
                            console.log(`Níveis correspondentes para ${name}:`, levels);
                        }
                    }
                } else {
                    console.log(`Modelo ${name} não tem dados raw, ignorando`);
                    // Não fazer nada - pular este modelo já que não temos dados reais
                    // Isso substitui o uso de 'continue'
                } 
                
                // Se temos dados raw e scores válidos, adicionamos o modelo
                if (data.raw && data.raw.by_level && scores.some(score => score !== null)) {
                    // Só adicionar este modelo se temos scores válidos
                    // Desabilitar criação de dados sintéticos quando não precisamos disso
                    // Se não encontramos nenhum score real, não adicionamos este modelo
                    modelScores[name] = scores;
                    modelNames[name] = name;
                    addedModels++;
                    console.log(`Modelo ${name} adicionado com ${scores.filter(s => s !== null).length} scores válidos`);
                } else {
                    console.log(`Modelo ${name} não tem scores válidos e não foi adicionado`);
                }
            });
            
            console.log(`Adicionados ${addedModels} modelos alternativos`);
            
            // Se não encontramos modelos alternativos, mostrar mensagem
            if (addedModels === 0) {
                console.log("Não foram encontrados modelos alternativos para comparação");
            }
        } else {
            console.log("Nenhum dado de modelo alternativo encontrado");
            // Não criar modelos sintéticos, apenas prosseguir com os dados reais disponíveis
        }
        }
        
        // Verificação final: garantir que só temos modelos com dados válidos
        for (const modelId in modelScores) {
            if (!modelScores[modelId].some(score => score !== null)) {
                console.log(`Modelo ${modelId} não tem scores válidos - removendo`);
                delete modelScores[modelId];
                delete modelNames[modelId];
            }
        }
        
        // Log os dados finais
        console.log("Dados finais para o gráfico de comparação de modelos:");
        console.log("- Níveis:", levels);
        console.log("- Modelos:", Object.keys(modelScores));
        for (const modelId in modelScores) {
            console.log(`- ${modelId}: ${modelScores[modelId].length} scores, ${modelScores[modelId].filter(s => s !== null).length} válidos`);
        }
        
        
        try {
            return {
            levels,
            modelScores,
            modelNames,
            metricName
        };
        } catch (error) {
            console.error('Error in model level details data extraction:', error);
            return {
                levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                modelNames: { 'primary': 'Primary Model' },
                metricName: 'Score'
            };
        }

    },
    
    /**
     * Show no data message in chart container
     * @param {HTMLElement} element - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(element, message) {
        console.log("Mostrando mensagem de dados indisponíveis: " + message);
        element.innerHTML = `
            <div class="data-unavailable">
                <div class="data-message">
                    <span class="message-icon">📊</span>
                    <h3>No Data Available</h3>
                    <p>${message}</p>
                </div>
            </div>`;
    },
    
    /**
     * Show error message in chart container
     * @param {HTMLElement} element - Chart container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(element, errorMessage) {
        element.innerHTML = `
            <div style='padding: 20px; color: red;'>
                Error creating chart: ${errorMessage}
            </div>`;
    },
    
    /**
     * Format score value to a readable string
     * @param {number} score - The score value to format
     * @param {number} decimals - Number of decimal places
     * @returns {string} Formatted score
     */
    formatScore: function(score, decimals = 4) {
        if (score === null || score === undefined) return 'N/A';
        return score.toFixed(decimals);
    }
};

// ----- Controller JS Files ----- //

// ----- controllers/PerturbationResultsController.js ----- //
// PerturbationResultsController.js
const PerturbationResultsController = {
    // Store the extracted data
    data: null,
    
    // Store UI state
    state: {
        selectedLevel: null,
        activeTab: 'summary',
        expandedSection: 'allFeatures'
    },
    
    /**
     * Initialize the controller
     */
    init: function() {
        console.log("Initializing Perturbation Results Controller");
        
        // Extract perturbation data if the manager exists
        if (typeof PerturbationResultsManager !== 'undefined') {
            this.data = PerturbationResultsManager.extractPerturbationData();
            
            // Set initial selected level to middle value if available, otherwise first value
            if (this.data.results.length > 0) {
                const middleIndex = Math.floor(this.data.results.length / 2);
                this.state.selectedLevel = this.data.results[middleIndex].level;
            }
            
            // Render the component
            this.render();
            
            // Initialize event listeners
            this.initEventListeners();
        } else {
            console.error("PerturbationResultsManager not found");
            this.renderError("Unable to extract perturbation data. PerturbationResultsManager not available.");
        }
    },
    
    /**
     * Render the perturbation results UI
     */
    render: function() {
        const container = document.getElementById('perturbation-results-container');
        if (!container) {
            console.error("Perturbation results container not found");
            return;
        }
        
        // Clear container
        container.innerHTML = '';
        
        // Create main container
        const mainDiv = document.createElement('div');
        mainDiv.className = 'bg-white rounded-lg shadow-md overflow-hidden';
        
        // Create header
        mainDiv.appendChild(this.createHeader());
        
        // Create content based on active tab
        if (this.state.activeTab === 'summary') {
            mainDiv.appendChild(this.createSummaryTab());
        } else {
            mainDiv.appendChild(this.createIterationsTab());
        }
        
        // Create footer
        mainDiv.appendChild(this.createFooter());
        
        // Add to container
        container.appendChild(mainDiv);
    },
    
    /**
     * Render an error message
     */
    renderError: function(message) {
        const container = document.getElementById('perturbation-results-container');
        if (!container) {
            console.error("Perturbation results container not found");
            return;
        }
        
        // Clear container
        container.innerHTML = '';
        
        // Create error message
        const errorDiv = document.createElement('div');
        errorDiv.className = 'p-6 text-center text-red-500 bg-red-50 rounded-lg border border-red-200';
        
        const errorIcon = document.createElement('div');
        errorIcon.className = 'text-4xl mb-3';
        errorIcon.innerHTML = '❌';
        errorDiv.appendChild(errorIcon);
        
        const errorTitle = document.createElement('h3');
        errorTitle.className = 'text-lg font-medium text-red-800 mb-2';
        errorTitle.textContent = 'Error Loading Perturbation Results';
        errorDiv.appendChild(errorTitle);
        
        const errorMessage = document.createElement('p');
        errorMessage.className = 'text-red-600';
        errorMessage.textContent = message || 'An unknown error occurred while loading perturbation data.';
        errorDiv.appendChild(errorMessage);
        
        container.appendChild(errorDiv);
    },
    
    /**
     * Initialize event listeners
     */
    initEventListeners: function() {
        document.addEventListener('click', (event) => {
            // Handle level selection
            if (event.target.classList.contains('level-btn')) {
                const level = parseFloat(event.target.dataset.level);
                this.state.selectedLevel = level;
                this.render();
            }
            
            // Handle tab selection
            if (event.target.classList.contains('tab-btn')) {
                const tab = event.target.dataset.tab;
                this.state.activeTab = tab;
                this.render();
            }
            
            // Handle section toggle
            if (event.target.closest('.section-toggle')) {
                const section = event.target.closest('.section-toggle').dataset.section;
                this.state.expandedSection = this.state.expandedSection === section ? null : section;
                this.render();
            }
        });
    },
    
    /**
     * Create header section
     * @returns {HTMLElement} Header element
     */
    createHeader: function() {
        const header = document.createElement('div');
        header.className = 'p-4 border-b border-gray-200';
        
        // Title
        const title = document.createElement('h2');
        title.className = 'text-xl font-bold text-gray-800';
        title.textContent = 'Perturbation Test Results';
        header.appendChild(title);
        
        // Perturbation level selector
        const levelSelectorContainer = document.createElement('div');
        levelSelectorContainer.className = 'mt-3';
        
        const levelLabel = document.createElement('label');
        levelLabel.className = 'block text-sm font-medium text-gray-700 mb-1';
        levelLabel.textContent = 'Perturbation Level:';
        levelSelectorContainer.appendChild(levelLabel);
        
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'flex space-x-1';
        
        this.data.results.forEach(result => {
            const levelBtn = document.createElement('button');
            levelBtn.className = `level-btn px-3 py-1 rounded text-sm ${
                this.state.selectedLevel === result.level
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
            }`;
            levelBtn.textContent = `${result.level * 100}%`;
            levelBtn.dataset.level = result.level;
            buttonGroup.appendChild(levelBtn);
        });
        
        levelSelectorContainer.appendChild(buttonGroup);
        header.appendChild(levelSelectorContainer);
        
        // Tabs
        const tabsContainer = document.createElement('div');
        tabsContainer.className = 'mt-3 border-b border-gray-200';
        
        const tabsNav = document.createElement('nav');
        tabsNav.className = '-mb-px flex space-x-8';
        
        const summaryTab = document.createElement('button');
        summaryTab.className = `tab-btn whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
            this.state.activeTab === 'summary'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700'
        }`;
        summaryTab.textContent = 'Summary';
        summaryTab.dataset.tab = 'summary';
        tabsNav.appendChild(summaryTab);
        
        const iterationsTab = document.createElement('button');
        iterationsTab.className = `tab-btn whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
            this.state.activeTab === 'iterations'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700'
        }`;
        iterationsTab.textContent = 'Iterations';
        iterationsTab.dataset.tab = 'iterations';
        tabsNav.appendChild(iterationsTab);
        
        tabsContainer.appendChild(tabsNav);
        header.appendChild(tabsContainer);
        
        return header;
    },
    
    /**
     * Create summary tab content
     * @returns {HTMLElement} Summary tab element
     */
    createSummaryTab: function() {
        const selectedData = this.data.results.find(r => r.level === this.state.selectedLevel);
        if (!selectedData) {
            return this.createErrorMessage("No data available for selected level");
        }
        
        const summaryTab = document.createElement('div');
        summaryTab.className = 'p-4';
        
        // Feature summaries grid
        const summaryGrid = document.createElement('div');
        summaryGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';
        
        // All Features Summary
        summaryGrid.appendChild(this.createFeatureSummary(
            selectedData.allFeatures, 
            'allFeatures', 
            'All Features'
        ));
        
        // Feature Subset Summary
        summaryGrid.appendChild(this.createFeatureSummary(
            selectedData.featureSubset, 
            'featureSubset', 
            'Feature Subset'
        ));
        
        summaryTab.appendChild(summaryGrid);
        
        // Analysis box
        const analysisBox = document.createElement('div');
        analysisBox.className = 'mt-4 p-4 bg-blue-50 rounded-lg';
        
        const analysisTitle = document.createElement('h3');
        analysisTitle.className = 'font-medium text-blue-800 mb-2';
        analysisTitle.textContent = 'Analysis';
        analysisBox.appendChild(analysisTitle);
        
        const analysisParagraph = document.createElement('p');
        analysisParagraph.className = 'text-sm text-blue-700';
        
        // Generate analysis text
        let analysisText = `At ${this.state.selectedLevel * 100}% perturbation, the model shows `;
        if (selectedData.allFeatures.impact < 0) {
            analysisText += 'improvement ';
        } else {
            analysisText += `degradation of ${PerturbationResultsManager.formatNumber(selectedData.allFeatures.impact * 100, 2)}% `;
        }
        analysisText += 'when all features are perturbed. ';
        
        if (selectedData.featureSubset.impact < selectedData.allFeatures.impact) {
            analysisText += `The feature subset shows better robustness with only ${PerturbationResultsManager.formatNumber(selectedData.featureSubset.impact * 100, 2)}% impact.`;
        }
        
        analysisParagraph.textContent = analysisText;
        analysisBox.appendChild(analysisParagraph);
        
        summaryTab.appendChild(analysisBox);
        
        return summaryTab;
    },
    
    /**
     * Create feature summary panel
     * @param {Object} featureData - Data for feature type
     * @param {string} sectionId - Section identifier
     * @param {string} title - Section title
     * @returns {HTMLElement} Feature summary element
     */
    createFeatureSummary: function(featureData, sectionId, title) {
        const summaryPanel = document.createElement('div');
        summaryPanel.className = `border rounded-lg overflow-hidden ${
            this.state.expandedSection === sectionId ? 'shadow-md' : ''
        }`;
        
        // Header
        const panelHeader = document.createElement('div');
        panelHeader.className = 'section-toggle bg-gray-50 p-3 flex justify-between items-center cursor-pointer';
        panelHeader.dataset.section = sectionId;
        
        const panelTitle = document.createElement('h3');
        panelTitle.className = 'font-medium';
        panelTitle.textContent = title;
        panelHeader.appendChild(panelTitle);
        
        const impactSpan = document.createElement('span');
        impactSpan.className = `text-sm font-semibold ${PerturbationResultsManager.getImpactColorClass(featureData.impact)}`;
        impactSpan.textContent = `Impact: ${PerturbationResultsManager.formatNumber(featureData.impact * 100)}%`;
        panelHeader.appendChild(impactSpan);
        
        summaryPanel.appendChild(panelHeader);
        
        // Content
        const panelContent = document.createElement('div');
        panelContent.className = `p-4 ${this.state.expandedSection === sectionId ? 'block' : 'hidden'}`;
        
        // Stats table
        const statsTable = document.createElement('table');
        statsTable.className = 'min-w-full divide-y divide-gray-200';
        
        const tbody = document.createElement('tbody');
        tbody.className = 'divide-y divide-gray-200';
        
        // Base Score
        const baseScoreRow = document.createElement('tr');
        
        const baseScoreLabel = document.createElement('td');
        baseScoreLabel.className = 'px-3 py-2 text-sm font-medium text-gray-900';
        baseScoreLabel.textContent = 'Base Score';
        baseScoreRow.appendChild(baseScoreLabel);
        
        const baseScoreValue = document.createElement('td');
        baseScoreValue.className = 'px-3 py-2 text-sm text-gray-700';
        baseScoreValue.textContent = PerturbationResultsManager.formatNumber(featureData.baseScore);
        baseScoreRow.appendChild(baseScoreValue);
        
        tbody.appendChild(baseScoreRow);
        
        // Mean Score
        const meanScoreRow = document.createElement('tr');
        
        const meanScoreLabel = document.createElement('td');
        meanScoreLabel.className = 'px-3 py-2 text-sm font-medium text-gray-900';
        meanScoreLabel.textContent = 'Mean Score';
        meanScoreRow.appendChild(meanScoreLabel);
        
        const meanScoreValue = document.createElement('td');
        meanScoreValue.className = 'px-3 py-2 text-sm text-gray-700';
        
        const meanScoreText = document.createTextNode(
            PerturbationResultsManager.formatNumber(featureData.meanScore)
        );
        meanScoreValue.appendChild(meanScoreText);
        
        const meanScoreDiff = document.createElement('span');
        const diffValue = featureData.meanScore - featureData.baseScore;
        meanScoreDiff.className = `ml-2 ${diffValue >= 0 ? 'text-green-600' : 'text-red-600'}`;
        meanScoreDiff.textContent = `(${diffValue >= 0 ? '+' : ''}${PerturbationResultsManager.formatNumber(diffValue * 100, 2)}%)`;
        meanScoreValue.appendChild(meanScoreDiff);
        
        meanScoreRow.appendChild(meanScoreValue);
        tbody.appendChild(meanScoreRow);
        
        // Worst Score
        const worstScoreRow = document.createElement('tr');
        
        const worstScoreLabel = document.createElement('td');
        worstScoreLabel.className = 'px-3 py-2 text-sm font-medium text-gray-900';
        worstScoreLabel.textContent = 'Worst Score';
        worstScoreRow.appendChild(worstScoreLabel);
        
        const worstScoreValue = document.createElement('td');
        worstScoreValue.className = 'px-3 py-2 text-sm text-red-600';
        
        const worstScoreText = document.createTextNode(
            PerturbationResultsManager.formatNumber(featureData.worstScore)
        );
        worstScoreValue.appendChild(worstScoreText);
        
        const worstScoreDiff = document.createElement('span');
        worstScoreDiff.className = 'ml-2';
        worstScoreDiff.textContent = `(${PerturbationResultsManager.formatNumber((featureData.worstScore - featureData.baseScore) * 100, 2)}%)`;
        worstScoreValue.appendChild(worstScoreDiff);
        
        worstScoreRow.appendChild(worstScoreValue);
        tbody.appendChild(worstScoreRow);
        
        statsTable.appendChild(tbody);
        panelContent.appendChild(statsTable);
        
        // Impact bar
        const barContainer = document.createElement('div');
        barContainer.className = 'mt-3';
        
        const barLabels = document.createElement('div');
        barLabels.className = 'flex justify-between text-xs text-gray-500 mb-1';
        
        const startLabel = document.createElement('span');
        startLabel.textContent = '0% (Base)';
        barLabels.appendChild(startLabel);
        
        const middleLabel = document.createElement('span');
        middleLabel.textContent = 'Impact';
        barLabels.appendChild(middleLabel);
        
        const endLabel = document.createElement('span');
        endLabel.textContent = '25%';
        barLabels.appendChild(endLabel);
        
        barContainer.appendChild(barLabels);
        
        const barBg = document.createElement('div');
        barBg.className = 'w-full bg-gray-200 rounded-full h-2.5';
        
        const barFill = document.createElement('div');
        barFill.className = `h-2.5 rounded-full ${featureData.impact < 0 ? 'bg-green-500' : 'bg-red-500'}`;
        barFill.style.width = `${Math.min(Math.abs(featureData.impact) * 100 * 4, 100)}%`;
        
        barBg.appendChild(barFill);
        barContainer.appendChild(barBg);
        
        panelContent.appendChild(barContainer);
        summaryPanel.appendChild(panelContent);
        
        return summaryPanel;
    },
    
    /**
     * Create iterations tab content
     * @returns {HTMLElement} Iterations tab element
     */
    createIterationsTab: function() {
        const selectedData = this.data.results.find(r => r.level === this.state.selectedLevel);
        if (!selectedData) {
            return this.createErrorMessage("No data available for selected level");
        }
        
        const iterationsTab = document.createElement('div');
        iterationsTab.className = 'p-4';
        
        // Table container
        const tableContainer = document.createElement('div');
        tableContainer.className = 'overflow-x-auto';
        
        const table = document.createElement('table');
        table.className = 'min-w-full divide-y divide-gray-200';
        
        // Table header
        const thead = document.createElement('thead');
        thead.className = 'bg-gray-50';
        
        const headerRow = document.createElement('tr');
        
        const headers = [
            { text: 'Iteration', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
            { text: 'All Features', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
            { text: 'Feature Subset', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
            { text: 'Difference', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' }
        ];
        
        headers.forEach(header => {
            const th = document.createElement('th');
            th.className = header.className;
            th.textContent = header.text;
            headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Table body
        const tbody = document.createElement('tbody');
        tbody.className = 'bg-white divide-y divide-gray-200';
        
        // Base score row
        const baseRow = document.createElement('tr');
        baseRow.className = 'bg-gray-100';
        
        const baseIterationCell = document.createElement('td');
        baseIterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
        baseIterationCell.textContent = 'Base';
        baseRow.appendChild(baseIterationCell);
        
        const baseAllFeaturesCell = document.createElement('td');
        baseAllFeaturesCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        baseAllFeaturesCell.textContent = PerturbationResultsManager.formatNumber(selectedData.allFeatures.baseScore);
        baseRow.appendChild(baseAllFeaturesCell);
        
        const baseFeatureSubsetCell = document.createElement('td');
        baseFeatureSubsetCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        baseFeatureSubsetCell.textContent = PerturbationResultsManager.formatNumber(selectedData.featureSubset.baseScore);
        baseRow.appendChild(baseFeatureSubsetCell);
        
        const baseDifferenceCell = document.createElement('td');
        baseDifferenceCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        baseDifferenceCell.textContent = '0.0000';
        baseRow.appendChild(baseDifferenceCell);
        
        tbody.appendChild(baseRow);
        
        // Iteration rows
        const allFeaturesIterations = selectedData.allFeatures.iterations || [];
        const featureSubsetIterations = selectedData.featureSubset.iterations || [];
        
        const maxIterations = Math.max(allFeaturesIterations.length, featureSubsetIterations.length);
        
        for (let i = 0; i < maxIterations; i++) {
            const iterationRow = document.createElement('tr');
            
            // Iteration number
            const iterationCell = document.createElement('td');
            iterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-900';
            iterationCell.textContent = `#${i + 1}`;
            iterationRow.appendChild(iterationCell);
            
            // All features score
            const allFeaturesScore = allFeaturesIterations[i] || selectedData.allFeatures.meanScore;
            const allFeaturesCell = document.createElement('td');
            allFeaturesCell.className = `px-6 py-3 whitespace-nowrap text-sm text-gray-700 ${
                PerturbationResultsManager.getScoreBgColorClass(allFeaturesScore, selectedData.allFeatures.baseScore)
            }`;
            
            const allFeaturesScoreText = document.createTextNode(
                PerturbationResultsManager.formatNumber(allFeaturesScore)
            );
            allFeaturesCell.appendChild(allFeaturesScoreText);
            
            const allFeaturesDiff = allFeaturesScore - selectedData.allFeatures.baseScore;
            const allFeaturesDiffSpan = document.createElement('span');
            allFeaturesDiffSpan.className = `ml-2 text-xs ${allFeaturesDiff >= 0 ? 'text-green-600' : 'text-red-600'}`;
            allFeaturesDiffSpan.textContent = `(${allFeaturesDiff >= 0 ? '+' : ''}${PerturbationResultsManager.formatNumber(allFeaturesDiff * 100, 2)}%)`;
            allFeaturesCell.appendChild(allFeaturesDiffSpan);
            
            iterationRow.appendChild(allFeaturesCell);
            
            // Feature subset score
            const featureSubsetScore = featureSubsetIterations[i] || selectedData.featureSubset.meanScore;
            const featureSubsetCell = document.createElement('td');
            featureSubsetCell.className = `px-6 py-3 whitespace-nowrap text-sm text-gray-700 ${
                PerturbationResultsManager.getScoreBgColorClass(featureSubsetScore, selectedData.featureSubset.baseScore)
            }`;
            
            const featureSubsetScoreText = document.createTextNode(
                PerturbationResultsManager.formatNumber(featureSubsetScore)
            );
            featureSubsetCell.appendChild(featureSubsetScoreText);
            
            const featureSubsetDiff = featureSubsetScore - selectedData.featureSubset.baseScore;
            const featureSubsetDiffSpan = document.createElement('span');
            featureSubsetDiffSpan.className = `ml-2 text-xs ${featureSubsetDiff >= 0 ? 'text-green-600' : 'text-red-600'}`;
            featureSubsetDiffSpan.textContent = `(${featureSubsetDiff >= 0 ? '+' : ''}${PerturbationResultsManager.formatNumber(featureSubsetDiff * 100, 2)}%)`;
            featureSubsetCell.appendChild(featureSubsetDiffSpan);
            
            iterationRow.appendChild(featureSubsetCell);
            
            // Difference between scores
            const scoreDiff = featureSubsetScore - allFeaturesScore;
            const differenceCell = document.createElement('td');
            differenceCell.className = `px-6 py-3 whitespace-nowrap text-sm ${scoreDiff > 0 ? 'text-green-600' : 'text-red-600'}`;
            differenceCell.textContent = `${scoreDiff > 0 ? '+' : ''}${PerturbationResultsManager.formatNumber(scoreDiff)}`;
            
            iterationRow.appendChild(differenceCell);
            
            tbody.appendChild(iterationRow);
        }
        
        // Mean row
        const meanRow = document.createElement('tr');
        meanRow.className = 'bg-gray-100';
        
        const meanLabelCell = document.createElement('td');
        meanLabelCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
        meanLabelCell.textContent = 'Mean';
        meanRow.appendChild(meanLabelCell);
        
        const allFeaturesMeanCell = document.createElement('td');
        allFeaturesMeanCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        allFeaturesMeanCell.textContent = PerturbationResultsManager.formatNumber(selectedData.allFeatures.meanScore);
        meanRow.appendChild(allFeaturesMeanCell);
        
        const featureSubsetMeanCell = document.createElement('td');
        featureSubsetMeanCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        featureSubsetMeanCell.textContent = PerturbationResultsManager.formatNumber(selectedData.featureSubset.meanScore);
        meanRow.appendChild(featureSubsetMeanCell);
        
        const meanDiffCell = document.createElement('td');
        const meanDiff = selectedData.featureSubset.meanScore - selectedData.allFeatures.meanScore;
        meanDiffCell.className = `px-6 py-3 whitespace-nowrap text-sm font-medium ${
            meanDiff > 0 ? 'text-green-600' : 'text-red-600'
        }`;
        meanDiffCell.textContent = `${meanDiff > 0 ? '+' : ''}${PerturbationResultsManager.formatNumber(meanDiff)}`;
        meanRow.appendChild(meanDiffCell);
        
        tbody.appendChild(meanRow);
        table.appendChild(tbody);
        tableContainer.appendChild(table);
        iterationsTab.appendChild(tableContainer);
        
        // Additional stats
        const statsGrid = document.createElement('div');
        statsGrid.className = 'mt-4 grid grid-cols-1 md:grid-cols-2 gap-4';
        
        // Worst performance
        const worstPerformanceDiv = document.createElement('div');
        worstPerformanceDiv.className = 'p-3 bg-yellow-50 rounded-lg';
        
        const worstPerfTitle = document.createElement('h3');
        worstPerfTitle.className = 'font-medium text-yellow-800 mb-1';
        worstPerfTitle.textContent = 'Worst Performance';
        worstPerformanceDiv.appendChild(worstPerfTitle);
        
        const allFeaturesWorst = document.createElement('p');
        allFeaturesWorst.className = 'text-sm text-yellow-700';
        allFeaturesWorst.innerHTML = `All Features: ${PerturbationResultsManager.formatNumber(selectedData.allFeatures.worstScore)} 
            <span class="ml-1">
                (${PerturbationResultsManager.formatNumber((selectedData.allFeatures.worstScore - selectedData.allFeatures.baseScore) * 100, 2)}%)
            </span>`;
        worstPerformanceDiv.appendChild(allFeaturesWorst);
        
        const featureSubsetWorst = document.createElement('p');
        featureSubsetWorst.className = 'text-sm text-yellow-700';
        featureSubsetWorst.innerHTML = `Feature Subset: ${PerturbationResultsManager.formatNumber(selectedData.featureSubset.worstScore)}
            <span class="ml-1">
                (${PerturbationResultsManager.formatNumber((selectedData.featureSubset.worstScore - selectedData.featureSubset.baseScore) * 100, 2)}%)
            </span>`;
        worstPerformanceDiv.appendChild(featureSubsetWorst);
        
        statsGrid.appendChild(worstPerformanceDiv);
        
        // Standard deviation
        const stdDevDiv = document.createElement('div');
        stdDevDiv.className = 'p-3 bg-blue-50 rounded-lg';
        
        const stdDevTitle = document.createElement('h3');
        stdDevTitle.className = 'font-medium text-blue-800 mb-1';
        stdDevTitle.textContent = 'Standard Deviation';
        stdDevDiv.appendChild(stdDevTitle);
        
        // Calculate standard deviations
        const calculateStdDev = (scores, mean) => {
            if (!scores || scores.length === 0) return 0;
            const squaredDiffs = scores.map(score => Math.pow(score - mean, 2));
            const variance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / scores.length;
            return Math.sqrt(variance);
        };
        
        const allFeaturesStdDev = calculateStdDev(
            selectedData.allFeatures.iterations,
            selectedData.allFeatures.meanScore
        );
        
        const featureSubsetStdDev = calculateStdDev(
            selectedData.featureSubset.iterations,
            selectedData.featureSubset.meanScore
        );
        
        const allFeaturesStdDevP = document.createElement('p');
        allFeaturesStdDevP.className = 'text-sm text-blue-700';
        allFeaturesStdDevP.textContent = `All Features: ${PerturbationResultsManager.formatNumber(allFeaturesStdDev)}`;
        stdDevDiv.appendChild(allFeaturesStdDevP);
        
        const featureSubsetStdDevP = document.createElement('p');
        featureSubsetStdDevP.className = 'text-sm text-blue-700';
        featureSubsetStdDevP.textContent = `Feature Subset: ${PerturbationResultsManager.formatNumber(featureSubsetStdDev)}`;
        stdDevDiv.appendChild(featureSubsetStdDevP);
        
        statsGrid.appendChild(stdDevDiv);
        iterationsTab.appendChild(statsGrid);
        
        return iterationsTab;
    },
    
    /**
     * Create footer section
     * @returns {HTMLElement} Footer element
     */
    createFooter: function() {
        const footer = document.createElement('div');
        footer.className = 'p-3 border-t border-gray-200 text-xs text-gray-500';
        
        const footerFlex = document.createElement('div');
        footerFlex.className = 'flex justify-between';
        
        const leftSpan = document.createElement('span');
        leftSpan.textContent = `Perturbation Test • ${this.data.modelType} • ${this.data.metric} Metric`;
        footerFlex.appendChild(leftSpan);
        
        const rightSpan = document.createElement('span');
        rightSpan.textContent = `Base Score: ${PerturbationResultsManager.formatNumber(this.data.baseScore)} • Date: ${new Date().toLocaleDateString()}`;
        footerFlex.appendChild(rightSpan);
        
        footer.appendChild(footerFlex);
        
        return footer;
    },
    
    /**
     * Create error message
     * @param {string} message - Error message to display
     * @returns {HTMLElement} Error message element
     */
    createErrorMessage: function(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'p-8 text-center text-red-500';
        errorDiv.textContent = message || 'An error occurred loading perturbation data';
        return errorDiv;
    }
};

// ----- controllers/SafePerturbationResultsController.js ----- //
// Safe implementation of the PerturbationResultsController
// This version fixes syntax errors and adds error handling
(function() {
    // Create the controller if it doesn't exist
    window.SafePerturbationResultsController = {
        // Store the extracted data
        data: null,
        
        // Store UI state
        state: {
            selectedLevel: null,
            activeTab: 'summary',
            expandedSection: 'allFeatures'
        },
        
        /**
         * Initialize the controller safely
         */
        init: function() {
            console.log("Initializing Safe Perturbation Results Controller");
            
            try {
                // Extract perturbation data if the manager exists
                if (typeof PerturbationResultsManager !== 'undefined') {
                    this.data = PerturbationResultsManager.extractPerturbationData();
                    
                    // Set initial selected level to middle value if available, otherwise first value
                    if (this.data && this.data.results && this.data.results.length > 0) {
                        const middleIndex = Math.floor(this.data.results.length / 2);
                        this.state.selectedLevel = this.data.results[middleIndex].level;
                    }
                    
                    // Render the component
                    this.render();
                    
                    // Initialize event listeners
                    this.initEventListeners();
                } else {
                    console.error("PerturbationResultsManager not found");
                    this.renderError("Unable to extract perturbation data. PerturbationResultsManager not available.");
                }
            } catch (error) {
                console.error("Error initializing PerturbationResultsController:", error);
                this.renderError("An error occurred while initializing: " + error.message);
            }
        },
        
        /**
         * Format a number safely
         * @param {number} value - Number to format
         * @param {number} decimals - Decimal places
         * @returns {string} Formatted number
         */
        formatNumber: function(value, decimals) {
            try {
                if (typeof value !== 'number') return 'N/A';
                const dec = decimals || 4;
                return value.toFixed(dec);
            } catch (error) {
                return 'Error';
            }
        },
        
        /**
         * Get color class for impact value safely
         * @param {number} impact - Impact value
         * @returns {string} CSS class
         */
        getImpactColorClass: function(impact) {
            try {
                if (impact < 0) return 'text-green-600';
                if (impact < 0.05) return 'text-yellow-600';
                if (impact < 0.1) return 'text-orange-600';
                return 'text-red-600';
            } catch (error) {
                return 'text-gray-600';
            }
        },
        
        /**
         * Get background color class for score comparison
         * @param {number} score - Score to compare
         * @param {number} baseScore - Base score
         * @returns {string} CSS class
         */
        getScoreBgColorClass: function(score, baseScore) {
            try {
                if (!score || !baseScore) return '';
                const diff = score - baseScore;
                if (diff > 0) return 'bg-green-50';
                if (diff < -0.1) return 'bg-red-50';
                if (diff < -0.05) return 'bg-orange-50';
                if (diff < 0) return 'bg-yellow-50';
                return '';
            } catch (error) {
                return '';
            }
        },
        
        /**
         * Create error message element
         * @param {string} message - Error message to display
         * @returns {HTMLElement} Error message element
         */
        createErrorMessage: function(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'p-8 text-center text-red-500';
            errorDiv.textContent = message || 'An error occurred loading perturbation data';
            return errorDiv;
        },
        
        /**
         * Render error message
         * @param {string} message - Error message to display
         */
        renderError: function(message) {
            const container = document.getElementById('perturbation-results-container');
            if (!container) {
                console.error("Perturbation results container not found");
                return;
            }
            
            // Clear container
            container.innerHTML = '';
            
            // Create error message
            const errorDiv = document.createElement('div');
            errorDiv.className = 'p-6 text-center text-red-500 bg-red-50 rounded-lg border border-red-200';
            
            const errorIcon = document.createElement('div');
            errorIcon.className = 'text-4xl mb-3';
            errorIcon.innerHTML = '❌';
            errorDiv.appendChild(errorIcon);
            
            const errorTitle = document.createElement('h3');
            errorTitle.className = 'text-lg font-medium text-red-800 mb-2';
            errorTitle.textContent = 'Error Loading Perturbation Results';
            errorDiv.appendChild(errorTitle);
            
            const errorMessage = document.createElement('p');
            errorMessage.className = 'text-red-600';
            errorMessage.textContent = message || 'An unknown error occurred while loading perturbation data.';
            errorDiv.appendChild(errorMessage);
            
            container.appendChild(errorDiv);
        },
        
        /**
         * Initialize event listeners
         */
        initEventListeners: function() {
            document.addEventListener('click', (event) => {
                try {
                    // Handle level selection
                    if (event.target.classList.contains('level-btn')) {
                        const level = parseFloat(event.target.dataset.level);
                        this.state.selectedLevel = level;
                        this.render();
                    }
                    
                    // Handle tab selection
                    if (event.target.classList.contains('tab-btn')) {
                        const tab = event.target.dataset.tab;
                        this.state.activeTab = tab;
                        this.render();
                    }
                    
                    // Handle section toggle
                    if (event.target.closest('.section-toggle')) {
                        const section = event.target.closest('.section-toggle').dataset.section;
                        this.state.expandedSection = this.state.expandedSection === section ? null : section;
                        this.render();
                    }
                } catch (error) {
                    console.error("Error in event listener:", error);
                }
            });
        },
        
        /**
         * Render the perturbation results UI
         */
        render: function() {
            try {
                const container = document.getElementById('perturbation-results-container');
                if (!container) {
                    console.error("Perturbation results container not found");
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                // Create main container
                const mainDiv = document.createElement('div');
                mainDiv.className = 'bg-white rounded-lg shadow-md overflow-hidden';
                
                // Create header
                mainDiv.appendChild(this.createHeader());
                
                // Create content based on active tab
                if (this.state.activeTab === 'summary') {
                    mainDiv.appendChild(this.createSummaryTab());
                } else {
                    mainDiv.appendChild(this.createIterationsTab());
                }
                
                // Create footer
                mainDiv.appendChild(this.createFooter());
                
                // Add to container
                container.appendChild(mainDiv);
            } catch (error) {
                console.error("Error rendering perturbation results:", error);
                this.renderError(error.message);
            }
        },
        
        // Create header section (same implementation with added try-catch)
        createHeader: function() {
            try {
                const header = document.createElement('div');
                header.className = 'p-4 border-b border-gray-200';
                
                // Title
                const title = document.createElement('h2');
                title.className = 'text-xl font-bold text-gray-800';
                title.textContent = 'Perturbation Test Results';
                header.appendChild(title);
                
                // Perturbation level selector (only if we have data)
                if (this.data && this.data.results && this.data.results.length > 0) {
                    const levelSelectorContainer = document.createElement('div');
                    levelSelectorContainer.className = 'mt-3';
                    
                    const levelLabel = document.createElement('label');
                    levelLabel.className = 'block text-sm font-medium text-gray-700 mb-1';
                    levelLabel.textContent = 'Perturbation Level:';
                    levelSelectorContainer.appendChild(levelLabel);
                    
                    const buttonGroup = document.createElement('div');
                    buttonGroup.className = 'flex space-x-1';
                    
                    this.data.results.forEach(result => {
                        const levelBtn = document.createElement('button');
                        levelBtn.className = `level-btn px-3 py-1 rounded text-sm ${
                            this.state.selectedLevel === result.level
                                ? 'bg-blue-600 text-white'
                                : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                        }`;
                        levelBtn.textContent = `${result.level * 100}%`;
                        levelBtn.dataset.level = result.level;
                        buttonGroup.appendChild(levelBtn);
                    });
                    
                    levelSelectorContainer.appendChild(buttonGroup);
                    header.appendChild(levelSelectorContainer);
                }
                
                // Tabs
                const tabsContainer = document.createElement('div');
                tabsContainer.className = 'mt-3 border-b border-gray-200';
                
                const tabsNav = document.createElement('nav');
                tabsNav.className = '-mb-px flex space-x-8';
                
                const summaryTab = document.createElement('button');
                summaryTab.className = `tab-btn whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
                    this.state.activeTab === 'summary'
                        ? 'border-blue-500 text-blue-600'
                        : 'border-transparent text-gray-500 hover:text-gray-700'
                }`;
                summaryTab.textContent = 'Summary';
                summaryTab.dataset.tab = 'summary';
                tabsNav.appendChild(summaryTab);
                
                const iterationsTab = document.createElement('button');
                iterationsTab.className = `tab-btn whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
                    this.state.activeTab === 'iterations'
                        ? 'border-blue-500 text-blue-600'
                        : 'border-transparent text-gray-500 hover:text-gray-700'
                }`;
                iterationsTab.textContent = 'Iterations';
                iterationsTab.dataset.tab = 'iterations';
                tabsNav.appendChild(iterationsTab);
                
                tabsContainer.appendChild(tabsNav);
                header.appendChild(tabsContainer);
                
                return header;
            } catch (error) {
                console.error("Error creating header:", error);
                return this.createErrorMessage("Error creating header");
            }
        },
        
        // Create summary tab content (wrapper with try-catch)
        createSummaryTab: function() {
            try {
                // Find selected data
                const selectedData = this.data && this.data.results ? 
                    this.data.results.find(r => r.level === this.state.selectedLevel) : null;
                
                if (!selectedData) {
                    return this.createErrorMessage("No data available for selected level");
                }
                
                const summaryTab = document.createElement('div');
                summaryTab.className = 'p-4';
                
                // Feature summaries grid
                const summaryGrid = document.createElement('div');
                summaryGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';
                
                // All Features Summary
                if (selectedData.allFeatures) {
                    summaryGrid.appendChild(this.createFeatureSummary(
                        selectedData.allFeatures, 
                        'allFeatures', 
                        'All Features'
                    ));
                }
                
                // Feature Subset Summary
                if (selectedData.featureSubset) {
                    summaryGrid.appendChild(this.createFeatureSummary(
                        selectedData.featureSubset, 
                        'featureSubset', 
                        'Feature Subset'
                    ));
                }
                
                summaryTab.appendChild(summaryGrid);
                
                // Analysis box
                if (selectedData.allFeatures) {
                    const analysisBox = document.createElement('div');
                    analysisBox.className = 'mt-4 p-4 bg-blue-50 rounded-lg';
                    
                    const analysisTitle = document.createElement('h3');
                    analysisTitle.className = 'font-medium text-blue-800 mb-2';
                    analysisTitle.textContent = 'Analysis';
                    analysisBox.appendChild(analysisTitle);
                    
                    const analysisParagraph = document.createElement('p');
                    analysisParagraph.className = 'text-sm text-blue-700';
                    
                    // Generate analysis text safely
                    let analysisText = `At ${this.state.selectedLevel * 100}% perturbation, the model shows `;
                    if (selectedData.allFeatures.impact < 0) {
                        analysisText += 'improvement ';
                    } else {
                        analysisText += `degradation of ${this.formatNumber(selectedData.allFeatures.impact * 100, 2)}% `;
                    }
                    analysisText += 'when all features are perturbed. ';
                    
                    if (selectedData.featureSubset && selectedData.featureSubset.impact < selectedData.allFeatures.impact) {
                        analysisText += `The feature subset shows better robustness with only ${this.formatNumber(selectedData.featureSubset.impact * 100, 2)}% impact.`;
                    }
                    
                    analysisParagraph.textContent = analysisText;
                    analysisBox.appendChild(analysisParagraph);
                    
                    summaryTab.appendChild(analysisBox);
                }
                
                return summaryTab;
                
            } catch (error) {
                console.error("Error creating summary tab:", error);
                return this.createErrorMessage("Error creating summary tab: " + error.message);
            }
        },
        
        // Create feature summary panel (with added try-catch)
        createFeatureSummary: function(featureData, sectionId, title) {
            try {
                if (!featureData) {
                    return this.createErrorMessage(`No data available for ${title}`);
                }
                
                const summaryPanel = document.createElement('div');
                summaryPanel.className = `border rounded-lg overflow-hidden ${
                    this.state.expandedSection === sectionId ? 'shadow-md' : ''
                }`;
                
                // Header
                const panelHeader = document.createElement('div');
                panelHeader.className = 'section-toggle bg-gray-50 p-3 flex justify-between items-center cursor-pointer';
                panelHeader.dataset.section = sectionId;
                
                const panelTitle = document.createElement('h3');
                panelTitle.className = 'font-medium';
                panelTitle.textContent = title;
                panelHeader.appendChild(panelTitle);
                
                const impactSpan = document.createElement('span');
                impactSpan.className = `text-sm font-semibold ${this.getImpactColorClass(featureData.impact)}`;
                impactSpan.textContent = `Impact: ${this.formatNumber(featureData.impact * 100)}%`;
                panelHeader.appendChild(impactSpan);
                
                summaryPanel.appendChild(panelHeader);
                
                // Content (only if expanded)
                if (this.state.expandedSection === sectionId) {
                    const panelContent = document.createElement('div');
                    panelContent.className = 'p-4';
                    
                    // Stats table
                    const statsTable = document.createElement('table');
                    statsTable.className = 'min-w-full divide-y divide-gray-200';
                    
                    const tbody = document.createElement('tbody');
                    tbody.className = 'divide-y divide-gray-200';
                    
                    // Add rows to the table
                    const rows = [
                        { label: 'Base Score', value: this.formatNumber(featureData.baseScore) },
                        { 
                            label: 'Mean Score',
                            value: this.formatNumber(featureData.meanScore),
                            diff: featureData.meanScore - featureData.baseScore
                        },
                        { 
                            label: 'Worst Score',
                            value: this.formatNumber(featureData.worstScore),
                            diff: featureData.worstScore - featureData.baseScore
                        }
                    ];
                    
                    // Create rows
                    rows.forEach(rowData => {
                        const row = document.createElement('tr');
                        
                        const labelCell = document.createElement('td');
                        labelCell.className = 'px-3 py-2 text-sm font-medium text-gray-900';
                        labelCell.textContent = rowData.label;
                        row.appendChild(labelCell);
                        
                        const valueCell = document.createElement('td');
                        valueCell.className = 'px-3 py-2 text-sm text-gray-700';
                        
                        if (rowData.diff !== undefined) {
                            const valueText = document.createTextNode(rowData.value);
                            valueCell.appendChild(valueText);
                            
                            const diffSpan = document.createElement('span');
                            diffSpan.className = `ml-2 ${rowData.diff >= 0 ? 'text-green-600' : 'text-red-600'}`;
                            diffSpan.textContent = `(${rowData.diff >= 0 ? '+' : ''}${this.formatNumber(rowData.diff * 100, 2)}%)`;
                            valueCell.appendChild(diffSpan);
                        } else {
                            valueCell.textContent = rowData.value;
                        }
                        
                        row.appendChild(valueCell);
                        tbody.appendChild(row);
                    });
                    
                    statsTable.appendChild(tbody);
                    panelContent.appendChild(statsTable);
                    
                    // Impact bar
                    const barContainer = document.createElement('div');
                    barContainer.className = 'mt-3';
                    
                    const barLabels = document.createElement('div');
                    barLabels.className = 'flex justify-between text-xs text-gray-500 mb-1';
                    
                    const startLabel = document.createElement('span');
                    startLabel.textContent = '0% (Base)';
                    barLabels.appendChild(startLabel);
                    
                    const middleLabel = document.createElement('span');
                    middleLabel.textContent = 'Impact';
                    barLabels.appendChild(middleLabel);
                    
                    const endLabel = document.createElement('span');
                    endLabel.textContent = '25%';
                    barLabels.appendChild(endLabel);
                    
                    barContainer.appendChild(barLabels);
                    
                    const barBg = document.createElement('div');
                    barBg.className = 'w-full bg-gray-200 rounded-full h-2.5';
                    
                    const barFill = document.createElement('div');
                    barFill.className = `h-2.5 rounded-full ${featureData.impact < 0 ? 'bg-green-500' : 'bg-red-500'}`;
                    barFill.style.width = `${Math.min(Math.abs(featureData.impact) * 100 * 4, 100)}%`;
                    
                    barBg.appendChild(barFill);
                    barContainer.appendChild(barBg);
                    
                    panelContent.appendChild(barContainer);
                    summaryPanel.appendChild(panelContent);
                }
                
                return summaryPanel;
                
            } catch (error) {
                console.error(`Error creating feature summary for ${title}:`, error);
                return this.createErrorMessage(`Error creating ${title} summary`);
            }
        },
        
        // Create iterations tab with try-catch
        createIterationsTab: function() {
            try {
                // Find selected data
                const selectedData = this.data && this.data.results ? 
                    this.data.results.find(r => r.level === this.state.selectedLevel) : null;
                
                if (!selectedData) {
                    return this.createErrorMessage("No data available for selected level");
                }
                
                const iterationsTab = document.createElement('div');
                iterationsTab.className = 'p-4';
                
                // Simple message if no iterations
                if (!selectedData.allFeatures || !selectedData.allFeatures.iterations || 
                    selectedData.allFeatures.iterations.length === 0) {
                    const noDataMessage = document.createElement('p');
                    noDataMessage.className = 'text-center text-gray-500 my-8';
                    noDataMessage.textContent = 'No iteration data available for this perturbation level.';
                    iterationsTab.appendChild(noDataMessage);
                    return iterationsTab;
                }
                
                // Table container
                const tableContainer = document.createElement('div');
                tableContainer.className = 'overflow-x-auto';
                
                const table = document.createElement('table');
                table.className = 'min-w-full divide-y divide-gray-200';
                
                // Table header
                const thead = document.createElement('thead');
                thead.className = 'bg-gray-50';
                
                const headerRow = document.createElement('tr');
                
                const headers = [
                    { text: 'Iteration', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
                    { text: 'All Features', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
                    { text: 'Feature Subset', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
                    { text: 'Difference', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' }
                ];
                
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.className = header.className;
                    th.textContent = header.text;
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Table body
                const tbody = document.createElement('tbody');
                tbody.className = 'bg-white divide-y divide-gray-200';
                
                // Simple function to handle all output of scores
                const createScoreCell = (score, baseScore, className) => {
                    const cell = document.createElement('td');
                    cell.className = className || 'px-6 py-3 whitespace-nowrap text-sm text-gray-700';
                    
                    if (score === null || score === undefined) {
                        cell.textContent = 'N/A';
                        return cell;
                    }
                    
                    const scoreText = document.createTextNode(this.formatNumber(score));
                    cell.appendChild(scoreText);
                    
                    // Add difference if base score provided
                    if (baseScore !== undefined && baseScore !== null) {
                        const diff = score - baseScore;
                        const diffSpan = document.createElement('span');
                        diffSpan.className = `ml-2 text-xs ${diff >= 0 ? 'text-green-600' : 'text-red-600'}`;
                        diffSpan.textContent = `(${diff >= 0 ? '+' : ''}${this.formatNumber(diff * 100, 2)}%)`;
                        cell.appendChild(diffSpan);
                    }
                    
                    return cell;
                };
                
                // Base score row
                const baseRow = document.createElement('tr');
                baseRow.className = 'bg-gray-100';
                
                const baseIterationCell = document.createElement('td');
                baseIterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
                baseIterationCell.textContent = 'Base';
                baseRow.appendChild(baseIterationCell);
                
                baseRow.appendChild(createScoreCell(
                    selectedData.allFeatures.baseScore, 
                    null,
                    'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900'
                ));
                
                baseRow.appendChild(createScoreCell(
                    selectedData.featureSubset ? selectedData.featureSubset.baseScore : null,
                    null,
                    'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900'
                ));
                
                const baseDifferenceCell = document.createElement('td');
                baseDifferenceCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
                baseDifferenceCell.textContent = '0.0000';
                baseRow.appendChild(baseDifferenceCell);
                
                tbody.appendChild(baseRow);
                
                // Get iteration data
                const allFeaturesIterations = selectedData.allFeatures.iterations || [];
                const featureSubsetIterations = selectedData.featureSubset ? 
                    (selectedData.featureSubset.iterations || []) : [];
                
                const maxIterations = Math.max(allFeaturesIterations.length, featureSubsetIterations.length);
                
                // Create a row for each iteration
                for (let i = 0; i < maxIterations; i++) {
                    const iterationRow = document.createElement('tr');
                    
                    // Iteration number
                    const iterationCell = document.createElement('td');
                    iterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-900';
                    iterationCell.textContent = `#${i + 1}`;
                    iterationRow.appendChild(iterationCell);
                    
                    // All features score
                    const allFeaturesScore = allFeaturesIterations[i] || null;
                    const allFeaturesBaseScore = selectedData.allFeatures.baseScore;
                    iterationRow.appendChild(createScoreCell(
                        allFeaturesScore, 
                        allFeaturesBaseScore,
                        `px-6 py-3 whitespace-nowrap text-sm text-gray-700 ${
                            this.getScoreBgColorClass(allFeaturesScore, allFeaturesBaseScore)
                        }`
                    ));
                    
                    // Feature subset score
                    const featureSubsetScore = featureSubsetIterations[i] || null;
                    const featureSubsetBaseScore = selectedData.featureSubset ? 
                        selectedData.featureSubset.baseScore : null;
                    iterationRow.appendChild(createScoreCell(
                        featureSubsetScore,
                        featureSubsetBaseScore,
                        `px-6 py-3 whitespace-nowrap text-sm text-gray-700 ${
                            this.getScoreBgColorClass(featureSubsetScore, featureSubsetBaseScore)
                        }`
                    ));
                    
                    // Difference between scores
                    if (allFeaturesScore !== null && featureSubsetScore !== null) {
                        const scoreDiff = featureSubsetScore - allFeaturesScore;
                        const differenceCell = document.createElement('td');
                        differenceCell.className = `px-6 py-3 whitespace-nowrap text-sm ${scoreDiff > 0 ? 'text-green-600' : 'text-red-600'}`;
                        differenceCell.textContent = `${scoreDiff > 0 ? '+' : ''}${this.formatNumber(scoreDiff)}`;
                        iterationRow.appendChild(differenceCell);
                    } else {
                        const differenceCell = document.createElement('td');
                        differenceCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-500';
                        differenceCell.textContent = 'N/A';
                        iterationRow.appendChild(differenceCell);
                    }
                    
                    tbody.appendChild(iterationRow);
                }
                
                // Mean row
                if (selectedData.allFeatures.meanScore !== undefined) {
                    const meanRow = document.createElement('tr');
                    meanRow.className = 'bg-gray-100';
                    
                    const meanLabelCell = document.createElement('td');
                    meanLabelCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
                    meanLabelCell.textContent = 'Mean';
                    meanRow.appendChild(meanLabelCell);
                    
                    meanRow.appendChild(createScoreCell(
                        selectedData.allFeatures.meanScore, 
                        null,
                        'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900'
                    ));
                    
                    meanRow.appendChild(createScoreCell(
                        selectedData.featureSubset ? selectedData.featureSubset.meanScore : null,
                        null,
                        'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900'
                    ));
                    
                    if (selectedData.featureSubset && 
                        selectedData.featureSubset.meanScore !== undefined &&
                        selectedData.allFeatures.meanScore !== undefined) {
                        const meanDiff = selectedData.featureSubset.meanScore - selectedData.allFeatures.meanScore;
                        const meanDiffCell = document.createElement('td');
                        meanDiffCell.className = `px-6 py-3 whitespace-nowrap text-sm font-medium ${
                            meanDiff > 0 ? 'text-green-600' : 'text-red-600'
                        }`;
                        meanDiffCell.textContent = `${meanDiff > 0 ? '+' : ''}${this.formatNumber(meanDiff)}`;
                        meanRow.appendChild(meanDiffCell);
                    } else {
                        const meanDiffCell = document.createElement('td');
                        meanDiffCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-500';
                        meanDiffCell.textContent = 'N/A';
                        meanRow.appendChild(meanDiffCell);
                    }
                    
                    tbody.appendChild(meanRow);
                }
                
                table.appendChild(tbody);
                tableContainer.appendChild(table);
                iterationsTab.appendChild(tableContainer);
                
                return iterationsTab;
                
            } catch (error) {
                console.error("Error creating iterations tab:", error);
                return this.createErrorMessage("Error creating iterations tab: " + error.message);
            }
        },
        
        // Create footer with try-catch
        createFooter: function() {
            try {
                const footer = document.createElement('div');
                footer.className = 'p-3 border-t border-gray-200 text-xs text-gray-500';
                
                const footerFlex = document.createElement('div');
                footerFlex.className = 'flex justify-between';
                
                // Left section
                const leftSpan = document.createElement('span');
                if (this.data) {
                    leftSpan.textContent = `Perturbation Test • ${this.data.modelType || 'Model'} • ${this.data.metric || 'Score'} Metric`;
                } else {
                    leftSpan.textContent = 'Perturbation Test';
                }
                footerFlex.appendChild(leftSpan);
                
                // Right section
                const rightSpan = document.createElement('span');
                if (this.data) {
                    rightSpan.textContent = `Base Score: ${this.data.baseScore ? this.formatNumber(this.data.baseScore) : 'N/A'} • Date: ${new Date().toLocaleDateString()}`;
                } else {
                    rightSpan.textContent = `Date: ${new Date().toLocaleDateString()}`;
                }
                footerFlex.appendChild(rightSpan);
                
                footer.appendChild(footerFlex);
                
                return footer;
                
            } catch (error) {
                console.error("Error creating footer:", error);
                const footer = document.createElement('div');
                footer.className = 'p-3 border-t border-gray-200 text-xs text-gray-500';
                footer.textContent = 'Error creating footer';
                return footer;
            }
        }
    };
    
    // Initialize when document is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Check if the container exists
        if (document.getElementById('perturbation-results-container')) {
            // Try to initialize with the safe controller
            try {
                window.SafePerturbationResultsController.init();
                console.log("Safe Perturbation Results Controller initialized");
            } catch (error) {
                console.error("Error initializing SafePerturbationResultsController:", error);
                
                // Create an error message in the container
                const container = document.getElementById('perturbation-results-container');
                if (container) {
                    container.innerHTML = `
                        <div class="p-4 text-center text-red-500 bg-red-50 rounded-lg">
                            <div class="text-2xl mb-2">❌</div>
                            <h3 class="font-bold">Error Loading Perturbation Results</h3>
                            <p class="mt-2">${error.message || 'An unknown error occurred'}</p>
                        </div>
                    `;
                }
            }
        }
    });
})();

// ----- controllers/boxplot.js ----- //
// BoxplotController.js
// Updated version that handles all boxplot functionality
// Last updated: 2024-05-07

const BoxplotController = {
    // Track initialization state
    hasInitialized: false,
    
    /**
     * Initialize the boxplot section
     */
    init: function() {
        console.log("Boxplot section initialized");
        
        if (this.hasInitialized) {
            console.log("BoxplotController already initialized, skipping");
            return;
        }
        
        this.hasInitialized = true;
        
        // Verify if boxplot section is visible
        const boxplotSection = document.getElementById('boxplot');
        if (boxplotSection) {
            console.log("Boxplot section found:", {
                isVisible: boxplotSection.classList.contains('active'),
                display: window.getComputedStyle(boxplotSection).display
            });
            
            // Add listener for tab click to handle lazy loading
            const boxplotTabButton = document.querySelector('[data-tab="boxplot"]');
            if (boxplotTabButton) {
                boxplotTabButton.addEventListener('click', () => {
                    console.log("Boxplot tab clicked, initializing charts");
                    this.initializeCharts();
                    this.populateStatsTable();
                });
            }
            
            // Listen for tab change events
            document.addEventListener('tabchange', (event) => {
                if (event.detail && event.detail.tabId === 'boxplot') {
                    console.log("Tab changed to boxplot");
                    this.initializeCharts();
                    this.populateStatsTable();
                }
            });
        }
        
        // Initialize immediately if tab is active
        if (boxplotSection && boxplotSection.classList.contains('active')) {
            this.initializeCharts();
            this.populateStatsTable();
        }
    },
    
    /**
     * Initialize boxplot chart
     */
    initializeCharts: function() {
        const container = document.getElementById('boxplot-chart-container');
        if (!container) {
            console.error("Boxplot chart container not found");
            return;
        }
        
        // Check if Plotly is loaded
        if (typeof Plotly === 'undefined') {
            console.log("Plotly not available, loading from CDN");
            
            const script = document.createElement('script');
            script.src = 'https://cdn.plot.ly/plotly-2.29.1.min.js';
            script.onload = () => {
                console.log("Plotly loaded successfully, rendering chart");
                this.renderBoxplotChart(container);
            };
            script.onerror = () => {
                console.error("Failed to load Plotly");
                this.showErrorMessage(container, "Biblioteca de visualização Plotly não pôde ser carregada");
            };
            
            document.head.appendChild(script);
        } else {
            // Plotly is already available
            this.renderBoxplotChart(container);
        }
    },
    
    /**
     * Render boxplot chart
     * @param {HTMLElement} container - Chart container element
     */
    renderBoxplotChart: function(container) {
        // Extract data from reportData or chartData
        const boxplotData = this.extractBoxplotData();
        
        if (!boxplotData || !boxplotData.models || boxplotData.models.length === 0) {
            console.error("No data available for boxplot visualization");
            this.showNoDataMessage(container, "Não há dados disponíveis para visualização do boxplot");
            return;
        }
        
        const models = boxplotData.models;
        const traces = [];
        
        // Define consistent colors for models
        const modelColors = {
            'Primary Model': 'rgba(31, 119, 180, 0.7)',
            'primary_model': 'rgba(31, 119, 180, 0.7)',
            'GLM_CLASSIFIER': 'rgba(255, 127, 14, 0.7)',
            'GAM_CLASSIFIER': 'rgba(44, 160, 44, 0.7)',
            'GBM': 'rgba(214, 39, 40, 0.7)',
            'XGB': 'rgba(148, 103, 189, 0.7)',
            'RANDOM_FOREST': 'rgba(140, 86, 75, 0.7)',
            'SVM': 'rgba(227, 119, 194, 0.7)',
            'NEURAL_NETWORK': 'rgba(127, 127, 127, 0.7)'
        };
        
        // Track valid models
        let validModelCount = 0;
        
        // Create traces for each model
        models.forEach(model => {
            // Skip models without real data
            if (!model.scores || model.scores.length === 0) {
                console.error(`Model ${model.name} has no scores, skipping`);
                return;
            }
            
            validModelCount++;
            
            // Clean up model name for display
            const displayName = model.name.replace(/_/g, ' ').trim();
            
            // Get color or generate a deterministic color based on model name
            let color;
            if (modelColors[model.name]) {
                color = modelColors[model.name];
            } else {
                // Generate a deterministic color based on the model name
                const hash = Array.from(model.name).reduce((hash, char) => {
                    return ((hash << 5) - hash) + char.charCodeAt(0);
                }, 0);
                const r = Math.abs(hash) % 200 + 55; // 55-255 range to avoid too dark or light
                const g = Math.abs(hash * 31) % 200 + 55;
                const b = Math.abs(hash * 17) % 200 + 55;
                color = `rgba(${r}, ${g}, ${b}, 0.7)`;
            }
            
            // Create violin plot for model
            traces.push({
                type: 'violin',
                y: model.scores,
                x: Array(model.scores.length).fill(displayName),
                name: displayName,
                box: {
                    visible: true,
                    width: 0.6
                },
                meanline: {
                    visible: true
                },
                line: {
                    color: 'black',
                    width: 1
                },
                fillcolor: color,
                opacity: 0.7,
                points: 'all',
                jitter: 0.3,
                pointpos: 0,
                hoverinfo: 'y+x',
                spanmode: 'soft',
                width: 0.5,
                bandwidth: 0.2
            });
        });
        
        // Add base scores as separate markers
        const baseScoreTrace = {
            type: 'scatter',
            mode: 'markers',
            y: models.map(m => m.baseScore),
            x: models.map(m => m.name.replace(/_/g, ' ').trim()),
            name: 'Base Score',
            marker: {
                size: 12,
                symbol: 'diamond',
                color: models.map(m => modelColors[m.name] || 'rgba(31, 119, 180, 0.7)'),
                line: {
                    color: 'white',
                    width: 1
                }
            },
            text: models.map(m => `Base Score: ${m.baseScore.toFixed(4)}`),
            hoverinfo: 'text+y'
        };
        
        traces.push(baseScoreTrace);
        
        // If no valid models, show error
        if (validModelCount === 0) {
            console.error("No models with valid scores found");
            this.showNoDataMessage(container, "Nenhum modelo possui dados reais para visualização");
            return;
        }
        
        // Get metric name
        const metricName = boxplotData.metricName || 
                           window.reportData?.metric ||
                           'Score';
        
        // Create layout
        const layout = {
            title: {
                text: `Model Performance Distribution - ${metricName}`,
                font: { size: 20 }
            },
            xaxis: {
                title: 'Models',
                tickangle: 0,
                automargin: true
            },
            yaxis: {
                title: metricName,
                zeroline: false,
                autorange: true,
                automargin: true
            },
            autosize: true,
            violinmode: 'group',
            hoverlabel: {
                bgcolor: "#FFF",
                font: { size: 12 },
                bordercolor: "#333"
            },
            showlegend: true,
            legend: {
                orientation: "h",
                yanchor: "top",
                y: 1.1,
                xanchor: "right",
                x: 1
            },
            hovermode: 'closest',
            margin: {
                l: 50,
                r: 20,
                t: 60,
                b: 80
            },
            annotations: [{
                xref: 'paper',
                yref: 'paper',
                x: 0,
                y: -0.15,
                text: 'The boxplots show model performance distribution under perturbation tests. Diamond markers indicate base scores.',
                showarrow: false,
                font: { size: 12 }
            }]
        };
        
        try {
            // Render the visualization
            Plotly.newPlot(container, traces, layout, {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                displaylogo: false,
                staticPlot: false,
                toImageButtonOptions: {
                    format: 'png',
                    filename: 'model_comparison_boxplot',
                    height: 700,
                    width: 1000,
                    scale: 2
                }
            }).then(() => {
                console.log("Boxplot chart successfully rendered");
                
                // Force a resize event to ensure proper layout
                window.dispatchEvent(new Event('resize'));
            }).catch(error => {
                console.error("Plotly.newPlot failed:", error);
                this.showErrorMessage(container, `Error rendering boxplot: ${error.message}`);
            });
        } catch (error) {
            console.error("Exception during Plotly.newPlot:", error);
            this.showErrorMessage(container, `Error rendering boxplot: ${error.message}`);
        }
    },
    
    /**
     * Extract boxplot data from report data
     * @returns {Object} Data for boxplot chart
     */
    extractBoxplotData: function() {
        try {
            // First check if we have processed boxplot data
            if (window.reportData && window.reportData.boxplot_data && window.reportData.boxplot_data.models) {
                console.log("Using server-prepared boxplot data");
                
                // Filter models to only include those with real data
                const validModels = window.reportData.boxplot_data.models.filter(model => 
                    model.scores && model.scores.length > 0
                );
                
                // Return null if no valid models
                if (validModels.length === 0) {
                    console.error("No models with valid scores found in boxplot_data");
                    return null;
                }
                
                return {
                    models: validModels,
                    metricName: window.reportData.metric || 'Score'
                };
            }
            
            // If no boxplot_data, try to extract from raw results
            console.log("No pre-processed boxplot data found, extracting from raw results");
            
            if (!window.reportData || !window.reportData.raw || !window.reportData.raw.by_level) {
                console.warn("No raw data available for boxplot extraction");
                return null;
            }
            
            // Get metric name
            const metricName = window.reportData.metric || 'Score';
            console.log(`Using metric: ${metricName}`);
            
            // Extract primary model data
            const primaryModelData = {
                name: window.reportData.model_name || 'Primary Model',
                modelType: window.reportData.model_type || 'Unknown',
                baseScore: window.reportData.base_score || 0,
                scores: []
            };
            
            // Extract iteration scores from each perturbation level
            const rawData = window.reportData.raw.by_level;
            Object.keys(rawData).forEach(level => {
                const levelData = rawData[level];
                
                if (!levelData.runs || !levelData.runs.all_features) {
                    console.log(`Level ${level}: No runs data found`);
                    return;
                }
                
                // Extract scores from all runs at this level
                levelData.runs.all_features.forEach(run => {
                    if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                        console.log(`Level ${level}: Found ${run.iterations.scores.length} iteration scores`);
                        primaryModelData.scores.push(...run.iterations.scores);
                    }
                });
            });
            
            console.log(`Primary model: extracted ${primaryModelData.scores.length} total scores`);
            
            // Se não temos scores reais para o modelo primário, não gerar dados sintéticos
            if (primaryModelData.scores.length === 0) {
                console.error("Nenhum score real encontrado para o modelo primário. Não serão gerados dados sintéticos.");
                // We keep the array empty - no synthetic data
            }
            
            const models = [];
            models.push(primaryModelData);
            
            // Extract alternative models data
            if (window.reportData.alternative_models) {
                console.log("Processing alternative models:", Object.keys(window.reportData.alternative_models));
                
                Object.keys(window.reportData.alternative_models).forEach(modelName => {
                    const modelData = window.reportData.alternative_models[modelName];
                    console.log(`Processing alternative model ${modelName}, data keys:`, Object.keys(modelData));
                    
                    const altModelData = {
                        name: modelName,
                        modelType: modelData.model_type || 'Unknown',
                        baseScore: modelData.base_score || 0,
                        scores: []
                    };
                    
                    // Extract scores from alternative model's raw data
                    if (modelData.raw && modelData.raw.by_level) {
                        Object.keys(modelData.raw.by_level).forEach(level => {
                            const levelData = modelData.raw.by_level[level];
                            
                            if (levelData.runs && levelData.runs.all_features) {
                                levelData.runs.all_features.forEach(run => {
                                    if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                                        console.log(`Found ${run.iterations.scores.length} scores for model ${modelName} at level ${level}`);
                                        altModelData.scores.push(...run.iterations.scores);
                                    }
                                });
                            } else if (levelData.overall_result && levelData.overall_result.all_features) {
                                const score = levelData.overall_result.all_features.mean_score;
                                if (score !== undefined) {
                                    console.log(`Using mean_score ${score} from overall_result for level ${level}`);
                                    altModelData.scores.push(score);
                                }
                            }
                        });
                    }
                    
                    console.log(`Alternative model ${modelName}: extracted ${altModelData.scores.length} scores`);
                    
                    // Se não há scores para o modelo alternativo, mostrar erro e não gerar dados sintéticos
                    if (altModelData.scores.length === 0) {
                        console.error(`Nenhum score encontrado para o modelo alternativo ${modelName}. Não serão gerados dados sintéticos.`);
                        // We keep the array empty - no synthetic data
                    }
                    
                    models.push(altModelData);
                });
            }
            
            // Se não houver modelos com scores, não gerar dados sintéticos
            if (models.length === 0 || !models.some(m => m.scores && m.scores.length > 0)) {
                console.error("Nenhum modelo com scores foi encontrado. Não serão criados dados sintéticos.");
                return null;
            }
            
            console.log(`Extracted data for ${models.length} models`);
            return { models, metricName };
        } catch (error) {
            console.error("Error extracting boxplot data:", error);
            return null; // Não gerar dados sintéticos em caso de erro
        }
    },
    
    /**
     * Populate the statistics table with model data
     */
    populateStatsTable: function() {
        const tableBody = document.getElementById('boxplot-table-body');
        if (!tableBody) return;
        
        try {
            // Clear existing content
            tableBody.innerHTML = '';
            
            // Get boxplot data
            const boxplotData = this.extractBoxplotData();
            if (!boxplotData || !boxplotData.models || boxplotData.models.length === 0) {
                this.showNoTableData(tableBody);
                return;
            }
            
            // Add rows for each model
            boxplotData.models.forEach(model => {
                // Skip models without real data
                if (!model.scores || model.scores.length === 0) return;
                
                // Sort scores for statistics
                const sortedScores = model.scores.slice().sort((a, b) => a - b);
                
                // Calculate basic stats
                const mean = sortedScores.reduce((a, b) => a + b, 0) / sortedScores.length;
                
                // Calculate median
                const mid = Math.floor(sortedScores.length / 2);
                const median = sortedScores.length % 2 === 0 ? 
                    (sortedScores[mid - 1] + sortedScores[mid]) / 2 : 
                    sortedScores[mid];
                
                // Calculate quartiles for IQR
                const q1Index = Math.floor(sortedScores.length * 0.25);
                const q3Index = Math.floor(sortedScores.length * 0.75);
                const q1 = sortedScores[q1Index] || 0;
                const q3 = sortedScores[q3Index] || 0;
                const iqr = q3 - q1;
                
                // Calculate min, max
                const min = sortedScores[0] || 0;
                const max = sortedScores[sortedScores.length - 1] || 0;
                
                // Calculate standard deviation
                let stdDev = 0;
                if (sortedScores.length > 1) {
                    const squaredDiffs = sortedScores.map(val => Math.pow(val - mean, 2));
                    const variance = squaredDiffs.reduce((a, b) => a + b, 0) / sortedScores.length;
                    stdDev = Math.sqrt(variance);
                }
                
                // Create row
                const row = document.createElement('tr');
                
                // Model name - replace all underscores with spaces
                const nameCell = document.createElement('td');
                const displayName = model.name.replace(/_/g, ' ');
                nameCell.textContent = displayName || "Unknown Model";
                nameCell.style.fontWeight = 'bold';
                
                // Highlight primary model
                if (model.name === window.reportData?.model_name || model.name === 'Primary Model') {
                    nameCell.style.color = '#1b78de';
                }
                
                row.appendChild(nameCell);
                
                // Base score
                const baseScoreCell = document.createElement('td');
                baseScoreCell.textContent = model.baseScore ? model.baseScore.toFixed(4) : "N/A";
                row.appendChild(baseScoreCell);
                
                // Median
                const medianCell = document.createElement('td');
                medianCell.textContent = median.toFixed(4);
                row.appendChild(medianCell);
                
                // Mean
                const meanCell = document.createElement('td');
                meanCell.textContent = mean.toFixed(4);
                row.appendChild(meanCell);
                
                // IQR
                const iqrCell = document.createElement('td');
                iqrCell.textContent = iqr.toFixed(4);
                row.appendChild(iqrCell);
                
                // Min
                const minCell = document.createElement('td');
                minCell.textContent = min.toFixed(4);
                row.appendChild(minCell);
                
                // Max
                const maxCell = document.createElement('td');
                maxCell.textContent = max.toFixed(4);
                row.appendChild(maxCell);
                
                // Std Dev
                const stdDevCell = document.createElement('td');
                stdDevCell.textContent = stdDev.toFixed(4);
                row.appendChild(stdDevCell);
                
                // Score drop
                const dropCell = document.createElement('td');
                const baseScore = model.baseScore || 0;
                const dropPercent = (baseScore > 0) ? ((baseScore - median) / baseScore) * 100 : 0;
                dropCell.textContent = dropPercent.toFixed(2) + '%';
                dropCell.className = dropPercent > 5 ? 'text-danger' : (dropPercent > 2 ? 'text-warning' : 'text-success');
                row.appendChild(dropCell);
                
                tableBody.appendChild(row);
            });
        } catch (error) {
            console.error("Error populating stats table:", error);
            this.showTableError(tableBody);
        }
    },
    
    /**
     * Show no data message in container
     * @param {HTMLElement} container - Chart container
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(container, message) {
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados não disponíveis</h3>
                <p style="color: #333; font-size: 16px; line-height: 1.4;">${message}</p>
                <p style="color: #333; margin-top: 20px; font-size: 14px;">
                    Execute testes de robustez com iterações (n_iterations > 1) para visualizar dados reais.
                </p>
            </div>`;
    },
    
    /**
     * Show error message in container
     * @param {HTMLElement} container - Chart container
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(container, errorMessage) {
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
            </div>`;
    },
    
    /**
     * Show no data message in table
     * @param {HTMLElement} tableBody - Table body element
     */
    showNoTableData: function(tableBody) {
        tableBody.innerHTML = `
            <tr>
                <td colspan="9" class="text-center">
                    <div class="loading-info">
                        <div class="loading-icon">⚠️</div>
                        <p>Dados de distribuição não disponíveis para modelos.</p>
                        <p>Execute testes com iterações (n_iterations > 1) para visualizar estatísticas.</p>
                    </div>
                </td>
            </tr>`;
    },
    
    /**
     * Show error message in table
     * @param {HTMLElement} tableBody - Table body element
     */
    showTableError: function(tableBody) {
        tableBody.innerHTML = `
            <tr>
                <td colspan="9" class="text-center">
                    <div class="loading-info">
                        <div class="loading-icon">⚠️</div>
                        <p>Erro ao carregar estatísticas dos modelos.</p>
                    </div>
                </td>
            </tr>`;
    }
};

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    BoxplotController.init();
});

// ----- controllers/details.js ----- //
/**
 * Overview Controller
 * Handles data and UI interactions for the model overview page
 */
window.OverviewController = {
    /**
     * Initialize the controller
     */
    init: function() {
        console.log("OverviewController initialized");
        
        // Load model data
        this.loadModelData();
        
        // Initialize the model selector
        this.initializeModelSelector();
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Initialize charts
        this.initializeCharts();
        
        // Update the dataset info
        this.updateDatasetInfo();
        
        // Fill the models table
        this.fillModelsTable();
        
        console.log("Overview page initialization complete");
    },
    
    /**
     * Load model data from global variables
     */
    loadModelData: function() {
        console.log("Loading model data");
        this.modelData = {};
        this.configData = {};
        
        // Try initial_results data first (from transformer)
        if (window.reportData && window.reportData.initial_results) {
            console.log("Found initial_results data:", Object.keys(window.reportData.initial_results).join(', '));
            if (window.reportData.initial_results.models) {
                this.modelData = window.reportData.initial_results.models;
                this.configData = window.reportData.initial_results.config || {};
                console.log("Using data from initial_results, found models:", Object.keys(this.modelData).length);
            }
        } 
        // Try chart_data.initial_results
        else if (window.chartData && window.chartData.initial_results) {
            console.log("Found initial_results in chartData");
            if (window.chartData.initial_results.models) {
                this.modelData = window.chartData.initial_results.models;
                this.configData = window.chartData.initial_results.config || {};
                console.log("Using data from chartData.initial_results, found models:", Object.keys(this.modelData).length);
            }
        }
        // Try radar_chart_data
        else if (window.chartData && window.chartData.radar_chart_data) {
            console.log("Found radar_chart_data");
            if (window.chartData.radar_chart_data.models) {
                this.modelData = window.chartData.radar_chart_data.models;
                console.log("Using data from radar_chart_data, found models:", Object.keys(this.modelData).length);
            }
        }
        // Try generic model data
        else if (window.reportData) {
            this.modelData = window.reportData.models || {};
            this.configData = window.reportData.config || {};
            console.log("Using data from reportData");
        } else if (window.chartData) {
            this.modelData = window.chartData.models || {};
            this.configData = window.chartData.config || {};
            console.log("Using data from chartData");
        } else if (window.config) {
            this.modelData = window.config.models || {};
            this.configData = window.config;
            console.log("Using data from config");
        } else {
            console.warn("No model data found in any data source");
        }
        
        // Debug the data that was found
        console.log("Model data keys:", Object.keys(this.modelData));
        if (Object.keys(this.modelData).length > 0) {
            const firstModel = Object.values(this.modelData)[0];
            console.log("First model data:", JSON.stringify(firstModel).substring(0, 200) + "...");
        }
        
        // Check if we have model data
        if (Object.keys(this.modelData).length === 0) {
            console.warn("Empty model data");
            this.showDataError("Não foi possível carregar dados de modelos.");
        } else {
            console.log("Loaded data for", Object.keys(this.modelData).length, "models");
        }
    },
    
    /**
     * Initialize the model selector dropdown
     */
    initializeModelSelector: function() {
        console.log("Initializing model selector");
        const selector = document.getElementById('model-selector');
        if (!selector) {
            console.error("Model selector element not found");
            return;
        }
        
        // Keep the 'all' option as first choice
        let options = ['<option value="all">Todos os Modelos</option>'];
        
        // Add options for each model
        Object.entries(this.modelData).forEach(([key, model]) => {
            options.push(`<option value="${key}">${model.name} (${model.type})</option>`);
        });
        
        // Update selector options
        selector.innerHTML = options.join('');
        
        console.log("Model selector initialized with", Object.keys(this.modelData).length, "models");
    },
    
    /**
     * Set up event listeners for UI interactions
     */
    setupEventListeners: function() {
        console.log("Setting up event listeners");
        
        // Model selector change event
        const selector = document.getElementById('model-selector');
        if (selector) {
            selector.addEventListener('change', (e) => {
                const modelId = e.target.value;
                this.handleModelSelection(modelId);
            });
        }
        
        // Table header sort event
        const headers = document.querySelectorAll('.data-table th.sortable');
        if (headers.length > 0) {
            headers.forEach(header => {
                header.addEventListener('click', (e) => {
                    const sortBy = e.currentTarget.getAttribute('data-sort');
                    this.sortModelsTable(sortBy);
                });
            });
        }
        
        // Tab navigation
        const tabLinks = document.querySelectorAll('.main-nav a');
        if (tabLinks.length > 0) {
            tabLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const tabId = e.currentTarget.getAttribute('data-tab');
                    this.switchTab(tabId);
                });
            });
        }
        
        console.log("Event listeners setup complete");
    },
    
    /**
     * Initialize charts on the overview page
     */
    initializeCharts: function() {
        console.log("Initializing overview charts");
        
        // Use the chart manager to initialize charts
        if (typeof window.OverviewChartsManager !== 'undefined' && 
            typeof window.OverviewChartsManager.initializeOverviewCharts === 'function') {
            window.OverviewChartsManager.initializeOverviewCharts();
        } else {
            console.error("OverviewChartsManager not available");
        }
    },
    
    /**
     * Update dataset info in the UI
     */
    updateDatasetInfo: function() {
        console.log("Updating dataset info");
        
        // Get dataset info elements
        const samplesElement = document.getElementById('n-samples');
        const featuresElement = document.getElementById('n-features');
        const testSizeElement = document.getElementById('test-size');
        
        // Get test info elements
        const testsListElement = document.getElementById('tests-list');
        const verboseElement = document.getElementById('verbose-status');
        
        // Check if we have dataset info
        if (this.configData && this.configData.dataset_info) {
            const datasetInfo = this.configData.dataset_info;
            
            // Update dataset info
            if (samplesElement) {
                samplesElement.textContent = datasetInfo.n_samples || 'N/A';
            }
            
            if (featuresElement) {
                featuresElement.textContent = datasetInfo.n_features || 'N/A';
            }
            
            if (testSizeElement && datasetInfo.test_size !== undefined) {
                testSizeElement.textContent = (datasetInfo.test_size * 100) + '%';
            }
        } else {
            console.warn("No dataset info available");
            
            // Set placeholders
            if (samplesElement) samplesElement.textContent = 'N/A';
            if (featuresElement) featuresElement.textContent = 'N/A';
            if (testSizeElement) testSizeElement.textContent = 'N/A';
        }
        
        // Check if we have test config info
        if (this.configData && this.configData.tests) {
            // Update test info
            if (testsListElement) {
                testsListElement.textContent = this.configData.tests.join(', ');
            }
            
            if (verboseElement) {
                verboseElement.textContent = this.configData.verbose ? 'Sim' : 'Não';
            }
        } else {
            console.warn("No test config info available");
            
            // Set placeholders
            if (testsListElement) testsListElement.textContent = 'N/A';
            if (verboseElement) verboseElement.textContent = 'N/A';
        }
        
        console.log("Dataset info updated");
    },
    
    /**
     * Fill the models comparison table
     */
    fillModelsTable: function() {
        console.log("Filling models table");
        
        const tableBody = document.getElementById('models-table-body');
        if (!tableBody) {
            console.error("Models table body element not found");
            return;
        }
        
        // Check if we have model data
        if (Object.keys(this.modelData).length === 0) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="7" class="empty-table-message">
                        Não foram encontrados dados de modelos para exibir.
                    </td>
                </tr>`;
            return;
        }
        
        // Convert model data to array for sorting
        const modelsArray = Object.entries(this.modelData).map(([key, model]) => ({
            id: key,
            name: model.name || key,
            type: model.type || 'Desconhecido',
            metrics: model.metrics || {}
        }));
        
        // Sort by model name by default
        modelsArray.sort((a, b) => a.name.localeCompare(b.name));
        
        // Generate table rows HTML
        const rows = modelsArray.map(model => {
            const metrics = model.metrics || {};
            
            return `
                <tr data-model-id="${model.id}">
                    <td>${model.name}</td>
                    <td>${model.type}</td>
                    <td class="numeric">${this.formatMetric(metrics.accuracy)}</td>
                    <td class="numeric">${this.formatMetric(metrics.roc_auc)}</td>
                    <td class="numeric">${this.formatMetric(metrics.f1)}</td>
                    <td class="numeric">${this.formatMetric(metrics.precision)}</td>
                    <td class="numeric">${this.formatMetric(metrics.recall)}</td>
                </tr>`;
        }).join('');
        
        // Update table body
        tableBody.innerHTML = rows;
        
        console.log("Models table filled with", modelsArray.length, "models");
    },
    
    /**
     * Format metric value for display
     * @param {number} value - Metric value
     * @returns {string} - Formatted value
     */
    formatMetric: function(value) {
        if (value === undefined || value === null) {
            return 'N/A';
        }
        return value.toFixed(4);
    },
    
    /**
     * Handle model selection change
     * @param {string} modelId - Selected model ID
     */
    handleModelSelection: function(modelId) {
        console.log("Model selection changed to:", modelId);
        
        // Highlight selected model in the table
        const tableRows = document.querySelectorAll('#models-table-body tr');
        tableRows.forEach(row => {
            if (modelId === 'all' || row.getAttribute('data-model-id') === modelId) {
                row.classList.remove('inactive-row');
            } else {
                row.classList.add('inactive-row');
            }
        });
        
        // You could refresh charts here based on selection
        // For example:
        // this.refreshMetricsChart(modelId);
    },
    
    /**
     * Sort the models table by the specified column
     * @param {string} sortBy - Column to sort by
     */
    sortModelsTable: function(sortBy) {
        console.log("Sorting table by:", sortBy);
        
        // Reset sort indicators on all header cells
        document.querySelectorAll('#models-table th.sortable').forEach(header => {
            header.classList.remove('sort-asc', 'sort-desc');
        });
        
        // Get the header element for the sorted column
        const header = document.querySelector(`#models-table th[data-sort="${sortBy}"]`);
        
        // Determine sort direction
        let sortDirection = 'asc';
        if (header.classList.contains('sort-asc')) {
            sortDirection = 'desc';
        }
        
        // Set sort indicator on active column
        header.classList.add(`sort-${sortDirection}`);
        
        // Convert model data to array for sorting
        const modelsArray = Object.entries(this.modelData).map(([key, model]) => ({
            id: key,
            name: model.name || key,
            type: model.type || 'Desconhecido',
            metrics: model.metrics || {}
        }));
        
        // Sort the array
        modelsArray.sort((a, b) => {
            let valueA, valueB;
            
            if (sortBy === 'name') {
                valueA = a.name;
                valueB = b.name;
                return sortDirection === 'asc' ? 
                    valueA.localeCompare(valueB) : 
                    valueB.localeCompare(valueA);
            } else if (sortBy === 'type') {
                valueA = a.type;
                valueB = b.type;
                return sortDirection === 'asc' ? 
                    valueA.localeCompare(valueB) : 
                    valueB.localeCompare(valueA);
            } else {
                // Assume it's a metric
                valueA = a.metrics[sortBy] || 0;
                valueB = b.metrics[sortBy] || 0;
                return sortDirection === 'asc' ? 
                    valueA - valueB : 
                    valueB - valueA;
            }
        });
        
        // Generate table rows HTML
        const rows = modelsArray.map(model => {
            const metrics = model.metrics || {};
            
            return `
                <tr data-model-id="${model.id}">
                    <td>${model.name}</td>
                    <td>${model.type}</td>
                    <td class="numeric">${this.formatMetric(metrics.accuracy)}</td>
                    <td class="numeric">${this.formatMetric(metrics.roc_auc)}</td>
                    <td class="numeric">${this.formatMetric(metrics.f1)}</td>
                    <td class="numeric">${this.formatMetric(metrics.precision)}</td>
                    <td class="numeric">${this.formatMetric(metrics.recall)}</td>
                </tr>`;
        }).join('');
        
        // Update table body
        const tableBody = document.getElementById('models-table-body');
        if (tableBody) {
            tableBody.innerHTML = rows;
        }
        
        // Reapply model filter if needed
        const selectedModel = document.getElementById('model-selector').value;
        if (selectedModel !== 'all') {
            this.handleModelSelection(selectedModel);
        }
    },
    
    /**
     * Switch between tabs
     * @param {string} tabId - ID of the tab to switch to
     */
    switchTab: function(tabId) {
        console.log("Switching to tab:", tabId);
        
        // Update tab links
        document.querySelectorAll('.main-nav li').forEach(tab => {
            if (tab.querySelector(`a[data-tab="${tabId}"]`)) {
                tab.classList.add('active');
            } else {
                tab.classList.remove('active');
            }
        });
        
        // Update tab contents
        document.querySelectorAll('.tab-content').forEach(content => {
            if (content.id === tabId) {
                content.classList.add('active');
            } else {
                content.classList.remove('active');
            }
        });
        
        // Dispatch custom event for tab change
        const event = new CustomEvent('tabchange', {
            detail: { tabId: tabId }
        });
        document.dispatchEvent(event);
    },
    
    /**
     * Show error message when data cannot be loaded
     * @param {string} message - Error message
     */
    showDataError: function(message) {
        console.error("Data error:", message);
        
        // Find container elements to show the error
        const chartContainer = document.getElementById('metrics-radar-chart');
        const tableBody = document.getElementById('models-table-body');
        
        // Show error in chart container
        if (chartContainer) {
            chartContainer.innerHTML = `
                <div class="error-container">
                    <div class="error-icon">⚠️</div>
                    <h3 class="error-title">Erro ao Carregar Dados</h3>
                    <p class="error-message">${message}</p>
                </div>`;
        }
        
        // Show error in table
        if (tableBody) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="7" class="empty-table-message">
                        ${message}
                    </td>
                </tr>`;
        }
    }
};

// Initialize controller when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Small delay to ensure other scripts are loaded
    setTimeout(function() {
        if (typeof OverviewController !== 'undefined' && 
            typeof OverviewController.init === 'function') {
            OverviewController.init();
        } else {
            console.error("OverviewController not available");
        }
    }, 100);
});

// ----- controllers/features.js ----- //
/**
 * Feature Importance Controller
 * Handles feature importance visualization and data management
 */
window.FeatureImportanceController = {
    /**
     * Initialize the controller
     */
    init: function() {
        console.log("FeatureImportanceController initialized");
        
        // Initialize the feature importance table
        this.initializeFeatureTable();
        
        // Set up event listeners for feature table interactions
        this.setupTableEvents();
        
        // Initialize feature charts when tab is active
        document.addEventListener('tabchange', (event) => {
            if (event.detail && event.detail.tabId === 'feature_impact') {
                console.log("Feature impact tab activated");
                this.refreshFeatureData();
            }
        });
    },
    
    /**
     * Initialize the feature importance table
     */
    initializeFeatureTable: function() {
        console.log("Initializing feature importance table");
        this.fillFeatureImportanceTable();
        
        // Update feature counts
        this.updateFeatureCounts();
    },
    
    /**
     * Set up event listeners for table interactions
     */
    setupTableEvents: function() {
        // Sort table when headers are clicked
        const headers = document.querySelectorAll('.feature-importance-table th.sortable');
        if (headers.length > 0) {
            headers.forEach(header => {
                header.addEventListener('click', (e) => {
                    const sortBy = e.currentTarget.getAttribute('data-sort');
                    this.sortTable(sortBy);
                });
            });
        }
        
        // Search feature table
        const searchInput = document.getElementById('feature-search');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                this.filterTable();
            });
        }
        
        // Toggle feature subset display
        const subsetToggle = document.getElementById('show-subset-only');
        if (subsetToggle) {
            subsetToggle.addEventListener('change', (e) => {
                this.filterTable();
            });
        }
    },
    
    /**
     * Fill the feature importance table with data
     */
    fillFeatureImportanceTable: function() {
        console.log("Filling feature importance table");
        
        // Get feature data from the table manager
        const featureData = FeatureImportanceTableManager.extractFeatureData();
        
        if (featureData.length === 0) {
            console.warn("No feature importance data available");
            this.showNoDataMessage();
            return;
        }
        
        // Sort by default column (impact/robustness)
        const sortedData = FeatureImportanceTableManager.sortData(featureData, 'impact', 'desc');
        
        // Generate table HTML
        const tableHTML = FeatureImportanceTableManager.generateTableRows(sortedData);
        
        // Update table content
        const tableBody = document.getElementById('feature-impact-data');
        if (tableBody) {
            tableBody.innerHTML = tableHTML;
        }
        
        // Log success
        console.log(`Feature table populated with ${featureData.length} features`);
    },
    
    /**
     * Show a message when no data is available
     */
    showNoDataMessage: function() {
        const tableBody = document.getElementById('feature-impact-data');
        if (tableBody) {
            tableBody.innerHTML = FeatureImportanceTableManager.generateNoDataMessage();
        }
    },
    
    /**
     * Sort the feature table by the specified column
     * @param {string} sortBy - Column to sort by
     */
    sortTable: function(sortBy) {
        // Reset sort indicators on all header cells
        document.querySelectorAll('.feature-importance-table th.sortable .sort-indicator')
            .forEach(indicator => indicator.textContent = '');
        
        // Set sort indicator on active column
        const activeHeader = document.querySelector(`.feature-importance-table th[data-sort="${sortBy}"]`);
        if (activeHeader) {
            activeHeader.querySelector('.sort-indicator').textContent = '▼';
        }
        
        // Get and sort feature data
        const featureData = FeatureImportanceTableManager.extractFeatureData();
        const sortedData = FeatureImportanceTableManager.sortData(featureData, sortBy, 'desc');
        
        // Generate and update table HTML
        const tableBody = document.getElementById('feature-impact-data');
        if (tableBody) {
            tableBody.innerHTML = FeatureImportanceTableManager.generateTableRows(sortedData);
        }
        
        console.log(`Table sorted by ${sortBy}`);
    },
    
    /**
     * Filter the feature table by search term and subset option
     */
    filterTable: function() {
        const searchTerm = document.getElementById('feature-search').value;
        const showOnlySubset = document.getElementById('show-subset-only').checked;
        
        // Get feature data
        const featureData = FeatureImportanceTableManager.extractFeatureData();
        
        // Filter data
        const filteredData = FeatureImportanceTableManager.filterData(featureData, searchTerm, showOnlySubset);
        
        // Get current sort column
        const activeHeader = document.querySelector('.feature-importance-table th.sortable .sort-indicator');
        const sortBy = activeHeader && activeHeader.parentElement.getAttribute('data-sort') || 'impact';
        
        // Sort filtered data
        const sortedData = FeatureImportanceTableManager.sortData(filteredData, sortBy, 'desc');
        
        // Update table
        const tableBody = document.getElementById('feature-impact-data');
        if (tableBody) {
            tableBody.innerHTML = FeatureImportanceTableManager.generateTableRows(sortedData);
        }
        
        console.log(`Table filtered with ${filteredData.length} of ${featureData.length} features visible`);
        
        // Update feature counts to reflect filtered data
        this.updateFeatureCountsWithData(filteredData, featureData);
    },
    
    /**
     * Update feature count displays in the UI
     */
    updateFeatureCounts: function() {
        const featureData = FeatureImportanceTableManager.extractFeatureData();
        this.updateFeatureCountsWithData(featureData, featureData);
    },
    
    /**
     * Update feature count displays with specific data
     * @param {Array} visibleData - Currently visible feature data
     * @param {Array} totalData - All feature data
     */
    updateFeatureCountsWithData: function(visibleData, totalData) {
        const totalFeaturesElement = document.getElementById('total-features-count');
        const subsetFeaturesElement = document.getElementById('subset-features-count');
        
        if (totalFeaturesElement) {
            totalFeaturesElement.textContent = visibleData.length;
        }
        
        if (subsetFeaturesElement) {
            const subsetCount = visibleData.filter(item => item.inSubset).length;
            subsetFeaturesElement.textContent = subsetCount;
        }
    },
    
    /**
     * Refresh feature data and update visualizations
     */
    refreshFeatureData: function() {
        // Reinitialize table with fresh data
        this.fillFeatureImportanceTable();
        
        // Also refresh charts if needed
        if (typeof window.ChartInitializer !== 'undefined' && 
            typeof window.ChartInitializer.initializeFeatureCharts === 'function') {
            window.ChartInitializer.initializeFeatureCharts();
        }
    }
};

// Manual initialization to ensure it runs
document.addEventListener('DOMContentLoaded', function() {
    // Delay initialization slightly to ensure other dependencies are loaded
    setTimeout(function() {
        if (typeof FeatureImportanceController !== 'undefined' && 
            typeof FeatureImportanceController.init === 'function') {
            FeatureImportanceController.init();
        }
    }, 100);
});

// ----- controllers/featuresTable.js ----- //
// Feature Importance Table Controller
window.FeatureImportanceTableController = {
    // State management
    state: {
        sortConfig: { key: 'impact', direction: 'desc' },
        searchTerm: '',
        showOnlySubset: false,
        hoveredRow: null,
        allData: [],
        filteredData: []
    },
    
    /**
     * Initialize the feature importance table
     */
    init: function() {
        console.log("Feature Importance Table initialized");
        
        // Get table elements
        this.tableElement = document.querySelector('.feature-importance-table');
        this.tableBody = document.getElementById('feature-impact-data');
        this.tableFooter = document.querySelector('.feature-importance-footer');
        this.searchInput = document.getElementById('feature-search');
        this.subsetToggle = document.getElementById('show-subset-only');
        this.totalCountEl = document.getElementById('total-features-count');
        this.subsetCountEl = document.getElementById('subset-features-count');
        
        // Check if required elements exist
        if (!this.tableBody) {
            console.error("Required table elements not found");
            return;
        }
        
        // Load initial data
        this.loadData();
        
        // Initialize event listeners
        this.initEventListeners();
        
        // Render the table
        this.renderTable();
    },
    
    /**
     * Load feature data from the report
     */
    loadData: function() {
        try {
            // Extract data using the manager
            this.state.allData = FeatureImportanceTableManager.extractFeatureData();
            
            // Apply initial sorting and filtering
            this.updateFilteredData();
            
            console.log(`Loaded ${this.state.allData.length} features in controller`);
        } catch (error) {
            console.error("Error loading feature data:", error);
            this.state.allData = [];
            this.state.filteredData = [];
        }
    },
    
    /**
     * Set up event listeners for the table
     */
    initEventListeners: function() {
        // Set up column header sorting
        if (this.tableElement) {
            const headers = this.tableElement.querySelectorAll('th.sortable');
            headers.forEach(header => {
                const key = header.getAttribute('data-sort');
                if (key) {
                    header.addEventListener('click', () => this.handleSort(key));
                }
            });
        }
        
        // Set up search input
        if (this.searchInput) {
            this.searchInput.addEventListener('input', (e) => {
                this.state.searchTerm = e.target.value;
                this.updateFilteredData();
                this.renderTable();
            });
        }
        
        // Set up subset toggle
        if (this.subsetToggle) {
            this.subsetToggle.addEventListener('change', (e) => {
                this.state.showOnlySubset = e.target.checked;
                this.updateFilteredData();
                this.renderTable();
            });
        }
        
        // Set up row hover effects (using event delegation)
        if (this.tableBody) {
            this.tableBody.addEventListener('mouseover', (e) => {
                const row = e.target.closest('tr[data-feature]');
                if (row) {
                    const feature = row.getAttribute('data-feature');
                    this.state.hoveredRow = feature;
                    this.highlightRow(feature);
                }
            });
            
            this.tableBody.addEventListener('mouseout', () => {
                this.state.hoveredRow = null;
                this.clearRowHighlights();
            });
        }
    },
    
    /**
     * Handle column sorting
     * @param {string} key - Key to sort by
     */
    handleSort: function(key) {
        const { sortConfig } = this.state;
        const direction = 
            sortConfig.key === key && sortConfig.direction === 'desc' ? 'asc' : 'desc';
        
        this.state.sortConfig = { key, direction };
        this.updateFilteredData();
        this.renderTable();
        
        // Update sort indicators
        this.updateSortIndicators(key, direction);
    },
    
    /**
     * Update filtered and sorted data based on current state
     */
    updateFilteredData: function() {
        const { allData, sortConfig, searchTerm, showOnlySubset } = this.state;
        
        // First filter the data
        const filtered = FeatureImportanceTableManager.filterData(
            allData, 
            searchTerm, 
            showOnlySubset
        );
        
        // Then sort the filtered data
        this.state.filteredData = FeatureImportanceTableManager.sortData(
            filtered,
            sortConfig.key,
            sortConfig.direction
        );
    },
    
    /**
     * Render the table with current data
     */
    renderTable: function() {
        if (!this.tableBody) return;
        
        try {
            const { filteredData, allData, hoveredRow } = this.state;
            
            // Generate and insert rows
            this.tableBody.innerHTML = FeatureImportanceTableManager.generateTableRows(filteredData, hoveredRow);
            
            // Update feature counts
            this.updateFeatureCounts();
            
        } catch (error) {
            console.error("Error rendering feature table:", error);
            this.tableBody.innerHTML = FeatureImportanceTableManager.generateErrorMessage(error.message);
        }
    },
    
    /**
     * Update feature count displays
     */
    updateFeatureCounts: function() {
        if (this.totalCountEl && this.subsetCountEl) {
            const counts = FeatureImportanceTableManager.getFeatureCounts(this.state.allData);
            this.totalCountEl.textContent = counts.total;
            this.subsetCountEl.textContent = counts.inSubset;
        }
    },
    
    /**
     * Update sort indicators in column headers
     * @param {string} activeKey - Currently active sort key
     * @param {string} direction - Sort direction
     */
    updateSortIndicators: function(activeKey, direction) {
        if (!this.tableElement) return;
        
        const headers = this.tableElement.querySelectorAll('th.sortable');
        
        headers.forEach(header => {
            const indicator = header.querySelector('.sort-indicator');
            if (!indicator) return;
            
            // Clear all indicators
            indicator.textContent = '';
            
            const key = header.getAttribute('data-sort');
            if (key === activeKey) {
                // Set the active indicator
                indicator.textContent = direction === 'asc' ? '▲' : '▼';
            }
        });
    },
    
    /**
     * Highlight a specific row
     * @param {string} featureName - Name of feature to highlight
     */
    highlightRow: function(featureName) {
        if (!this.tableBody) return;
        
        // Remove current highlights
        this.clearRowHighlights();
        
        // Add highlight to matching row
        const row = this.tableBody.querySelector(`tr[data-feature="${featureName}"]`);
        if (row) {
            row.classList.add('hovered-row');
        }
    },
    
    /**
     * Clear all row highlights
     */
    clearRowHighlights: function() {
        if (!this.tableBody) return;
        
        const rows = this.tableBody.querySelectorAll('tr.hovered-row');
        rows.forEach(row => row.classList.remove('hovered-row'));
    }
};

// Add auto-initialization on DOM load
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the controller if we're on the feature impact tab
    const featureTab = document.getElementById('feature_impact');
    if (featureTab && featureTab.classList.contains('active')) {
        console.log("Feature tab is active on load, initializing table controller");
        FeatureImportanceTableController.init();
    }
    
    // Also initialize when the feature tab is clicked
    const featureTabBtn = document.querySelector('[data-tab="feature_impact"]');
    if (featureTabBtn) {
        featureTabBtn.addEventListener('click', function() {
            console.log("Feature tab clicked, initializing table controller");
            setTimeout(function() {
                FeatureImportanceTableController.init();
            }, 100);
        });
    }
});

// ----- controllers/modelComparison.js ----- //
// Model Comparison Controller
const ModelComparisonController = {
    init: function() {
        console.log("Model Comparison section initialized");
        
        // Initialize tab navigation
        this.initTabNavigation();
        
        // Initialize metric selector if it exists
        this.initMetricSelector();
        
        // Initialize highlight toggle
        this.initHighlightToggle();
        
        // Initialize row expansion functionality
        this.initRowExpansion();
        
        // Initialize charts for robustness visualization
        this.initRobustnessCharts();
    },
    
    initTabNavigation: function() {
        const tabButtons = document.querySelectorAll('.model-comparison-tab');
        if (!tabButtons.length) return;
        
        tabButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                // Remove active from all tabs
                tabButtons.forEach(tab => tab.classList.remove('active'));
                
                // Add active to clicked tab
                e.currentTarget.classList.add('active');
                
                // Show corresponding content
                const tabId = e.currentTarget.getAttribute('data-tab');
                this.showTabContent(tabId);
            });
        });
        
        // Show first tab by default
        tabButtons[0].click();
    },
    
    showTabContent: function(tabId) {
        // Hide all tab content
        const tabContents = document.querySelectorAll('.model-comparison-content');
        tabContents.forEach(content => content.classList.remove('active'));
        
        // Show selected tab content
        const selectedContent = document.getElementById(tabId);
        if (selectedContent) {
            selectedContent.classList.add('active');
        }
        
        // Re-render charts if it's the robustness tab
        if (tabId === 'robustness-tab') {
            this.initRobustnessCharts();
        }
    },
    
    initMetricSelector: function() {
        const metricSelector = document.getElementById('metric-selector');
        if (!metricSelector) return;
        
        metricSelector.addEventListener('change', (e) => {
            const metric = e.target.value;
            ModelComparisonManager.updateMetricsDisplay(metric);
        });
    },
    
    initHighlightToggle: function() {
        const highlightToggle = document.getElementById('highlight-best-toggle');
        if (!highlightToggle) return;
        
        highlightToggle.addEventListener('change', (e) => {
            const highlightBest = e.target.checked;
            ModelComparisonManager.setHighlightBest(highlightBest);
            
            // Re-render active table
            const activeTab = document.querySelector('.model-comparison-tab.active');
            if (activeTab) {
                const tabId = activeTab.getAttribute('data-tab');
                ModelComparisonManager.renderTable(tabId);
            }
        });
    },
    
    initRowExpansion: function() {
        // Use event delegation for row expansion since rows might be re-rendered
        const tableContainer = document.querySelector('.model-comparison-container');
        if (!tableContainer) return;
        
        tableContainer.addEventListener('click', (e) => {
            // Check if the click is on a model row (not on expanded content)
            const modelRow = e.target.closest('tr[data-model-key]');
            if (!modelRow) return;
            
            const modelKey = modelRow.getAttribute('data-model-key');
            ModelComparisonManager.toggleRowExpansion(modelKey);
        });
    },
    
    initRobustnessCharts: function() {
        console.log("Initializing robustness comparison charts");
        
        setTimeout(() => {
            if (typeof Plotly !== 'undefined') {
                ModelComparisonManager.renderPerturbationChart('perturbation-comparison-chart');
            } else {
                this.showChartError();
            }
        }, 500);
    },
    
    showChartError: function() {
        const chartContainers = document.querySelectorAll('.chart-container');
        chartContainers.forEach(container => {
            container.innerHTML = "<div style='padding: 20px; text-align: center; color: red;'>Plotly library not loaded. Charts cannot be displayed.</div>";
        });
    },
    
    refreshAllTables: function() {
        // Get currently active tab
        const activeTab = document.querySelector('.model-comparison-tab.active');
        if (activeTab) {
            const tabId = activeTab.getAttribute('data-tab');
            ModelComparisonManager.renderTable(tabId);
        }
    }
};

// ----- controllers/overview.js ----- //
// Overview Controller
const OverviewController = {
    init: function() {
        console.log("Overview section initialized");
        
        // Initialize chart selector
        this.initChartSelector('performance_charts_selector', '.performance-charts-container .chart-container');
        
        // Initialize model comparison selector if it exists
        this.initChartSelector('model_comparison_selector', '.model-comparison-section .chart-container');
        
        // Initialize tabs in overview
        this.initResultTabs();
        
        // Initialize charts immediately
        this.initCharts();
    },
    
    initChartSelector: function(selectorId, containerSelector) {
        const chartSelector = document.getElementById(selectorId);
        if (!chartSelector) return;
        
        const options = chartSelector.querySelectorAll('.chart-selector-option');
        options.forEach(option => {
            option.addEventListener('click', function() {
                // Remove active from all options
                options.forEach(opt => opt.classList.remove('active'));
                
                // Add active to clicked option
                this.classList.add('active');
                
                // Show corresponding chart
                const chartType = this.getAttribute('data-chart-type');
                const containers = document.querySelectorAll(containerSelector);
                
                containers.forEach(chart => {
                    chart.classList.remove('active');
                });
                
                const targetChart = document.querySelector(`${containerSelector}[data-chart-type="${chartType}"]`);
                if (targetChart) {
                    targetChart.classList.add('active');
                }
            });
        });
    },
    
    initResultTabs: function() {
        const resultTabsContainer = document.getElementById('result_tables_tabs');
        if (!resultTabsContainer) return;
        
        const tabButtons = resultTabsContainer.querySelectorAll('.tab');
        tabButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Remove active class from all buttons
                tabButtons.forEach(btn => btn.classList.remove('active'));
                
                // Add active class to clicked button
                this.classList.add('active');
                
                // Hide all tab contents
                const tabContents = document.querySelectorAll('.results-tables-section .tab-content');
                tabContents.forEach(content => content.classList.remove('active'));
                
                // Show target tab content
                const targetId = this.getAttribute('data-tab');
                const targetContent = document.getElementById(targetId);
                if (targetContent) {
                    targetContent.classList.add('active');
                }
            });
        });
    },
    
    initCharts: function() {
        console.log("Initializing overview charts");
        
        // Try to initialize all charts
        setTimeout(() => {
            if (typeof Plotly !== 'undefined') {
                this.initializePerturbationChart();
                this.initializeWorstScoreChart();
                // Mean Performance chart removed
                
                // Initialize model comparison charts if available
                // Verificar se temos modelos alternativos de qualquer forma
                const hasAlternativeModels = (window.reportConfig && window.reportConfig.hasAlternativeModels) || 
                                          (window.reportData && window.reportData.alternative_models && 
                                           Object.keys(window.reportData.alternative_models).length > 0);
                
                console.log("Verificação de modelos alternativos:", {
                    "reportConfig.hasAlternativeModels": window.reportConfig?.hasAlternativeModels,
                    "Has alternative_models in data": !!(window.reportData?.alternative_models),
                    "alternative_models keys": window.reportData?.alternative_models ? Object.keys(window.reportData.alternative_models) : [],
                    "Final hasAlternativeModels": hasAlternativeModels
                });
                
                if (hasAlternativeModels) {
                    console.log("Inicializando gráficos de comparação de modelos");
                    // Forçar a configuração para indicar que temos modelos alternativos
                    if (window.reportConfig) {
                        window.reportConfig.hasAlternativeModels = true;
                    } else {
                        window.reportConfig = { hasAlternativeModels: true };
                    }
                    
                    this.initializeModelComparisonChart();
                    this.initializeModelLevelDetailsChart();
                    this.populateModelComparisonTable();
                } else {
                    console.log("Não há modelos alternativos para comparação");
                }
                
                // Fill the perturbation tables
                this.fillPerturbationTables();
            } else {
                this.showChartError();
            }
        }, 500);
    },
    
    showChartError: function() {
        const chartContainers = document.querySelectorAll('.chart-plot');
        chartContainers.forEach(container => {
            container.innerHTML = "<div style='padding: 20px; text-align: center; color: red;'>Plotly library not loaded. Charts cannot be displayed.</div>";
        });
    },
    
    fillPerturbationTables: function() {
        // Fill the raw perturbation table
        try {
            const rawTableBody = document.getElementById('raw-perturbation-data');
            if (!rawTableBody) return;
            
            // Clear existing content
            rawTableBody.innerHTML = '';
            
            if (window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
                const rawData = window.reportData.raw.by_level;
                const levels = Object.keys(rawData).sort((a, b) => parseFloat(a) - parseFloat(b));
                
                let baseScore = window.reportData.base_score || 0;
                
                // Criar um mapeamento de todos os scores de feature_subset disponíveis para referência rápida
                const featureSubsetScoresByLevel = {};
                Object.keys(rawData).forEach(levelStr => {
                    if (rawData[levelStr]?.overall_result?.feature_subset?.mean_score !== undefined) {
                        featureSubsetScoresByLevel[levelStr] = rawData[levelStr].overall_result.feature_subset.mean_score;
                    }
                });
                
                console.log("Tabela - Scores de feature subset coletados:", featureSubsetScoresByLevel);
                
                levels.forEach(level => {
                    if (rawData[level] && rawData[level].overall_result) {
                        const result = rawData[level].overall_result;
                        let levelData;
                        
                        if (result.all_features) {
                            levelData = result.all_features;
                        } else if (result.feature_subset) {
                            levelData = result.feature_subset;
                        } else {
                            return; // Skip if no data
                        }
                        
                        const row = document.createElement('tr');
                        
                        // Level
                        const levelCell = document.createElement('td');
                        levelCell.textContent = level;
                        row.appendChild(levelCell);
                        
                        // Base score
                        const baseScoreCell = document.createElement('td');
                        baseScoreCell.textContent = baseScore.toFixed(3);
                        row.appendChild(baseScoreCell);
                        
                        // Perturbed score
                        const perturbedScoreCell = document.createElement('td');
                        perturbedScoreCell.textContent = levelData.mean_score ? levelData.mean_score.toFixed(3) : 'N/A';
                        row.appendChild(perturbedScoreCell);
                        
                        // Impact
                        const impactCell = document.createElement('td');
                        impactCell.textContent = levelData.impact ? (levelData.impact * 100).toFixed(2) + '%' : 'N/A';
                        row.appendChild(impactCell);
                        
                        // Subset score instead of worst score
                        const subsetScoreCell = document.createElement('td');
                        // Get feature subset score if available
                        let subsetScore = 'N/A';
                        
                        // Usar o mapeamento que criamos para ter acesso rápido e consistente aos scores
                        if (featureSubsetScoresByLevel[level] !== undefined) {
                            console.log(`Tabela: Usando score mapeado para nível ${level}:`, featureSubsetScoresByLevel[level]);
                            subsetScore = featureSubsetScoresByLevel[level].toFixed(3);
                        } else {
                            // Tenta encontrar o score de feature subset em diferentes lugares possíveis
                            if (result.feature_subset && result.feature_subset.mean_score !== undefined) {
                                console.log(`Tabela: Encontrado feature_subset.mean_score para nível ${level}:`, result.feature_subset.mean_score);
                                subsetScore = result.feature_subset.mean_score.toFixed(3);
                            } else if (result.subset_features && result.subset_features.mean_score !== undefined) {
                                console.log(`Tabela: Encontrado subset_features.mean_score para nível ${level}:`, result.subset_features.mean_score);
                                subsetScore = result.subset_features.mean_score.toFixed(3);
                            } else if (result.all_features && result.all_features.subset_score !== undefined) {
                                console.log(`Tabela: Encontrado all_features.subset_score para nível ${level}:`, result.all_features.subset_score);
                                subsetScore = result.all_features.subset_score.toFixed(3);
                            } else if (levelData.mean_subset_score !== undefined) {
                                console.log(`Tabela: Encontrado mean_subset_score para nível ${level}:`, levelData.mean_subset_score);
                                subsetScore = levelData.mean_subset_score.toFixed(3);
                            } else if (levelData.subset_score !== undefined) {
                                console.log(`Tabela: Encontrado subset_score para nível ${level}:`, levelData.subset_score);
                                subsetScore = levelData.subset_score.toFixed(3);
                            } else {
                                console.log(`Tabela: Sem score de feature subset válido para nível ${level}`);
                                // Não usaremos scores sintéticos, mostramos N/A em vez disso
                            }
                        }
                        
                        subsetScoreCell.textContent = subsetScore;
                        row.appendChild(subsetScoreCell);
                        
                        rawTableBody.appendChild(row);
                    }
                });
            }
        } catch (error) {
            console.error("Error filling perturbation tables:", error);
        }
    },
    
    // Chart initialization methods would be here (moved to charts/overview.js)
    initializePerturbationChart: function() {
        // Verificar a estrutura dos dados antes de inicializar o gráfico
        if (window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
            console.log("Estrutura dos dados raw.by_level:", Object.keys(window.reportData.raw.by_level));
            
            // Verificar a estrutura para o primeiro nível
            const firstLevel = Object.keys(window.reportData.raw.by_level)[0];
            if (firstLevel) {
                console.log(`Estrutura para nível ${firstLevel}:`, 
                            window.reportData.raw.by_level[firstLevel].overall_result);
                
                // Verificar se temos feature_subset
                if (window.reportData.raw.by_level[firstLevel].overall_result.feature_subset) {
                    console.log(`feature_subset para nível ${firstLevel}:`, 
                                window.reportData.raw.by_level[firstLevel].overall_result.feature_subset);
                }
            }
        }
        
        // Inicializar o gráfico
        ChartManager.initializePerturbationChart('perturbation-chart-plot');
    },
    
    initializeWorstScoreChart: function() {
        ChartManager.initializeWorstScoreChart('worst-score-chart-plot');
    },
    
    // Mean Score chart function removed
    
    initializeModelComparisonChart: function() {
        ChartManager.initializeModelComparisonChart('model-comparison-chart-plot');
    },
    
    initializeModelLevelDetailsChart: function() {
        ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
    },
    
    populateModelComparisonTable: function() {
        const tableBody = document.getElementById('model-comparison-table')?.querySelector('tbody');
        if (!tableBody) return;
        
        try {
            // Clear existing content
            tableBody.innerHTML = '';
            
            // Check if we have alternative models data
            if (!window.reportData || !window.reportConfig || !window.reportConfig.hasAlternativeModels) {
                this.showNoModelComparisonDataMessage(tableBody);
                return;
            }
            
            // Get model data
            const models = this.extractModelComparisonData();
            
            if (models.length === 0) {
                this.showNoModelComparisonDataMessage(tableBody);
                return;
            }
            
            // Sort models by robustness score
            models.sort((a, b) => b.robustnessScore - a.robustnessScore);
            
            // Add a row for each model
            models.forEach(model => {
                const row = document.createElement('tr');
                
                // Model name
                const nameCell = document.createElement('td');
                nameCell.textContent = model.name;
                
                // Base score
                const baseScoreCell = document.createElement('td');
                baseScoreCell.textContent = model.baseScore.toFixed(3);
                
                // Robustness score - calculate correctly as 1.0 - rawImpact
                const robustnessScoreCell = document.createElement('td');
                let robustnessScoreValue;
                
                // First try to use the actual robustness_score if available
                if (typeof model.robustnessScore === 'number' && model.robustnessScore >= 0 && model.robustnessScore <= 1) {
                    robustnessScoreValue = model.robustnessScore;
                } else {
                    // If not available or invalid, calculate it from rawImpact
                    robustnessScoreValue = Math.max(0, Math.min(1, 1.0 - model.rawImpact));
                }
                
                robustnessScoreCell.textContent = robustnessScoreValue.toFixed(3);
                
                // Raw impact - ensure it's a percentage 
                const rawImpactCell = document.createElement('td');
                // Ensure rawImpact is between 0 and 1 for percentage calculation
                const rawImpactValue = typeof model.rawImpact === 'number' ? 
                    Math.max(0, Math.min(1, model.rawImpact)) : 0;
                
                rawImpactCell.textContent = (rawImpactValue * 100).toFixed(2) + '%';
                
                row.appendChild(nameCell);
                row.appendChild(baseScoreCell);
                row.appendChild(robustnessScoreCell);
                row.appendChild(rawImpactCell);
                
                tableBody.appendChild(row);
            });
            
        } catch (error) {
            console.error("Error populating model comparison table:", error);
            this.showErrorMessage(tableBody);
        }
    },
    
    showNoModelComparisonDataMessage: function(tableBody) {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 4;
        cell.innerHTML = `
            <div class="no-data-message">
                <p><strong>No model comparison data available</strong></p>
                <p>Run robustness test with compare() method to see model comparison data.</p>
            </div>
        `;
        cell.style.textAlign = 'center';
        row.appendChild(cell);
        tableBody.appendChild(row);
    },
    
    showErrorMessage: function(tableBody) {
        tableBody.innerHTML = '';
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 4;
        cell.textContent = 'Error loading model comparison data';
        cell.style.textAlign = 'center';
        cell.style.color = 'red';
        row.appendChild(cell);
        tableBody.appendChild(row);
    },
    
    extractModelComparisonData: function() {
        const models = [];
        
        // Add primary model
        let primaryModelName = 'Primary Model';
        let primaryModelData = null;
        
        if (window.reportData.primary_model) {
            primaryModelData = window.reportData.primary_model;
            primaryModelName = primaryModelData.model_name || window.reportConfig.modelName || 'Primary Model';
        } else {
            // Primary model data is at the top level
            primaryModelData = window.reportData;
            primaryModelName = window.reportConfig.modelName || 'Primary Model';
        }
        
        if (primaryModelData) {
            // CORREÇÃO: Garantir que usamos os valores corretos do robustness_score
            // Se o valor estiver presente diretamente em primaryModelData, use-o
            let robustnessScore = 0;
            if (typeof primaryModelData.robustness_score === 'number') {
                robustnessScore = primaryModelData.robustness_score;
                console.log("Usando robustness_score do modelo primário:", robustnessScore);
            } else if (window.reportConfig && typeof window.reportConfig.robustnessScore === 'number') {
                robustnessScore = window.reportConfig.robustnessScore;
                console.log("Usando robustnessScore do reportConfig:", robustnessScore);
            }
            
            models.push({
                name: primaryModelName,
                baseScore: primaryModelData.base_score || 0,
                robustnessScore: robustnessScore,
                rawImpact: primaryModelData.avg_raw_impact || window.reportConfig.rawImpact || 0,
                quantileImpact: primaryModelData.avg_quantile_impact || window.reportConfig.quantileImpact || 0
            });
        }
        
        // Add alternative models
        if (window.reportData.alternative_models) {
            Object.entries(window.reportData.alternative_models).forEach(([name, data]) => {
                // CORREÇÃO: Garantir que usamos os valores corretos do robustness_score para modelos alternativos
                const altScore = typeof data.robustness_score === 'number' ? data.robustness_score : 0;
                console.log(`Modelo alternativo ${name} robustness_score:`, altScore);
                
                models.push({
                    name: name,
                    baseScore: data.base_score || 0,
                    robustnessScore: altScore,
                    rawImpact: data.avg_raw_impact || 0,
                    quantileImpact: data.avg_quantile_impact || 0
                });
            });
        }
        
        return models;
    }
};

// ----- main.js ----- //
/**
 * Improved initialization for robustness reports 
 * Fixes chart initialization issues with centralized rendering
 */

// Global chart initialization state to prevent duplicate rendering
window.chartInitialized = {
    features: false,
    overview: false,
    boxplot: false,
    details: false
};

// Central chart management
window.ChartInitializer = {
    // Check if Plotly is loaded and load if necessary
    ensurePlotlyLoaded: function(callback) {
        if (typeof Plotly !== 'undefined') {
            // Plotly already loaded, execute callback immediately
            if (callback) callback();
            return true;
        }
        
        console.log("Plotly not loaded, attempting to load from CDN");
        
        // Create script element to load Plotly
        const script = document.createElement('script');
        script.src = 'https://cdn.plot.ly/plotly-2.29.1.min.js';
        script.async = true;
        
        script.onload = function() {
            console.log("Plotly loaded successfully");
            if (callback) callback();
        };
        
        script.onerror = function() {
            console.error("Failed to load Plotly from CDN");
            document.querySelectorAll('.chart-plot').forEach(container => {
                container.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="color: #e53935; margin-bottom: 10px;">⚠️ Chart library could not be loaded</div>
                        <div style="color: #555; font-size: 14px;">Please check your internet connection and refresh the page.</div>
                    </div>`;
            });
        };
        
        document.head.appendChild(script);
        return false;
    },
    
    // Initialize feature charts, with validation
    initializeFeatureCharts: function(sortBy) {
        // Allow forced reinitialization with new sort order
        console.log("Initializing feature charts" + (sortBy ? ` with sort: ${sortBy}` : ""));
        
        // More robust feature data availability check
        const checkFeatureImportanceData = () => {
            // First check if we have direct feature_importance
            if (window.reportData && 
                window.reportData.feature_importance && 
                Object.keys(window.reportData.feature_importance).length > 0) {
                console.log("Found feature importance directly in reportData");
                return true;
            }
            
            // Check in reportConfig
            if (window.reportConfig && 
                window.reportConfig.feature_importance && 
                Object.keys(window.reportConfig.feature_importance).length > 0) {
                console.log("Found feature importance in reportConfig");
                return true;
            }
            
            // Check in chartData
            if (window.chartData && 
                window.chartData.feature_importance && 
                Object.keys(window.chartData.feature_importance).length > 0) {
                console.log("Found feature importance in chartData");
                return true;
            }
            
            // Check in chart_data_json
            if (window.reportData && 
                window.reportData.chart_data_json && 
                typeof window.reportData.chart_data_json === 'string' &&
                window.reportData.chart_data_json.includes('feature_importance')) {
                console.log("Found feature importance reference in chart_data_json");
                return true;
            }
            
            // Check in perturbation_details_data
            if (window.reportData && 
                window.reportData.perturbation_details_data && 
                window.reportData.perturbation_details_data.results &&
                window.reportData.perturbation_details_data.results.length > 0) {
                console.log("Found potential feature importance data in perturbation_details_data");
                return true;
            }
            
            // If FeatureImportanceTableManager exists, try its extraction method
            if (typeof FeatureImportanceTableManager !== 'undefined' && 
                typeof FeatureImportanceTableManager.extractFeatureData === 'function') {
                const featureData = FeatureImportanceTableManager.extractFeatureData();
                if (featureData && featureData.length > 0) {
                    console.log(`Found ${featureData.length} features through FeatureImportanceTableManager`);
                    return true;
                }
            }
            
            console.warn("No feature importance data available through any channel");
            return false;
        };
        
        const hasFeatureData = checkFeatureImportanceData();
        
        if (!hasFeatureData) {
            console.warn("No feature importance data available for charts");
            this.showNoDataForCharts('feature-importance-chart');
            this.showNoDataForCharts('importance-comparison-chart-plot');
            return;
        }
        
        this.ensurePlotlyLoaded(() => {
            // Try both standalone chart handlers first
            try {
                // First try StandaloneFeatureImportanceChart
                if (typeof window.StandaloneFeatureImportanceChart !== 'undefined' && 
                    typeof window.StandaloneFeatureImportanceChart.initialize === 'function') {
                    const featureChartContainer = document.getElementById('feature-importance-chart');
                    if (featureChartContainer) {
                        console.log("Using StandaloneFeatureImportanceChart handler");
                        Plotly.purge(featureChartContainer);
                        featureChartContainer.innerHTML = '';
                        
                        // Give a small delay to ensure DOM is ready
                        setTimeout(() => {
                            window.StandaloneFeatureImportanceChart.initialize('feature-importance-chart');
                        }, 100);
                    }
                }
                
                // Then try ImportanceComparisonHandler
                if (typeof window.ImportanceComparisonHandler !== 'undefined' && 
                    typeof window.ImportanceComparisonHandler.initialize === 'function') {
                    const comparisonContainer = document.getElementById('importance-comparison-chart-plot');
                    if (comparisonContainer) {
                        console.log("Using ImportanceComparisonHandler");
                        Plotly.purge(comparisonContainer);
                        comparisonContainer.innerHTML = '';
                        
                        // Give a small delay to ensure DOM is ready
                        setTimeout(() => {
                            window.ImportanceComparisonHandler.initialize();
                        }, 100);
                    }
                }
                
                // Fallback to traditional managers when standalone handlers not available
                if ((typeof window.StandaloneFeatureImportanceChart === 'undefined' || 
                     typeof window.StandaloneFeatureImportanceChart.initialize !== 'function') && 
                    document.getElementById('feature-importance-chart')) {
                    
                    // Try FeatureImportanceChartManager
                    this.initializeFeatureChartWithManager();
                }
                
            } catch (e) {
                console.error("Error initializing feature charts with standalone handlers:", e);
                // Fall back to traditional chart managers
                this.initializeFeatureChartWithManager();
            }
            
            window.chartInitialized.features = true;
        });
    },
    
    // Helper method to initialize feature chart with manager
    initializeFeatureChartWithManager: function() {
        const chartContainer = document.getElementById('feature-importance-chart');
        if (!chartContainer) return;
        
        // Clear previous chart
        if (typeof Plotly !== 'undefined') {
            Plotly.purge(chartContainer);
        }
        chartContainer.innerHTML = '';
        
        if (typeof FeatureImportanceChartManager !== 'undefined' && 
            typeof FeatureImportanceChartManager.initializeFeatureImportanceChart === 'function') {
            console.log("Using FeatureImportanceChartManager");
            FeatureImportanceChartManager.initializeFeatureImportanceChart('feature-importance-chart');
        } 
        else if (typeof FeatureImportanceHandler !== 'undefined' && 
                 typeof FeatureImportanceHandler.initialize === 'function') {
            console.log("Using FeatureImportanceHandler");
            FeatureImportanceHandler.initialize();
        }
        else {
            console.error("No feature chart manager available");
            this.showErrorForCharts('feature-importance-chart', "Chart manager not available");
        }
        
        // Also initialize comparison chart
        const comparisonContainer = document.getElementById('importance-comparison-chart-plot');
        if (comparisonContainer) {
            // Clear previous chart
            if (typeof Plotly !== 'undefined') {
                Plotly.purge(comparisonContainer);
            }
            comparisonContainer.innerHTML = '';
            
            if (typeof FeatureImportanceChartManager !== 'undefined' && 
                typeof FeatureImportanceChartManager.initializeImportanceComparisonChart === 'function') {
                try {
                    FeatureImportanceChartManager.initializeImportanceComparisonChart('importance-comparison-chart-plot');
                } catch (e) {
                    console.error("Error initializing importance comparison chart:", e);
                    // Show graceful error
                    comparisonContainer.innerHTML = `
                        <div style="padding: 30px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto;">
                            <div style="font-size: 48px; margin-bottom: 10px;">⚠️</div>
                            <h3 style="font-size: 18px; margin-bottom: 10px; color: #e53935;">Chart Error</h3>
                            <p style="color: #666; font-size: 14px;">${e.message || "Error rendering chart"}</p>
                        </div>`;
                }
            }
        }
    },
    
    // Initialize overview charts
    initializeOverviewCharts: function() {
        if (window.chartInitialized.overview) return;
        
        console.log("Initializing overview charts");
        
        this.ensurePlotlyLoaded(() => {
            if (typeof ChartManager !== 'undefined') {
                // Clear any previous error messages
                const chartContainers = document.querySelectorAll('.overview-chart');
                chartContainers.forEach(container => {
                    container.innerHTML = '';
                });
                
                // Check if data is available
                const hasOverviewData = window.reportData && 
                                       (window.reportData.raw || window.reportData.perturbation_chart_data);
                
                if (!hasOverviewData) {
                    console.warn("No overview data available for charts");
                    this.showNoDataForCharts('perturbation-chart-plot');
                    this.showNoDataForCharts('worst-score-chart-plot');
                    this.showNoDataForCharts('mean-score-chart-plot');
                    return;
                }
                
                // Initialize each chart with try-catch for robustness
                try {
                    if (typeof ChartManager.initializePerturbationChart === 'function') {
                        ChartManager.initializePerturbationChart('perturbation-chart-plot');
                    }
                } catch (e) {
                    console.error("Error initializing perturbation chart:", e);
                    this.showErrorForCharts('perturbation-chart-plot', e.message);
                }
                
                try {
                    if (typeof ChartManager.initializeWorstScoreChart === 'function') {
                        ChartManager.initializeWorstScoreChart('worst-score-chart-plot');
                    }
                } catch (e) {
                    console.error("Error initializing worst score chart:", e);
                    this.showErrorForCharts('worst-score-chart-plot', e.message);
                }
                
                try {
                    if (typeof ChartManager.initializeMeanScoreChart === 'function') {
                        ChartManager.initializeMeanScoreChart('mean-score-chart-plot');
                    }
                } catch (e) {
                    console.error("Error initializing mean score chart:", e);
                    this.showErrorForCharts('mean-score-chart-plot', e.message);
                }
                
                // Only initialize model comparison charts if we have alternative models
                const hasAlternativeModels = window.reportData && 
                                            window.reportData.alternative_models &&
                                            Object.keys(window.reportData.alternative_models).length > 0;
                                            
                if (hasAlternativeModels) {
                    try {
                        if (typeof ChartManager.initializeModelComparisonChart === 'function') {
                            ChartManager.initializeModelComparisonChart('model-comparison-chart-plot');
                        }
                    } catch (e) {
                        console.error("Error initializing model comparison chart:", e);
                        this.showErrorForCharts('model-comparison-chart-plot', e.message);
                    }
                    
                    try {
                        if (typeof ChartManager.initializeModelLevelDetailsChart === 'function') {
                            ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
                        }
                    } catch (e) {
                        console.error("Error initializing model level details chart:", e);
                        this.showErrorForCharts('model-level-details-chart-plot', e.message);
                    }
                } else {
                    console.log("No alternative models available, skipping comparison charts");
                }
            } else {
                console.error("ChartManager not available");
                document.querySelectorAll('.overview-chart').forEach(container => {
                    this.showErrorForCharts(container.id, "Chart manager not available");
                });
            }
            
            window.chartInitialized.overview = true;
        });
    },
    
    // Initialize boxplot charts
    initializeBoxplotCharts: function() {
        if (window.chartInitialized.boxplot) return;
        
        console.log("Initializing boxplot charts");
        
        // Check if boxplot data is available
        const hasBoxplotData = window.reportData && 
                              (window.reportData.boxplot_data || 
                              (window.reportData.raw && window.reportData.raw.by_level));
        
        if (!hasBoxplotData) {
            console.warn("No boxplot data available");
            this.showNoDataForCharts('boxplot-chart-container');
            return;
        }
        
        // First make sure the container is visible and has dimensions
        const boxplotContainer = document.getElementById('boxplot-chart-container');
        if (boxplotContainer) {
            // Force a minimum size to ensure rendering works
            boxplotContainer.style.minHeight = '400px';
            boxplotContainer.style.minWidth = '100%';
            
            this.ensurePlotlyLoaded(() => {
                if (typeof BoxplotChartManager !== 'undefined' && 
                    typeof BoxplotChartManager.initializeBoxplotChart === 'function') {
                    try {
                        BoxplotChartManager.initializeBoxplotChart('boxplot-chart-container');
                    } catch (e) {
                        console.error("Error initializing boxplot chart:", e);
                        this.showErrorForCharts('boxplot-chart-container', e.message);
                    }
                } else {
                    console.error("BoxplotChartManager not available");
                    this.showErrorForCharts('boxplot-chart-container', "Chart manager not available");
                }
            });
        } else {
            console.warn("Boxplot container not found");
        }
        
        window.chartInitialized.boxplot = true;
    },
    
    // Utility function to show no data message
    showNoDataForCharts: function(elementId) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        element.innerHTML = `
            <div style="padding: 30px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto;">
                <div style="font-size: 48px; margin-bottom: 10px;">📊</div>
                <h3 style="font-size: 18px; margin-bottom: 10px;">No Chart Data Available</h3>
                <p style="color: #666; font-size: 14px;">The required data for this chart is not available.</p>
            </div>`;
    },
    
    // Utility function to show error message
    showErrorForCharts: function(elementId, message) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        element.innerHTML = `
            <div style="padding: 30px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto;">
                <div style="font-size: 48px; margin-bottom: 10px;">⚠️</div>
                <h3 style="font-size: 18px; margin-bottom: 10px; color: #e53935;">Chart Error</h3>
                <p style="color: #666; font-size: 14px;">${message || "Error rendering chart"}</p>
            </div>`;
    }
};

// Tab change handler to ensure charts are rendered when tabs become visible
function handleTabChange(tabId) {
    // Reset layout for any charts in this tab
    window.dispatchEvent(new Event('resize'));
    
    // Initialize appropriate charts based on tab ID
    switch (tabId) {
        case 'overview':
            window.ChartInitializer.initializeOverviewCharts();
            break;
        case 'feature_impact':
            window.ChartInitializer.initializeFeatureCharts();
            // Check if the table controller is initialized
            if (typeof FeatureImportanceTableController !== 'undefined' && 
                typeof FeatureImportanceTableController.init === 'function') {
                console.log("Ensuring feature table is initialized");
                FeatureImportanceTableController.init();
            } else if (typeof FeatureImportanceController !== 'undefined' && 
                     typeof FeatureImportanceController.fillFeatureImportanceTable === 'function') {
                console.log("Using fallback feature table initialization");
                FeatureImportanceController.fillFeatureImportanceTable();
            }
            break;
        case 'boxplot':
            window.ChartInitializer.initializeBoxplotCharts();
            break;
        case 'importance_comparison':
            // Deixamos o ImportanceComparisonHandler cuidar desta inicialização
            // para evitar conflitos de renderização múltipla
            console.log("Importance comparison tab activated - using ImportanceComparisonHandler");
            // Não inicializamos aqui, deixamos o ImportanceComparisonHandler fazer isso
            break;
    }
    
    // Broadcast tab change event for other components
    document.dispatchEvent(new CustomEvent('tabchange', { 
        detail: { tabId: tabId } 
    }));
}

// Initialize on DOM ready with improved structure
document.addEventListener('DOMContentLoaded', function() {
    console.log("Report initialized");
    
    // Carregar script para corrigir erros de continue
    try {
        // Verificar se o script de correção já foi carregado
        if (!window.fixedSyntaxLoaded) {
            console.log("Carregando correção para erros de 'continue' fora de loops");
            window.fixedSyntaxLoaded = true;
            
            // Carregar o script fixed_syntax.js
            const fixScript = document.createElement('script');
            fixScript.src = 'js/fixed_syntax.js';
            fixScript.onload = function() {
                console.log("Script de correção carregado com sucesso");
            };
            fixScript.onerror = function(e) {
                console.error("Erro ao carregar script de correção:", e);
            };
            document.head.appendChild(fixScript);
        }
    } catch (e) {
        console.error("Erro ao configurar correção de sintaxe:", e);
    }
    
    // Set up tab navigation with chart initialization on tab change
    setupTabNavigation();
    
    // Initialize first tab's charts
    const initialTab = document.querySelector('.tab-btn.active');
    if (initialTab) {
        const tabId = initialTab.getAttribute('data-tab');
        handleTabChange(tabId);
    } else {
        // Default to overview if no tab is active
        window.ChartInitializer.initializeOverviewCharts();
    }
    
    // Initialize controllers with error handling
    initializeControllers();
});

// Set up tab navigation
function setupTabNavigation() {
    const tabButtons = document.querySelectorAll('.tab-btn');
    if (tabButtons.length === 0) {
        console.warn("No tab buttons found");
        return;
    }
    
    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            // Remove active class from all buttons
            tabButtons.forEach(btn => btn.classList.remove('active'));
            
            // Add active class to clicked button
            this.classList.add('active');
            
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Show target tab content
            const targetTab = this.getAttribute('data-tab');
            const targetElement = document.getElementById(targetTab);
            
            if (targetElement) {
                targetElement.classList.add('active');
                
                // Initialize charts for this tab
                handleTabChange(targetTab);
            } else {
                console.error(`Tab content not found: #${targetTab}`);
            }
        });
    });
    
    // Activate first tab by default if none is active
    if (!document.querySelector('.tab-btn.active')) {
        tabButtons[0]?.click();
    }
}

// Initialize controllers with error handling
function initializeControllers() {
    // Define controllers to initialize
    const controllers = [
        { name: 'MainController', initializer: function() { 
            if (typeof MainController !== 'undefined' && typeof MainController.init === 'function') {
                MainController.init();
            }
        }},
        { name: 'OverviewController', initializer: function() { 
            if (typeof OverviewController !== 'undefined' && typeof OverviewController.init === 'function') {
                OverviewController.init();
            }
        }},
        { name: 'DetailsController', initializer: function() { 
            if (typeof DetailsController !== 'undefined' && typeof DetailsController.init === 'function') {
                DetailsController.init();
            }
        }},
        // Our direct_perturbation_handler.js now handles the perturbation results
        // automatically when the DOM is loaded, so no initialization needed here
        { name: 'BoxplotController', initializer: function() { 
            if (typeof BoxplotController !== 'undefined' && typeof BoxplotController.init === 'function') {
                BoxplotController.init();
            }
        }},
        { name: 'FeatureImportanceController', initializer: function() { 
            if (typeof FeatureImportanceController !== 'undefined' && typeof FeatureImportanceController.init === 'function') {
                FeatureImportanceController.init();
            } else {
                console.log("FeatureImportanceController not found, using fallback initialization");
                // Try direct chart initialization if controller not available
                window.ChartInitializer.initializeFeatureCharts();
            }
        }},
        { name: 'FeatureImportanceTableController', initializer: function() { 
            if (typeof FeatureImportanceTableController !== 'undefined' && typeof FeatureImportanceTableController.init === 'function') {
                FeatureImportanceTableController.init();
            }
        }}
    ];
    
    // Initialize each controller with error handling
    controllers.forEach(controller => {
        try {
            controller.initializer();
        } catch (error) {
            console.error(`Error initializing ${controller.name}:`, error);
        }
    });
}

// Simple MainController implementation (keep backward compatibility)
const MainController = {
    init: function() {
        console.log("MainController initialized with enhanced initialization");
        // Tab navigation is now handled by setupTabNavigation function
    }
};


        
        // Garantir que a inicialização ocorra quando o DOM estiver pronto
        document.addEventListener('DOMContentLoaded', function() {
            // Uma pequena pausa para garantir que todos os dados estão disponíveis
            setTimeout(function() {
                if (typeof window.DeepBridgeInit === 'function') {
                    window.DeepBridgeInit();
                } else {
                    console.warn("DeepBridgeInit não disponível - usando inicialização alternativa");
                    
                    // Inicializar abas
                    const tabButtons = document.querySelectorAll('.tab-btn');
                    if (tabButtons.length > 0) {
                        tabButtons.forEach(button => {
                            button.addEventListener('click', function() {
                                const targetTab = this.getAttribute('data-tab');
                                
                                // Desativar todas as abas
                                document.querySelectorAll('.tab-content').forEach(tab => {
                                    tab.classList.remove('active');
                                });
                                
                                // Ativar a aba selecionada
                                const selectedTab = document.getElementById(targetTab);
                                if (selectedTab) {
                                    selectedTab.classList.add('active');
                                }
                                
                                // Desativar todos os botões
                                tabButtons.forEach(btn => {
                                    btn.classList.remove('active');
                                });
                                
                                // Ativar o botão selecionado
                                this.classList.add('active');
                            });
                        });
                        
                        // Ativar a primeira aba por padrão
                        tabButtons[0].click();
                    }
                }
            }, 100);
        });
    </script>
</body>
</html>