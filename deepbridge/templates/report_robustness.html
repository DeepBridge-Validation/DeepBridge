<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepBridge Robustness Report: primary_model</title>
    
    <!-- Global error handler - load first to catch syntax errors early -->
    <script>
        // Simple inline error handler to catch syntax errors
        window.onerror = function(message, source, lineno, colno, error) {
            if (message && (message.includes("Illegal continue") || message.includes("no surrounding iteration"))) {
                console.error("Caught illegal continue:", {message, source, lineno});
                return true; // Prevent default handling
            }
            return false; // Let other errors propagate
        };
    </script>
    <script src="js/global_error_handler.js"></script>
    <script src="js/syntax_fixer.js"></script>
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/png;base64,AAABAAEAeU0AAAEAIACMlgAAFgAAACgAAAB5AAAAmgAAAAEAIAAAAAAAlJEAAMIOAADCDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAHWXAUs5loHsu1aAfzuWgD/8VkB//BZAP/rWwD/7VoA/+pZBPjcWAicy1EKGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzVIIH+BZCbbsWAH77VoA/+tZAP/uWgD/61sA//VZAP/pVwX7z1QMUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAHXWgUt5FoFtOxZAv7yWAH/8FoB/+xZAf/zWQD/7FgD/dlbDV8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wAAAdVaCB/iVgm57VcD/vBaAP/uWQH/71kC/+BYB8HLUQoZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA11cPIOBZCbfsWgL26lkC999YBsLVUwsrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAHXWw0n31kIct9aC3PSWAUu/38AAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///////////////////4D///////////////////+A////////////////////gP///////////////////4D8AAf////////////4AA+A+AAD////////////8AAHgPAAAf///////////+AAA4DwAAD////////////AAAeA+AAAf///////////gAAHgP4AAD///////////gAAH4D+AAAP//////////wAAB+A/wAAD//////////4AAA/gP/AAAH/////////4AAA/4D/4AAA/////////8AAAf+A//AAAH////////+AAAP/gP/8AAAP///////8AAAP/4D//gAAB///////+AAAH/+A//+AAAH//////+AAAH//gP//4AAAP/////8AAAH//4D///AAAA/////8AAAD//+A///8AAAB////4AAAD///gP///4AAAA//+AAAAH///4D4P//AAAAAHgAAAAD//4eA8Af/8AAAAAAAAAAD//gDgPAAf/8AAAAAAAAAP/+AA4DwAB//gAAAAAAAAH/+AAOA8AAH/4AAAAAAAAB/+AADgPAAAf+A4AAAAAHAf+AAA4D4AAD/gP8AAAA/wH/AAAeA/wAAf4D//wAf/8B/gAAfgP/4AB+A///////AfgAD/4D//AAPgP//////wHwAD/+A//8AB4D//AAP/8B4AD//gP//4AOA/8AAAP/AcAD//4D///ABgP8AAAA/wGAB//+A///4AID8AAAAD8BAB///gP///AAA8AAAAAfAAA///4D///4AAOAAAAABwAAf//+A////gADAAAAAAcAAf///gP///4AAgAP/8ABAAH///4D////AAAAH//gAAAD///+A////4AAAH//+AAAB////gP////AAAH///4AAA////4D////wAAD////AAAP///+A////+AAB////4AAH////gP////wAA///8HAAD////4D////8AAf//+B4AA////+A/////gAP///APAAf////gP////4AH///gA4AH////4D////+AB///wAOAB////+A/////gA///4ABwAf////gP////8AP//8AAGAP////4D/////AH//+AABwD////+A/////wB///AAAMA/////gP/////B///gAAAw/////4D/////////wAIAP/////+A/////////4AHAB//////gP////////8AH4AH/////4D////////+AB+AB/////+A/////////gA/wAP/////gP////////4A//AA/////4D////////+AP/4AP////+A/////////gH/+AB/////gP////////8H//4AH////4D/////////h//+AB////+A/////////////wAP////gP/////////////AA////4D/////////////wAP///+A/////////////+AB////gP/////////////4AP///4D/////////////+AB///+A//////////////wAP///gP//////////////AD///4D//////////////wA///+A//////////////+AP///gP//////////////4H///4D//////////////+B///+A" type="image/png">
    
    <!-- Plotly library -->
    <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
    
    <!-- Fix scripts for critical functionality -->
    <script src="js/global_error_handler.js"></script>
    <script src="js/syntax_fixer.js"></script>
    <script src="js/fixed_syntax.js"></script>
    <script src="js/model_chart_fix.js"></script>
    <script src="js/patches.js"></script>
    
    <!-- Tab-specific controllers -->
    <script src="js/controllers/details.js"></script>
    <script src="js/charts/details.js"></script>
    
    <!-- CSS combinado -->
    <style>
        /* ===== Combined CSS (Generic + Test-specific) ===== */

/* ----- Combined CSS Styles ----- */

/* =========================================
   MODEL VALIDATION LIBRARY - MAIN STYLES
   ========================================= */

/* --------------------------------------
   CSS VARIABLES
   -------------------------------------- */
:root {
    /* Brand colors */
    --primary-color: #1b78de;       /* Bright blue */
    --primary-light: #4287f5;       /* Lighter blue for gradients */
    --primary-color-dark: #1a5fb4;  /* Darker blue for hover states */
    --secondary-color: #2c3e50;     /* Dark slate */
    
    /* Semantic colors */
    --success-color: #28a745;
    --danger-color: #dc3545;
    --warning-color: #f39c12;
    --info-color: #17a2b8;
    
    /* UI colors */
    --light-color: #f8f9fa;
    --dark-color: #343a40;
    --text-color: #333333;
    --text-secondary: #555555;
    --text-muted: #6c757d;
    --border-color: #dddddd;
    --background-color: #f8f9fa;
    --card-bg: #ffffff;
    --bg-card: #ffffff;
    --bg-card-alt: #f8f9fa;
    
    /* Gradients */
    --header-bg: linear-gradient(to right, #1a5fb4, #3584e4, #62a0ea);
    --primary-gradient: linear-gradient(135deg, #4287f5, #1a56b8);
    
    /* Spacing */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;
    
    /* Border radius */
    --border-radius-sm: 4px;
    --border-radius-md: 8px;
    --border-radius-lg: 12px;
    
    /* Box shadows */
    --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
    --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
    --shadow-card: 0 2px 5px rgba(0, 0, 0, 0.1);
}

/* --------------------------------------
   RESET AND BASE STYLES
   -------------------------------------- */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html, body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 16px;
    line-height: 1.5;
    color: var(--text-color);
    background-color: var(--background-color);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

img {
    max-width: 100%;
    height: auto;
}

a {
    color: var(--primary-color);
    text-decoration: none;
    transition: color 0.2s ease;
}

a:hover {
    color: var(--primary-color-dark);
    text-decoration: underline;
}

/* Fix for tab display */
.tab-content {
    display: none !important;
}

.tab-content.active {
    display: block !important;
}

/* Header styling */
.report-header {
    background: var(--header-bg);
    color: white;
    padding: var(--spacing-lg);
    border-radius: var(--border-radius-md);
    margin-bottom: var(--spacing-lg);
    box-shadow: var(--shadow-md);
    width: 100%;
}

.header-content {
    display: flex;
    align-items: center;
    gap: 1.5rem;
}

.header-logo {
    flex: 0 0 auto;
}

.header-logo .logo {
    max-width: 120px;
    max-height: 60px;
}

.header-info {
    flex: 1;
}

.header-info h1 {
    margin: 0 0 0.25rem 0;
    font-size: 1.75rem;
}

.report-subtitle {
    margin: 0 0 0.75rem 0;
    opacity: 0.9;
}

.report-metadata {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    font-size: 0.875rem;
}

.metadata-item {
    padding-right: 1rem;
    border-right: 1px solid rgba(255, 255, 255, 0.3);
}

.metadata-item:last-child {
    border-right: none;
}

/* Report container */
.report-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--spacing-lg);
    width: 100%;
}

/* Content containers */
.report-content {
    padding: 0;
    width: 100%;
}

/* --------------------------------------
   LAYOUT CONTAINERS
   -------------------------------------- */
.container {
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 15px;
}

.section {
    margin-bottom: var(--spacing-xl);
    background-color: var(--bg-card);
    padding: var(--spacing-lg);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-card);
}

.section-title {
    margin-bottom: var(--spacing-md);
    padding-bottom: var(--spacing-sm);
    border-bottom: 1px solid var(--border-color);
    color: var(--secondary-color);
    font-size: 1.5rem;
}

/* --------------------------------------
   GRID SYSTEM
   -------------------------------------- */
.row {
    display: flex;
    flex-wrap: wrap;
    margin-right: -15px;
    margin-left: -15px;
}

.col {
    flex-basis: 0;
    flex-grow: 1;
    max-width: 100%;
    padding-right: 15px;
    padding-left: 15px;
}

.col-12 {
    flex: 0 0 100%;
    max-width: 100%;
    padding-right: 15px;
    padding-left: 15px;
}

.col-6 {
    flex: 0 0 50%;
    max-width: 50%;
    padding-right: 15px;
    padding-left: 15px;
}

.col-4 {
    flex: 0 0 33.333333%;
    max-width: 33.333333%;
    padding-right: 15px;
    padding-left: 15px;
}

.col-8 {
    flex: 0 0 66.666667%;
    max-width: 66.666667%;
    padding-right: 15px;
    padding-left: 15px;
}

.col-3 {
    flex: 0 0 25%;
    max-width: 25%;
    padding-right: 15px;
    padding-left: 15px;
}

/* Import component styles */
@import url('components/buttons.css');
@import url('components/cards.css');
@import url('components/charts.css');
@import url('components/messages.css');
@import url('components/tables.css');
@import url('components/tabs.css');
@import url('components/typography.css');
@import url('components/utilities.css');

/* --------------------------------------
   RESPONSIVE MEDIA QUERIES
   -------------------------------------- */
@media (max-width: 992px) {
    .col-lg-6 {
        flex: 0 0 50%;
        max-width: 50%;
    }
    
    .col-lg-12 {
        flex: 0 0 100%;
        max-width: 100%;
    }
    
    .header-content {
        flex-direction: column;
        text-align: center;
    }
    
    .header-logo {
        margin-bottom: 1rem;
    }
    
    .report-metadata {
        justify-content: center;
    }
}

@media (max-width: 768px) {
    .col-md-6, .col-6, .col-4, .col-8, .col-3 {
        flex: 0 0 100%;
        max-width: 100%;
    }
    
    .main-tabs {
        overflow-x: auto;
        flex-wrap: nowrap;
        justify-content: flex-start;
    }
    
    h1 {
        font-size: 1.8rem;
    }
    
    h2 {
        font-size: 1.5rem;
    }
    
    .report-header {
        padding: 1rem;
    }
    
    .section {
        padding: 1rem;
    }
    
    .report-container {
        padding: var(--spacing-md);
    }
}

@media (max-width: 576px) {
    .container {
        padding: 0 10px;
    }
    
    .report-container {
        padding: var(--spacing-sm);
    }
    
    .report-metadata {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .metadata-item {
        border-right: none;
        padding-right: 0;
    }
}

/* ----- tabs ----- */
/* Main tab navigation */
.main-tabs {
    display: flex;
    flex-wrap: nowrap;
    gap: 5px;
    margin: 1.5rem 0;
    background-color: #f4f6f9;
    border-radius: 8px;
    padding: 8px;
    overflow-x: auto;
    justify-content: center;
}

/* Tab content */
.tab-content {
    display: none !important;
}

.tab-content.active {
    display: block !important;
}

/* Results tabs */
.results-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 1rem;
}

.results-tabs .tab {
    padding: 0.5rem 1rem;
    cursor: pointer;
    border-bottom: 2px solid transparent;
}

.results-tabs .tab.active {
    border-bottom: 2px solid var(--primary-color);
    color: var(--primary-color);
    font-weight: 500;
}

/* ----- utilities ----- */
/* Status colors */
.text-red-600 {
    color: #dc2626;
}

.text-yellow-600 {
    color: #d97706;
}

.text-green-600 {
    color: #16a34a;
}

.positive-value {
    color: #4caf50;
}

.negative-value {
    color: #e53935;
}

.score-high {
    color: #2ecc71;
}

.score-medium {
    color: #f39c12;
}

.score-low {
    color: #e74c3c;
}

/* Font utilities */
.font-semibold {
    font-weight: 600;
}

/* Display utilities */
.flex {
    display: flex;
}

.flex-col {
    flex-direction: column;
}

.justify-center {
    justify-content: center;
}

.items-center {
    align-items: center;
}

.gap-2 {
    gap: 0.5rem;
}

.gap-4 {
    gap: 1rem;
}

/* Spacing utilities */
.mt-2 {
    margin-top: 0.5rem;
}

.mt-4 {
    margin-top: 1rem;
}

.mb-2 {
    margin-bottom: 0.5rem;
}

.mb-4 {
    margin-bottom: 1rem;
}

.my-6 {
    margin-top: 1.5rem;
    margin-bottom: 1.5rem;
}

/* ----- typography ----- */
/* Heading styles */
h1, h2, h3, h4, h5, h6 {
    margin-bottom: 0.5rem;
    font-weight: 500;
    line-height: 1.2;
}

h1 {
    font-size: 2.2rem;
    color: white;
    margin-bottom: 0.5rem;
}

h2 {
    font-size: 1.8rem;
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 0.5rem;
    color: var(--secondary-color);
}

h3 {
    font-size: 1.5rem;
    color: var(--secondary-color);
}

.section-title {
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border-color);
}

/* Text styles */
p {
    margin-bottom: 1rem;
}

.text-muted {
    color: var(--text-muted);
}

.text-center {
    text-align: center;
}

.text-sm {
    font-size: 0.875rem;
}

.text-lg {
    font-size: 1.125rem;
}

.text-xl {
    font-size: 1.25rem;
}

.text-2xl {
    font-size: 1.5rem;
}

.font-bold {
    font-weight: 700;
}

/* ----- charts ----- */
/* Chart containers */
.chart-container {
    margin: 1.5rem 0;
    display: none;
    min-height: 300px;
}

.chart-container.active {
    display: block;
}

.chart-plot {
    min-height: 300px;
    background-color: #fff;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    width: 100%;
    margin-bottom: 1.5rem;
}

/* Chart selector */
.chart-selector {
    display: flex;
    align-items: center;
    background: #f0f2f5;
    border-radius: 4px;
    padding: 0.25rem;
    margin-bottom: 1rem;
    max-width: fit-content;
    overflow-x: auto;
}

.chart-selector-option {
    padding: 0.5rem 1rem;
    border-radius: 4px;
    font-size: 0.875rem;
    cursor: pointer;
    background: none;
    border: none;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.chart-selector-option.active {
    background: #fff;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    font-weight: 500;
}

/* ----- tables ----- */
/* Table container */
.table-container {
    margin: 1.5rem 0;
    overflow-x: auto;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}

/* Data table */
.data-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
    margin-bottom: 0;
}

.data-table th {
    background-color: #f5f7fa;
    color: var(--secondary-color);
    text-align: left;
    padding: 12px 15px;
    font-weight: 600;
    border-bottom: 2px solid #eaeef2;
}

.data-table td {
    padding: 10px 15px;
    border-bottom: 1px solid #eaeef2;
}

.data-table tr:last-child td {
    border-bottom: none;
}

.data-table tr:hover td {
    background-color: #f9fbfd;
}

/* Striped table */
.striped-table tr:nth-child(even) td {
    background-color: #f5f7fa;
}

.striped-table tr:hover td {
    background-color: #eef2f7;
}

/* Table status colors */
.positive {
    color: var(--success-color);
}

.negative {
    color: var(--danger-color);
}

.warning {
    color: var(--warning-color);
}

/* Table filter */
.table-filter {
    margin-bottom: 1rem;
    padding: 0.75rem;
    background-color: #f8f9fa;
    border-radius: 4px;
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    align-items: center;
}

.filter-input {
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.filter-select {
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    background-color: white;
}

/* ----- cards ----- */
/* Base card styles */
.card {
    background-color: var(--card-bg);
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    margin-bottom: 1.5rem;
    overflow: hidden;
}

.card-header {
    background: linear-gradient(to right, var(--primary-color), var(--primary-color) 85%, #3498db);
    color: white;
    padding: 15px 20px;
    font-weight: bold;
    font-size: 1.2rem;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
}

.card-body {
    padding: 20px;
}

/* Score card */
.score-card {
    text-align: center;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    padding: 25px 20px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100%;
}

.score-value {
    font-size: 3rem;
    font-weight: bold;
    color: var(--primary-color);
    margin: 15px 0;
}

.score-label {
    font-size: 1.2rem;
    color: var(--secondary-color);
    margin-bottom: 10px;
    font-weight: 600;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
    width: 100%;
}

.score-desc {
    color: var(--text-muted);
    font-size: 0.95rem;
    margin-top: 10px;
}

/* Info card */
.info-card {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    padding: 25px 20px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    height: 100%;
}

.info-title {
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 20px;
    color: var(--secondary-color);
    text-align: center;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
}

/* Metric card */
.metric-card {
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
    text-align: center;
    transition: all 0.3s ease;
}

.metric-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
}

.metric-card-value {
    font-size: 2.2rem;
    font-weight: 700;
    margin: 0.75rem 0;
    color: var(--primary-color);
}

.metric-card-label {
    font-size: 1.1rem;
    color: var(--secondary-color);
    margin: 0 0 0.5rem 0;
    font-weight: 600;
}

.metric-card-desc {
    font-size: 0.9rem;
    color: var(--text-muted);
    margin-top: 0.5rem;
}

/* Summary card */
.summary-card {
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
    margin-bottom: 1.5rem;
}

/* ----- messages ----- */
/* Message container styles */
.message-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 1.5rem;
    text-align: center;
}

/* Loading message */
.loading-message {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    height: 100%;
    padding: 2rem;
    text-align: center;
}

/* Message icon */
.message-icon {
    font-size: 2rem;
    margin-bottom: 1rem;
}

/* Error message */
.error-message {
    padding: 15px;
    text-align: center;
    color: var(--danger-color);
    background-color: #fef2f2;
    border-radius: 4px;
}

/* No data message */
.no-data-message {
    padding: 20px;
    background-color: var(--light-color);
    border-radius: 8px;
    margin: 10px 0;
}

.no-data-message p {
    margin: 8px 0;
    color: #6c757d;
}

.no-data-message strong {
    color: #495057;
}

/* Data unavailable */
.data-unavailable {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 300px;
    background-color: #f8f9fa;
    border-radius: 5px;
}

.data-message {
    text-align: center;
    padding: 20px;
}

/* ----- buttons ----- */
/* Button styles */
.btn {
    display: inline-block;
    padding: 0.6rem 1.2rem;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 1px solid transparent;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    text-align: center;
}

.btn:hover {
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.btn-primary {
    background-color: var(--primary-color);
    color: white;
}

.btn-primary:hover {
    background-color: var(--primary-color-dark);
}

.btn-secondary {
    background-color: #fff;
    color: var(--text-color);
}

.btn-secondary:hover {
    color: var(--primary-color);
    background-color: #f8f9fa;
}

/* Tab buttons */
.tab-btn {
    background-color: #fff;
    border: 1px solid transparent;
    border-radius: 6px;
    padding: 0.6rem 1.2rem;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
    white-space: nowrap;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    color: var(--text-color);
}

.tab-btn:hover {
    color: var(--primary-color);
    background-color: #f8f9fa;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.tab-btn.active {
    background-color: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

/* Filter buttons */
.filter-button {
    padding: 0.5rem 1rem;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.filter-button:hover {
    background-color: var(--primary-color-dark);
}

.filter-reset {
    padding: 0.5rem 1rem;
    background-color: #f8f9fa;
    color: #666;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.filter-reset:hover {
    background-color: #e9ecef;
}



/* ----- Combined CSS Styles ----- */

/* =========================================
   MODEL ROBUSTNESS REPORT - MAIN STYLES
   ========================================= */

/* Import our component styles */
@import url('components/summary.css');
@import url('components/cards.css');
@import url('components/charts.css');
@import url('components/tables.css');
@import url('components/tabs.css');
@import url('components/widgets.css');

/* Variables especficas para o relatrio de robustez */
:root {
    /* Cores especficas para o tema de robustez */
    --robustness-primary: #1b78de;
    --robustness-secondary: #3498db;
    --robustness-highlight: #4287f5;
    
    /* Cores para indicao de nvel de robustez */
    --robust-high: #28a745;
    --robust-medium: #ffc107;
    --robust-low: #dc3545;
    
    /* Gradientes personalizados */
    --robustness-gradient: linear-gradient(135deg, #4287f5, #1a56b8);
}

/* Estilos adicionais especficos */
.robustness-report .section {
    margin-bottom: 2rem;
}

.robustness-report .chart-container {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    padding: 1rem;
}

/* Boxplot specific styles */
#boxplot-chart-container {
  min-height: 550px !important;
  padding: 20px 0;
  border-radius: 8px;
  background-color: #fafafa;
  margin-bottom: 25px;
}

/* Make sure violin plots have enough contrast */
.violin-plot .violin-fill {
  opacity: 0.8 !important;
}

/* Style for base score markers */
.base-score-marker {
  stroke: white !important;
  stroke-width: 1.5px !important;
}

/* Improve table presentation */
.boxplot-table {
  border-collapse: collapse;
  width: 100%;
  margin-top: 20px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.05);
}

.boxplot-table th {
  background-color: #f3f3f3;
  font-weight: bold;
  text-align: left;
  padding: 10px;
  border-bottom: 2px solid #ddd;
}

.boxplot-table td {
  padding: 8px 10px;
  border-bottom: 1px solid #eee;
}

.boxplot-table tr:nth-child(even) {
  background-color: #f9f9f9;
}

.boxplot-table tr:hover {
  background-color: #f0f0f0;
}

/* Score drop coloring */
.boxplot-table .text-danger {
  color: #d9534f;
  font-weight: bold;
}

.boxplot-table .text-warning {
  color: #f0ad4e;
}

.boxplot-table .text-success {
  color: #5cb85c;
}

.robustness-metrics {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin: 1.5rem 0;
}

.metric-item {
    flex: 1;
    min-width: 120px;
    background-color: #1b78de;
    border-radius: 8px;
    padding: 1.25rem;
    text-align: center;
}

.metric-value {
    font-size: 1.8rem;
    font-weight: bold;
    color: var(--robustness-primary);
}

.metric-label {
    font-size: 0.9rem;
    color: #1b78de;
    margin-top: 0.5rem;
}

/* ----- tabs ----- */
/* Estilos especficos para tabs de robustez */

/* Navegao principal em abas */
.main-tabs {
    display: flex;
    flex-wrap: nowrap;
    gap: var(--spacing-sm);
    margin: var(--spacing-lg) 0;
    background-color: var(--bg-card-alt);
    border-radius: var(--border-radius-md);
    padding: var(--spacing-sm);
    overflow-x: auto;
    justify-content: center;
    box-shadow: var(--shadow-sm);
}

/* Estilizao especfica dos botes das abas */
.tab-btn {
    background-color: var(--bg-card);
    border: 1px solid transparent;
    border-radius: var(--border-radius-sm);
    padding: 0.6rem 1.2rem;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
    white-space: nowrap;
    box-shadow: var(--shadow-sm);
    color: var(--text-color);
}

.tab-btn:hover {
    color: var(--primary-color);
    background-color: var(--light-color);
    box-shadow: var(--shadow-md);
}

.tab-btn.active {
    background-color: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    box-shadow: var(--shadow-md);
}

/* Contedo das abas */
.tab-content {
    display: none !important;
    padding: var(--spacing-md);
    background-color: var(--bg-card);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-card);
    margin-bottom: var(--spacing-xl);
}

.tab-content.active {
    display: block !important;
    animation: fadeIn 0.3s ease;
}

/* Sub-abas dentro de uma seo */
.section-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: var(--spacing-md);
    gap: var(--spacing-sm);
}

.section-tab {
    padding: var(--spacing-sm) var(--spacing-md);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.2s ease;
}

.section-tab:hover {
    color: var(--primary-color);
}

.section-tab.active {
    border-bottom: 2px solid var(--primary-color);
    color: var(--primary-color);
    font-weight: 500;
}

/* Tabs de resultados */
.results-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: var(--spacing-md);
}

.results-tabs .tab {
    padding: var(--spacing-sm) var(--spacing-md);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.2s ease;
}

.results-tabs .tab:hover {
    color: var(--primary-color);
}

.results-tabs .tab.active {
    border-bottom: 2px solid var(--primary-color);
    color: var(--primary-color);
    font-weight: 500;
}

/* Animao para transio de tabs */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Ajustes responsivos */
@media (max-width: 768px) {
    .main-tabs {
        overflow-x: auto;
        justify-content: flex-start;
        padding: var(--spacing-xs);
        gap: var(--spacing-xs);
    }
    
    .tab-btn {
        padding: 0.5rem 1rem;
        font-size: 0.85rem;
    }
    
    .tab-content {
        padding: var(--spacing-sm);
    }
}

/* ----- charts ----- */
/* Estilos especficos para charts de robustez */

/* Boxplot Chart Styles */
.boxplot-chart-container {
    margin: 20px auto;
    width: 100%;
    min-height: 500px;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.boxplot-chart {
    max-width: 100%;
    overflow-x: auto;
    margin-bottom: 20px;
}

.boxplot-legend {
    width: 100%;
    max-width: 800px;
    background-color: #f8f9fa;
    border-radius: 5px;
    padding: 10px;
    margin-top: 20px;
}

.model-selector-wrapper {
    margin: 10px 0 20px;
    text-align: right;
}

.boxplot-table {
    width: 100%;
    border-collapse: collapse;
}

.boxplot-table th {
    background-color: #f2f2f2;
    font-weight: bold;
    text-align: left;
    padding: 10px;
    border-bottom: 2px solid #ddd;
}

.boxplot-table td {
    padding: 8px 10px;
    border-bottom: 1px solid #ddd;
}

.boxplot-table tr:hover {
    background-color: #f5f5f5;
}

/* ----- widgets ----- */
/* Widget component styles */

.widget {
    margin-bottom: 1.5rem;
}

/* Chart selector widget */
.chart-selector {
    display: flex;
    flex-wrap: nowrap;
    gap: 5px;
    margin: 1.5rem 0;
    background-color: #f4f6f9;
    border-radius: 8px;
    padding: 8px;
    overflow-x: auto;
}

.chart-selector-option {
    background-color: #fff;
    border: 1px solid transparent;
    border-radius: 6px;
    padding: 0.6rem 1.2rem;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
    white-space: nowrap;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}

.chart-selector-option:hover {
    color: var(--primary-color);
    background-color: #f8f9fa;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.chart-selector-option.active {
    background-color: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

/* Expandable panel */
.expandable-panel {
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-bottom: 1rem;
    background-color: #fff;
    overflow: hidden;
}

.panel-header {
    padding: 0.75rem 1rem;
    background-color: #f5f5f5;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.panel-title {
    font-weight: 600;
    margin: 0;
}

.panel-icon {
    transition: transform 0.3s;
}

.panel-icon.expanded {
    transform: rotate(180deg);
}

.panel-content {
    padding: 1rem;
    display: none;
}

.panel-content.expanded {
    display: block;
}

/* Tooltip */
.tooltip {
    position: relative;
    display: inline-block;
}

.tooltip-icon {
    color: #888;
    cursor: pointer;
    font-size: 0.875rem;
    margin-left: 0.25rem;
}

.tooltip-content {
    visibility: hidden;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    background-color: #333;
    color: #fff;
    border-radius: 4px;
    padding: 0.5rem 1rem;
    width: 200px;
    font-size: 0.75rem;
    opacity: 0;
    transition: opacity 0.3s;
}

.tooltip:hover .tooltip-content {
    visibility: visible;
    opacity: 1;
}

/* Metric card */
.metric-card {
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
    text-align: center;
    transition: all 0.3s ease;
}

.metric-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
}

.metric-card-value {
    font-size: 2.2rem;
    font-weight: 700;
    margin: 0.75rem 0;
    color: var(--primary-color);
}

.metric-card-label {
    font-size: 1.1rem;
    color: var(--secondary-color);
    margin: 0 0 0.5rem 0;
    font-weight: 600;
}

.metric-card-desc {
    font-size: 0.9rem;
    color: var(--text-muted);
    margin-top: 0.5rem;
}

/* Progress bar */
.progress-container {
    background-color: #f1f1f1;
    border-radius: 4px;
    height: 8px;
    margin: 1rem 0;
}

.progress-bar {
    height: 100%;
    border-radius: 4px;
    background-color: #4a6ee0;
    width: 0;
    transition: width 0.5s;
}


/* ----- tables ----- */
/* Estilos especficos para tabelas de robustez */

/* Specialized tables */
.metrics-details-table th {
    background-color: #f0f7ff;
}

.feature-importance-table th {
    background-color: #f0fff7;
}

.perturbation-results-table th {
    background-color: #fff7f0;
}

/* Info table */
.info-table {
    width: 100%;
    border-collapse: collapse;
}

.info-table td {
    padding: 6px 0;
    border-bottom: 1px dotted #eaeef2;
}

.info-table tr:last-child td {
    border-bottom: none;
}

/* Table status indicators */
.text-red-600 {
    color: #dc2626;
}

.text-yellow-600 {
    color: #d97706;
}

.text-green-600 {
    color: #16a34a;
}

.font-semibold {
    font-weight: 600;
}

/* No data states */
.no-data {
    padding: 20px;
    text-align: center;
    color: #666;
    background-color: #f9f9f9;
    border-radius: 4px;
}

.error-message {
    padding: 15px;
    text-align: center;
    color: var(--danger-color);
    background-color: #fef2f2;
    border-radius: 4px;
}

/* Pagination */
.pagination {
    display: flex;
    justify-content: center;
    margin-top: 1rem;
    gap: 0.5rem;
}

.pagination-item {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border-radius: 4px;
    background-color: #f5f7fa;
    cursor: pointer;
    transition: all 0.2s;
}

.pagination-item:hover {
    background-color: #e9ecef;
}

.pagination-item.active {
    background-color: var(--primary-color);
    color: white;
}

/* Feature Importance Table Styles */
.feature-importance-container {
    background-color: white;
    border-radius: 0.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    overflow: hidden;
    margin-bottom: 1.5rem;
}

.feature-importance-header {
    padding: 1rem;
    border-bottom: 1px solid #e5e7eb;
}

.feature-importance-header h2 {
    font-size: 1.25rem;
    font-weight: 600;
    color: #1f2937;
    margin-bottom: 0.75rem;
}

.feature-importance-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-top: 0.75rem;
}

.search-container {
    flex-grow: 1;
    min-width: 200px;
}

.search-input {
    width: 100%;
    padding: 0.5rem 0.75rem;
    border: 1px solid #d1d5db;
    border-radius: 0.375rem;
    font-size: 0.875rem;
}

.toggle-container {
    display: flex;
    align-items: center;
}

.toggle-label {
    display: inline-flex;
    align-items: center;
    cursor: pointer;
    font-size: 0.875rem;
}

.toggle-checkbox {
    margin-right: 0.5rem;
    width: 1rem;
    height: 1rem;
}

/* Feature importance table styles */
.feature-importance-table-wrapper {
    overflow-x: auto;
}

.feature-importance-table {
    width: 100%;
    border-collapse: collapse;
}

.feature-importance-table th,
.feature-importance-table td {
    padding: 0.75rem 1rem;
    text-align: left;
    border-bottom: 1px solid #e5e7eb;
}

.feature-importance-table th {
    background-color: #f9fafb;
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
    color: #6b7280;
}

.feature-importance-table th.sortable {
    cursor: pointer;
    user-select: none;
}

.feature-importance-table th.sortable:hover {
    background-color: #f3f4f6;
}

.sort-indicator {
    display: inline-block;
    margin-left: 0.25rem;
}

.feature-importance-table tbody tr:hover {
    background-color: #f3f4f6;
}

.feature-importance-table .hovered-row {
    background-color: #eff6ff;
}

.feature-importance-table .feature-subset-row {
    background-color: #fffbeb;
}

.feature-importance-table .feature-subset-row.hovered-row {
    background-color: #fef3c7;
}

/* Cell content styling */
.feature-name {
    font-weight: 500;
    color: #111827;
}

.value-with-bar {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.value-text {
    min-width: 80px;
    font-family: monospace;
}

.progress-container {
    width: 100px;
    height: 0.5rem;
    background-color: #e5e7eb;
    border-radius: 9999px;
    overflow: hidden;
}

.progress-bar {
    height: 100%;
    border-radius: 9999px;
}

.progress-bar.positive {
    background-color: #3b82f6;
}

.progress-bar.negative {
    background-color: #ef4444;
}

.progress-bar.model {
    background-color: #10b981;
}

.impact-badge {
    display: inline-flex;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    font-weight: 500;
    border-radius: 9999px;
}

.impact-badge.positive {
    background-color: #dcfce7;
    color: #166534;
}

.impact-badge.negative {
    background-color: #fee2e2;
    color: #991b1b;
}

.subset-badge {
    display: inline-flex;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    font-weight: 500;
    border-radius: 9999px;
    text-align: center;
}

.subset-badge.included {
    background-color: #dbeafe;
    color: #1e40af;
}

.subset-badge.excluded {
    background-color: #f3f4f6;
    color: #4b5563;
}

/* Message styling */
.message-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
}

/* Footer styles */
.feature-importance-footer {
    padding: 1rem;
    border-top: 1px solid #e5e7eb;
    font-size: 0.875rem;
    color: #6b7280;
}

.table-summary-info {
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 1rem;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .feature-importance-controls {
        flex-direction: column;
    }
    
    .progress-container {
        width: 60px;
    }
    
    .value-text {
        min-width: 60px;
    }
    
    .table-summary-info {
        flex-direction: column;
    }
}

/* ----- cards ----- */
/* Estilos especficos para cards de robustez */

/* Robustness score card styles */
.robustness-score-card {
    background: linear-gradient(135deg, #1a5fb4, #3584e4);
    color: white;
    border-radius: 8px;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.robustness-score-title {
    font-size: 1rem;
    margin: 0;
}

.robustness-score-value {
    font-size: 2.5rem;
    font-weight: 700;
    margin: 0;
}

.robustness-score-description {
    font-size: 0.875rem;
    opacity: 0.9;
    margin: 0;
}

/* Metrics summary styles */
.metrics-summary {
    background-color: var(--light-color);
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
}

.metrics-summary-title {
    font-size: 1rem;
    margin: 0 0 0.75rem 0;
    font-weight: 600;
}

.metrics-summary-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

.metrics-summary-label {
    color: #495057;
}

.metrics-summary-value {
    font-weight: 600;
}

/* Model info styles */
.model-info {
    background-color: var(--light-color);
    border-radius: 8px;
    padding: 1rem;
}

.model-info-title {
    font-size: 1rem;
    margin: 0 0 0.75rem 0;
    font-weight: 600;
}

.model-info-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

.model-info-label {
    color: #495057;
}

.model-info-value {
    font-weight: 600;
}

/* ----- summary ----- */
/* Summary Section Styling */
.summary-stats {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-xl);
    background-color: var(--bg-card);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-card);
    width: 100%;
    justify-content: space-between;
    align-items: stretch;
    gap: var(--spacing-lg);
}

/* Estrutura de card */
.summary-card-wrapper {
    flex: 1;
    min-width: 0; /* Permite que os cards diminuam abaixo de seu contedo mnimo */
}

/* Removendo o wrapper aninhado de info-cards */
.info-cards-wrapper {
    display: none; /* Removemos este wrapper */
}

/* Wrapper para cada card - cada um com espao exato */
.summary-card-wrapper {
    display: flex;
    margin-bottom: 0;
}

/* Card de pontuao */
.score-card {
    width: 100%;
    padding: var(--spacing-md);
    border-radius: var(--border-radius-md);
    background: var(--primary-gradient);
    color: white;
    text-align: center;
    box-shadow: var(--shadow-md);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    overflow: hidden;
}

.score-label {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: var(--spacing-sm);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Medidor gauge circular */
.score-gauge {
    width: 100%;
    max-width: 120px;
    margin: 0.25rem auto;
}

.gauge-svg {
    width: 100%;
    height: auto;
}

/* Mtricas adicionais no card de score */
.score-metrics {
    display: flex;
    justify-content: center;
    width: 100%;
    max-width: 180px;
    gap: 10px;
    margin: var(--spacing-sm) auto;
}

.score-metrics .metric-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: #ffffff;
    border-radius: 4px;
    padding: 5px;
    width: 70px;
}

.score-metrics .metric-value {
    font-size: 0.95rem;
    font-weight: 700;
    white-space: nowrap;
}

.score-metrics .metric-label {
    font-size: 0.65rem;
    opacity: 0.8;
    text-align: center;
    white-space: nowrap;
}

/* Badges de classificao */
.score-badge {
    font-weight: 600;
    padding: 2px 5px;
    border-radius: 3px;
    margin-right: 3px;
    font-size: 0.9rem;
}

.score-badge.excellent {
    background-color: rgba(40, 167, 69, 0.8);
}

.score-badge.good {
    background-color: rgba(255, 193, 7, 0.8);
    color: rgba(0, 0, 0, 0.9);
}

.score-badge.moderate {
    background-color: rgba(253, 126, 20, 0.8);
}

.score-badge.needs-improvement {
    background-color: rgba(220, 53, 69, 0.8);
}

.score-desc {
    font-size: 0.8rem;
    margin-top: 0.5rem;
    padding: 0 var(--spacing-sm);
    width: 100%;
    box-sizing: border-box;
    overflow-wrap: break-word;
    word-wrap: break-word;
}

/* Cards de informao */
.info-card {
    width: 100%;
    height: 100%;
    padding: var(--spacing-lg);
    border-radius: var(--border-radius-md);
    background-color: var(--bg-card-alt);
    box-shadow: var(--shadow-sm);
    display: flex;
    flex-direction: column;
}

.info-title {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: var(--spacing-md);
    color: var(--text-color);
    border-bottom: 2px solid var(--primary-light);
    padding-bottom: var(--spacing-sm);
}

.info-table {
    width: 100%;
    border-collapse: collapse;
    flex-grow: 1;
}

.info-table td {
    padding: var(--spacing-sm) 0;
    font-size: 0.95rem;
}

.info-table td:first-child {
    color: var(--text-secondary);
    width: 50%;
}

.info-table td:last-child {
    font-weight: 500;
    color: var(--text-color);
}

/* Conteiner do sumrio */
.report-summary {
    margin-bottom: var(--spacing-lg);
    width: 100%;
    box-sizing: border-box;
    padding: 0;
}

/* Responsive adjustments */
@media (max-width: 992px) {
    .summary-stats {
        padding: var(--spacing-md);
    }
    
    .score-card, .info-card {
        padding: var(--spacing-md);
    }
}

@media (max-width: 768px) {
    .summary-stats {
        flex-direction: column;
        gap: var(--spacing-md);
    }
    
    .summary-card-wrapper {
        width: 100%;
        margin-bottom: var(--spacing-md);
    }
    
    .summary-card-wrapper:last-child {
        margin-bottom: 0;
    }
    
    .score-gauge {
        max-width: 120px;
    }
}

@media (max-width: 576px) {
    .summary-stats {
        padding: var(--spacing-sm);
    }
    
    .score-metrics {
        max-width: 160px;
        gap: 5px;
    }
    
    .score-metrics .metric-item {
        width: 65px;
        padding: 4px;
    }
    
    .info-card, .score-card {
        padding: var(--spacing-sm);
    }
}


    </style>
</head>
<body>
    <div class="report-container robustness-report">
        <!-- Header comum -->
<header class="report-header">
    <div class="header-content">
        <div class="header-logo">
            <img src="data:image/png;base64, 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" alt="Logo" class="logo">
        </div>
        <div class="header-info">
            <h1>Model Validation Report</h1>
            <p class="report-subtitle">Performance Analysis Report</p>
            <div class="report-metadata">
                <div class="metadata-item"><strong>Model:</strong> primary_model</div>
                <div class="metadata-item"><strong>Date:</strong> 2025-05-07 23:36:52</div>
<div class="metadata-item"><strong>Type:</strong> RandomForestClassifier</div><div class="metadata-item"><strong>Report:</strong> Robustness</div>            </div>
        </div>
    </div>
</header>
        <!-- Summary section (inserido diretamente como o header) -->
<div class="summary-stats">
    <!-- Robustness Score Card -->
    <div class="summary-card-wrapper">
        <div class="score-card">
            <div class="score-label">Robustness Score</div>
            <div class="score-gauge">
                <svg viewBox="0 0 120 120" class="gauge-svg">
                    <!-- Fundo do medidor -->
                    <circle cx="60" cy="60" r="50" fill="none" stroke="#e6e6e6" stroke-width="10"></circle>
                    
                    <!-- Arco colorido do medidor baseado na pontuao -->
                    <circle 
                        cx="60" 
                        cy="60" 
                        r="50" 
                        fill="none" 
                            stroke="#28a745"
                        stroke-width="10" 
                        stroke-dasharray="296.54426614668597 314" 
                        transform="rotate(-90 60 60)"
                    ></circle>
                    
                    <!-- Valor no centro -->
                    <text x="60" y="65" text-anchor="middle" font-size="24" font-weight="bold" fill="white">
                        94.4%
                    </text>
                </svg>
            </div>
            <div class="score-metrics">
                <div class="metric-item">
                    <span class="metric-value">77.4%</span>
                    <span class="metric-label">Base Score</span>
                </div>
                <div class="metric-item">
                    <span class="metric-value">5.56%</span>
                    <span class="metric-label">Impact</span>
                </div>
            </div>
            <div class="score-desc">
                    <span class="score-badge excellent">Excellent</span> resistance to perturbations
            </div>
        </div>
    </div>

    <!-- Model Information Card -->
    <div class="summary-card-wrapper">
        <div class="info-card">
            <div class="info-title">Model Information</div>
            <table class="info-table">
                <tr>
                    <td><strong>Type:</strong></td>
                    <td>RandomForestClassifier</td>
                </tr>
                <tr>
                    <td><strong>Features:</strong></td>
                    <td>0</td>
                </tr>
                <tr>
                    <td><strong>Primary Metric:</strong></td>
                    <td>AUC</td>
                </tr>
                <tr>
                    <td><strong>Critical Features:</strong></td>
                    <td>3</td>
                </tr>
                <tr>
                    <td><strong>Alternative Models:</strong></td>
                    <td>3</td>
                </tr>
            </table>
        </div>
    </div>
    
    <!-- Test Summary Card -->
    <div class="summary-card-wrapper">
        <div class="info-card">
            <div class="info-title">Test Summary</div>
            <table class="info-table">
                <tr>
                    <td><strong>Perturbation Levels:</strong></td>
                    <td>6</td>
                </tr>
                <tr>
                    <td><strong>Iterations Per Level:</strong></td>
                    <td>10</td>
                </tr>
                <tr>
                    <td><strong>Max Impact Level:</strong></td>
                    <td>
                        13.09% at 1.0
                    </td>
                </tr>
                <tr>
                    <td><strong>Feature Subset Impact:</strong></td>
                    <td>
                        0%
                    </td>
                </tr>
            </table>
        </div>
    </div>
</div>
        <div class="report-content">
            <!-- Navegao em abas usando componente comum -->
<div class="main-tabs" id="main-tabs">
        <button class="tab-btn active" data-tab="overview">Overview</button>
        <button class="tab-btn " data-tab="details">Details</button>
        <button class="tab-btn " data-tab="boxplot">Box Plot</button>
        <button class="tab-btn " data-tab="feature_impact">Feature Importance</button>
        <button class="tab-btn " data-tab="importance_comparison">Importance Comparison</button>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // Ensure at least first tab is active
        if (tabButtons.length > 0 && !document.querySelector('.tab-btn.active')) {
            tabButtons[0].classList.add('active');
            const firstTabId = tabButtons[0].getAttribute('data-tab');
            document.getElementById(firstTabId)?.classList.add('active');
        }
        
        // Add click handlers
        tabButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Remove active from all buttons and contents
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                
                // Add active to clicked button
                this.classList.add('active');
                
                // Show target tab content
                const targetTab = this.getAttribute('data-tab');
                const targetContent = document.getElementById(targetTab);
                
                if (targetContent) {
                    targetContent.classList.add('active');
                    // Trigger a custom event for tab change
                    document.dispatchEvent(new CustomEvent('tabchange', { 
                        detail: { tabId: targetTab, element: targetContent }
                    }));
                }
            });
        });
    });
</script>
            <!-- Contedo das abas -->
            <div id="overview" class="tab-content active">
<div class="section">
    <h2 class="section-title">Performance Overview</h2>
    <p>This section shows how the model's performance changes under different perturbation levels.</p>
    
    <!-- Performance charts selector -->
    <div class="chart-selector" id="performance_charts_selector">
        <button class="chart-selector-option active" data-chart-type="perturbation">Perturbation Impact</button>
        <button class="chart-selector-option" data-chart-type="worst">Worst Case</button>
    </div>
    
    <!-- Performance charts section -->
    <div class="performance-charts-container">
        <div class="chart-container active" data-chart-type="perturbation">
            <div id="perturbation-chart-plot" class="chart-plot" style="min-height: 400px; width: 100%;"></div>
        </div>
        <div class="chart-container" data-chart-type="worst">
            <div id="worst-score-chart-plot" class="chart-plot" style="min-height: 400px; width: 100%;"></div>
        </div>
    </div>
</div>

<!-- Removida a condio para sempre mostrar a seo de comparao de modelos -->
<div class="section model-comparison-section">
    <h2 class="section-title">Model Comparison</h2>
    <p>Comparison of robustness between different models.</p>
    
    <!-- Model comparison charts selector -->
    <div class="chart-selector" id="model_comparison_selector">
        <button class="chart-selector-option active" data-chart-type="overview">Overview</button>
        <button class="chart-selector-option" data-chart-type="details">Details by Level</button>
    </div>
    
    <!-- Model comparison charts -->
    <div class="chart-container active" data-chart-type="overview">
        <div id="model-comparison-chart-plot" class="chart-plot" style="min-height: 400px; width: 100%;"></div>
    </div>
    <div class="chart-container" data-chart-type="details">
        <div id="model-level-details-chart-plot" class="chart-plot" style="min-height: 400px; width: 100%;"></div>
    </div>
</div>

<div class="section results-tables-section">
    <h2 class="section-title">Detailed Results</h2>
    
    <!-- Results tabs -->
    <div class="results-tabs" id="result_tables_tabs">
        <div class="tab active" data-tab="model-comparison-results">Model Comparison</div>
        <div class="tab" data-tab="raw-perturbation-results">Raw Perturbation</div>
    </div>
    
    <!-- Results tab content -->
    <div id="model-comparison-results" class="tab-content active">
        <table class="data-table" id="model-comparison-table">
            <thead>
                <tr>
                    <th>Model</th>
                    <th>Base Score</th>
                    <th>Robustness Score</th>
                    <th>Raw Impact</th>
                </tr>
            </thead>
            <tbody>
                <!-- Will be filled by JavaScript -->
            </tbody>
        </table>
    </div>
    
    <div id="raw-perturbation-results" class="tab-content">
        <table class="data-table">
            <thead>
                <tr>
                    <th>Perturbation Level</th>
                    <th>Base Score</th>
                    <th>Perturbed Score</th>
                    <th>Impact</th>
                    <th>Subset Score</th>
                </tr>
            </thead>
            <tbody id="raw-perturbation-data">
                <!-- Will be filled by JavaScript -->
            </tbody>
        </table>
    </div>
</div>            </div>
            
            <div id="details" class="tab-content">
<div class="section">
    <h2 class="section-title">Detailed Performance Analysis</h2>
    <p>Detailed analysis of the model's performance under different perturbation types and levels.</p>
    
    <!-- Model Metrics Overview -->
    <div class="card mb-6">
        <div class="card-header">
            <h3 class="card-title">Model Metrics Overview</h3>
            <p class="card-subtitle">Comparative view of model metrics</p>
        </div>
        <div class="card-body">
            <!-- Metrics Radar Chart -->
            <div id="metrics-radar-chart" class="chart-container" style="min-height: 400px;"></div>
            
            <!-- Model Selection -->
            <div class="form-group mt-4">
                <label for="model-selector">Select Model:</label>
                <select id="model-selector" class="form-control">
                    <option value="all">All Models</option>
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            
            <!-- Model Info Cards -->
            <div class="model-info mt-4">
                <div class="row">
                    <div class="col-md-4">
                        <div class="info-card">
                            <h4>Dataset Info</h4>
                            <ul>
                                <li>Samples: <span id="n-samples">-</span></li>
                                <li>Features: <span id="n-features">-</span></li>
                                <li>Test Size: <span id="test-size">-</span></li>
                            </ul>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="info-card">
                            <h4>Test Configuration</h4>
                            <ul>
                                <li>Tests: <span id="tests-list">-</span></li>
                                <li>Verbose Mode: <span id="verbose-status">-</span></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Models Comparison Table -->
    <div class="card mb-6">
        <div class="card-header">
            <h3 class="card-title">Models Comparison</h3>
            <p class="card-subtitle">Performance metrics for all models</p>
        </div>
        <div class="card-body">
            <div class="table-responsive">
                <table id="models-table" class="data-table">
                    <thead>
                        <tr>
                            <th class="sortable" data-sort="name">Model Name</th>
                            <th class="sortable" data-sort="type">Type</th>
                            <th class="sortable" data-sort="accuracy">Accuracy</th>
                            <th class="sortable" data-sort="roc_auc">ROC AUC</th>
                            <th class="sortable" data-sort="f1">F1 Score</th>
                            <th class="sortable" data-sort="precision">Precision</th>
                            <th class="sortable" data-sort="recall">Recall</th>
                        </tr>
                    </thead>
                    <tbody id="models-table-body">
                        <!-- Table rows will be populated by JavaScript -->
                        <tr>
                            <td colspan="7" class="empty-table-message">Loading model data...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Perturbation Results Container -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">Perturbation Analysis</h3>
            <p class="card-subtitle">Detailed analysis of the model's performance under different perturbation types and levels</p>
        </div>
        <div class="card-body">
            <div id="perturbation-results-container" class="mt-4">
                <!-- This container will be populated by DetailsController -->
                <div class="loading-indicator">
                    <p>Loading perturbation details...</p>
                </div>
            </div>
        </div>
    </div>
</div>            </div>
            
            <div id="boxplot" class="tab-content">
<div class="section">
    <h2 class="section-title">Performance Distribution</h2>
    <p>Distribution of model performance under different perturbation levels.</p>
    
    <div id="boxplot-chart-container" class="chart-plot">
        <!-- Boxplot chart will be rendered here by the controller -->
        <div class="chart-loading-message">
            <div class="spinner"></div>
            <p>Carregando grfico de boxplot...</p>
        </div>
    </div>
    
    <div class="table-container">
        <h3>Model Distribution Statistics</h3>
        <table class="data-table boxplot-table">
            <thead>
                <tr>
                    <th>Model</th>
                    <th>Base Score</th>
                    <th>Median</th>
                    <th>Mean</th>
                    <th>IQR</th>
                    <th>Min</th>
                    <th>Max</th>
                    <th>Std Dev</th>
                    <th>Score Drop</th>
                </tr>
            </thead>
            <tbody id="boxplot-table-body">
                <!-- Table content will be dynamically generated by BoxplotController -->
                <tr>
                    <td colspan="9" class="text-center">
                        <div class="loading-info">
                            <div class="loading-icon"></div>
                            <p>Loading statistics...</p>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Local CSS for boxplot-specific styles only -->
<style>
    /* Local styling specific to boxplot visualization */
    #boxplot-chart-container .chart-loading-message {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        text-align: center;
    }
    
    #boxplot-chart-container .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin-bottom: 10px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .boxplot-table .text-danger {
        color: #d32f2f;
    }
    
    .boxplot-table .text-warning {
        color: #f0ad4e;
    }
    
    .boxplot-table .text-success {
        color: #5cb85c;
    }
    
    .loading-info {
        text-align: center;
        padding: 20px;
    }
    
    .loading-info .loading-icon {
        font-size: 24px;
        margin-bottom: 10px;
    }
</style>            </div>
            
            <div id="feature_impact" class="tab-content">
<div class="section">
    <h2 class="section-title">Feature Importance Analysis</h2>
    <p>Analysis of how each feature contributes to model robustness.</p>
    
    <div id="feature-importance-chart" class="chart-plot" style="min-height: 500px; min-width: 100%; display: block;">
        <div class="loading-message">
            <div class="message-container">
                <span class="message-icon"></span>
                <h3>Loading Feature Importance Chart...</h3>
                <p>Please wait while the chart data is being prepared...</p>
            </div>
        </div>
    </div>
    
    <div class="feature-importance-container">
        <div class="feature-importance-header">
            <h2>Feature Importance Table</h2>
            <div class="feature-importance-controls">
                <div class="search-container">
                    <input type="text" id="feature-search" class="search-input" placeholder="Search features...">
                </div>
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="show-subset-only" class="toggle-checkbox">
                        Show feature subset only
                    </label>
                </div>
            </div>
        </div>
        
        <div class="feature-importance-table-wrapper">
            <table class="feature-importance-table">
                <thead>
                    <tr>
                        <th class="sortable" data-sort="name">Feature <span class="sort-indicator"></span></th>
                        <th class="sortable" data-sort="impact">Robustness Impact <span class="sort-indicator"></span></th>
                        <th class="sortable" data-sort="importance">Model Importance <span class="sort-indicator"></span></th>
                        <th>Feature Subset</th>
                    </tr>
                </thead>
                <tbody id="feature-impact-data">
                    <!-- Mensagem de carregamento que ser substituda por dados reais pelo FeatureImportanceHandler -->
                    <tr>
                        <td colspan="4" class="text-center py-4">
                            <div style="padding: 20px; text-align: center; background-color: #f9f9fa; border-radius: 5px;">
                                <div style="font-size: 24px; margin-bottom: 10px;"></div>
                                <p>Carregando dados de importncia de caractersticas...</p>
                            </div>
                        </td>
                    </tr>
                    <!-- Nenhum dado sinttico/demo ser exibido. O JavaScript substituir esta linha por dados reais ou uma mensagem de erro. -->
                </tbody>
            </table>
        </div>
        
        <div class="feature-importance-footer">
            <div class="table-summary-info">
                <span>Total features: <span id="total-features-count">-</span></span>
                <span>In feature subset: <span id="subset-features-count">-</span></span>
            </div>
        </div>
    </div>
</div>

<style>
    /* Estilos para garantir que o grfico seja exibido corretamente */
    #feature-importance-chart {
        min-height: 500px;
        width: 100%;
        display: block !important;
        position: relative;
        margin-bottom: 30px;
        background-color: #f9f9fa;
        border: 1px solid #eaeaea;
        border-radius: 5px;
    }
    
    .loading-message .message-container {
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.8);
        border-radius: 5px;
        text-align: center;
        max-width: 400px;
        margin: 100px auto;
    }
    
    .message-icon {
        font-size: 36px;
        display: block;
        margin-bottom: 15px;
    }
    
    #feature_impact.active {
        display: block !important;
    }
    
    /* Styles for the feature importance table */
    .feature-importance-table-wrapper {
        overflow-x: auto;
        margin-bottom: 20px;
        max-height: 500px;
        overflow-y: auto;
        border: 1px solid #eaeaea;
        border-radius: 5px;
    }
    
    .feature-importance-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
    }
    
    .feature-importance-table th {
        background-color: #f4f4f4;
        padding: 10px;
        text-align: left;
        border-bottom: 1px solid #ddd;
        cursor: pointer;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .feature-importance-table th.sortable:hover {
        background-color: #e4e4e4;
    }
    
    .feature-importance-table td {
        padding: 8px 10px;
        border-bottom: 1px solid #eee;
    }
    
    .feature-importance-table tr:hover {
        background-color: #f8f8f8;
    }
    
    /* Feature subset styling */
    .feature-subset-row {
        background-color: rgba(40, 180, 99, 0.1);
    }
    
    .feature-subset-row:hover {
        background-color: rgba(40, 180, 99, 0.2);
    }
    
    /* Subset badge styling */
    .subset-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: bold;
    }
    
    .subset-badge.included {
        background-color: rgba(40, 180, 99, 0.2);
        color: rgb(40, 180, 99);
    }
    
    .subset-badge.excluded {
        background-color: rgba(150, 150, 150, 0.2);
        color: #666;
    }
    
    /* Feature importance controls */
    .feature-importance-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        flex-wrap: wrap;
    }
    
    .feature-importance-controls {
        display: flex;
        align-items: center;
        gap: 15px;
        flex-wrap: wrap;
    }
    
    .search-container {
        position: relative;
    }
    
    .search-input {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 200px;
    }
    
    /* Feature count summary */
    .feature-importance-footer {
        margin-top: 15px;
        font-size: 14px;
        color: #666;
    }
    
    .table-summary-info {
        display: flex;
        gap: 20px;
    }
    
    .toggle-container {
        display: flex;
        align-items: center;
    }
    
    .toggle-label {
        display: flex;
        align-items: center;
        cursor: pointer;
    }
    
    .toggle-checkbox {
        margin-right: 8px;
    }
</style>

<script>
    // Feature table initialization is now handled by FeatureImportanceController in controllers/features.js
    console.log("Feature importance table will be initialized by FeatureImportanceController");
</script>            </div>
            
            <div id="importance_comparison" class="tab-content">
<div class="section">
    <h2 class="section-title">Model vs Robustness Importance Comparison</h2>
    <p>Comparison between model feature importance and robustness impact.</p>
    
    <div id="importance-comparison-chart-plot" class="chart-plot" style="min-height: 500px; min-width: 100%; display: block;">
        <!-- The chart will be rendered here by the standalone chart handler -->
        <div class="chart-loading-message">
            Loading feature comparison chart...
        </div>
    </div>
</div>

<style>
    /* Styles to ensure correct chart display */
    #importance-comparison-chart-plot {
        min-height: 500px;
        width: 100%;
        display: block !important;
        position: relative;
        margin-bottom: 30px;
        background-color: #f9f9fa;
        border: 1px solid #eaeaea;
        border-radius: 5px;
    }
    
    .chart-loading-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.8);
        border-radius: 5px;
        font-weight: bold;
    }
</style>

<!-- No inline JavaScript - initialization is handled by the standalone chart handler -->            </div>
        </div>
        
        <!-- Footer comum -->
<footer class="report-footer">
    <div class="footer-content">
        <div class="copyright">
            &copy; 2025 DeepBridge. All rights reserved.
        </div>
        <div class="footer-links">
            <button onclick="printReport()" class="btn btn-print">Print Report</button>
            <button onclick="exportData()" class="btn btn-export">Export Data</button>
        </div>
    </div>
</footer>

<script>
    function printReport() {
        window.print();
    }
    
    function exportData() {
        if (window.reportData) {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(window.reportData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "report_data.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        } else {
            alert("No report data available for export.");
        }
    }
</script>    </div>

    <!-- Inicializao de dados do relatrio -->
    <script>
        // Disponibilizar dados do relatrio para todos os componentes
        window.reportData = {"model_name": "primary_model", "model_type": "RandomForestClassifier", "timestamp": "2025-05-07 23:36:52", "metric": "AUC", "base_score": 0.7743932845744681, "robustness_score": 0.9444084909130127, "resilience_score": 0.9444084909130127, "uncertainty_score": 0.9444084909130127, "feature_importance": {"feature_0": 8.626169203199512e-05, "feature_1": -0.000508387270804607, "feature_2": -0.00014133028385141362, "feature_3": 5.690516809692856e-05, "feature_4": -9.719506018366599e-05, "feature_5": 1.0388134569380727e-05, "feature_6": 0.0013897143119511227, "feature_7": -0.0002658157196581499, "feature_8": -2.5453799345416906e-05, "feature_9": 0.0002104027697866221, "feature_10": -0.00029098255396015435, "feature_11": 0.0005851791164059549, "feature_12": 0.0006904378943078983, "feature_13": 0.004248976610914157, "feature_14": 3.515321781075109e-05, "feature_15": 0.0006239767902673061, "feature_16": 1.7964011713935787e-05, "feature_17": 0.00629555390710083, "feature_18": 0.0006021387504681262, "feature_19": 0.0037193539269014}, "model_feature_importance": {"feature_0": 0.04441968784910863, "feature_1": 0.041051945787947214, "feature_2": 0.006536648686879563, "feature_3": 0.004557487553156789, "feature_4": 0.004525462110153291, "feature_5": 0.003418093109979521, "feature_6": 0.1703488869133524, "feature_7": 0.005880585740812931, "feature_8": 0.0055375016013733125, "feature_9": 0.004257599989473853, "feature_10": 0.03794462126493219, "feature_11": 0.1193658895869036, "feature_12": 0.02534450889628226, "feature_13": 0.09108320192389514, "feature_14": 0.0033145121242270405, "feature_15": 0.052665998640822775, "feature_16": 0.09355164224442686, "feature_17": 0.14771392008763776, "feature_18": 0.04304063919840231, "feature_19": 0.09544116669023245}, "feature_subset": ["feature_6", "feature_11", "feature_17"], "feature_subset_display": "feature_6, feature_11, feature_17", "features": [], "raw_impact": 0.05559150908698728, "quantile_impact": 0, "avg_performance_gap": 0.0, "metrics": {"accuracy": 0.739, "roc_auc": 0.7874212779746349, "f1": 0.7388510959863877, "precision": 0.7392365860430896, "recall": 0.739}, "metrics_details": {}, "distance_metrics": [], "alphas": [], "shift_scenarios": [], "sensitive_features": [], "baseline_dataset": "Baseline", "target_dataset": "Target", "alternative_models": {"GLM_CLASSIFIER": {"model_name": "GLM_CLASSIFIER", "model_type": "SGDClassifier", "base_score": 0.7229918079417453, "robustness_score": 0.9753040166715845, "resilience_score": 0.0, "raw_impact": 0.0, "metrics": {"accuracy": 0.6595, "roc_auc": 0.707588618222805, "f1": 0.6591826568445812, "precision": 0.6597247027573995, "recall": 0.6595}}, "GAM_CLASSIFIER": {"model_name": "GAM_CLASSIFIER", "model_type": "LogisticGAM", "base_score": 0.47251002673796794, "robustness_score": 1.0631430714675394, "resilience_score": 0.0, "raw_impact": 0.0, "metrics": {"accuracy": 0.472, "roc_auc": 0.48684690847592554, "f1": 0.4684885820499203, "precision": 0.47216730923917566, "recall": 0.472}}, "GBM": {"model_name": "GBM", "model_type": "GradientBoostingClassifier", "base_score": 0.8713973077141883, "robustness_score": 0.7919438267291634, "resilience_score": 0.0, "raw_impact": 0.0, "metrics": {"accuracy": 0.72, "roc_auc": 0.7617011658410667, "f1": 0.7200084002100052, "precision": 0.72006864006864, "recall": 0.72}}}, "primary_model": {"base_score": 0.7743932845744681, "raw": {"by_level": {"0.1": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7746783532682898, "std_perturbed_score": 0.0012199989884020363, "impact": -0.0003681187576134109, "worst_score": 0.7719459338377517, "iterations": {"n_iterations": 10, "scores": [0.7749543996757311, 0.773953281445557, 0.7750841783763796, 0.7734061664438503, 0.7761317413812721, 0.7719459338377517, 0.7749379551143475, 0.7760872966207759, 0.7746726198941858, 0.7756099598930482]}, "perturbation": {"method": "raw", "level": 0.1, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7746888200093867, "std_perturbed_score": 0.000605394818318767, "impact": -0.0003816348111553638, "worst_score": 0.7737979470076232, "iterations": {"n_iterations": 10, "scores": [0.7743001728012288, 0.7753837360621232, 0.7756437379110251, 0.774648175275913, 0.7746290640288997, 0.7752744019513027, 0.7742728392735237, 0.773874169771874, 0.7750639560103539, 0.7737979470076232]}, "perturbation": {"method": "raw", "level": 0.1, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7746783532682898, "std_score": 0.0, "impact": -0.0003681187576134109, "worst_score": 0.7719459338377517}, "feature_subset": {"mean_score": 0.7746888200093867, "std_score": 0.0, "impact": -0.0003816348111553638, "worst_score": 0.7737979470076232}}}, "0.2": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7710501719123335, "std_perturbed_score": 0.0029424099127835666, "impact": 0.004317073415702021, "worst_score": 0.7644858807884856, "iterations": {"n_iterations": 10, "scores": [0.7717550435914211, 0.7747041756741382, 0.7732674987911026, 0.7644858807884856, 0.7710785943366708, 0.7750135112071908, 0.7689985795454545, 0.7695661391369895, 0.7719326004096029, 0.7696996956422801]}, "perturbation": {"method": "raw", "level": 0.2, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7736134568068039, "std_perturbed_score": 0.0012083603231169894, "impact": 0.0010070177301352546, "worst_score": 0.7712228175844806, "iterations": {"n_iterations": 10, "scores": [0.773443055595062, 0.7730186081323246, 0.7727761619638184, 0.7754770700591648, 0.7742159499800887, 0.7727970510012515, 0.7753759582290363, 0.7740146152150416, 0.7712228175844806, 0.7737932803077712]}, "perturbation": {"method": "raw", "level": 0.2, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7710501719123335, "std_score": 0.0, "impact": 0.004317073415702021, "worst_score": 0.7644858807884856}, "feature_subset": {"mean_score": 0.7736134568068039, "std_score": 0.0, "impact": 0.0010070177301352546, "worst_score": 0.7712228175844806}}}, "0.4": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7488332139250768, "std_perturbed_score": 0.0029039414552957206, "impact": 0.033006575803968395, "worst_score": 0.7451132985834567, "iterations": {"n_iterations": 10, "scores": [0.7475466492206166, 0.7474177594151781, 0.7452568551598588, 0.7459748602656731, 0.7451132985834567, 0.7489257701388098, 0.7504795589657527, 0.7522351270053476, 0.7517391234782114, 0.7536431370178633]}, "perturbation": {"method": "raw", "level": 0.4, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7702910109583001, "std_perturbed_score": 0.002252011447603846, "impact": 0.005297403396805293, "worst_score": 0.7654849990044373, "iterations": {"n_iterations": 10, "scores": [0.7722177135481852, 0.7733230547417227, 0.7687423555011947, 0.7730448305410172, 0.7695074720531346, 0.770385256072932, 0.7654849990044373, 0.771517264122767, 0.7687076885880076, 0.7699794754096029]}, "perturbation": {"method": "raw", "level": 0.4, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7488332139250768, "std_score": 0.0, "impact": 0.033006575803968395, "worst_score": 0.7451132985834567}, "feature_subset": {"mean_score": 0.7702910109583001, "std_score": 0.0, "impact": 0.005297403396805293, "worst_score": 0.7654849990044373}}}, "0.6": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7236645682813745, "std_perturbed_score": 0.004500381961344191, "impact": 0.06550769138057444, "worst_score": 0.7160308695528502, "iterations": {"n_iterations": 10, "scores": [0.724558041301627, 0.7183482193651155, 0.7160308695528502, 0.7203806782626011, 0.7313243116395495, 0.7266838341961542, 0.7207495697747184, 0.7253722693139151, 0.7285980700307202, 0.7245998193764933]}, "perturbation": {"method": "raw", "level": 0.6, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.765265197441404, "std_perturbed_score": 0.0025470855126285452, "impact": 0.011787404817282266, "worst_score": 0.7598465144641029, "iterations": {"n_iterations": 10, "scores": [0.7650776627744909, 0.762331198799636, 0.7598465144641029, 0.7671501219564228, 0.7685503541358517, 0.7661285591364206, 0.7644656584224597, 0.766651007296052, 0.7681459068153373, 0.7643049906132666]}, "perturbation": {"method": "raw", "level": 0.6, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7236645682813745, "std_score": 0.0, "impact": 0.06550769138057444, "worst_score": 0.7160308695528502}, "feature_subset": {"mean_score": 0.765265197441404, "std_score": 0.0, "impact": 0.011787404817282266, "worst_score": 0.7598465144641029}}}, "0.8": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.696800732805211, "std_perturbed_score": 0.008133013651746148, "impact": 0.1001978623973921, "worst_score": 0.6825084089486858, "iterations": {"n_iterations": 10, "scores": [0.6992694170269655, 0.6825084089486858, 0.6939124900443736, 0.707801922147002, 0.6958987263909433, 0.7082299251905791, 0.698506300489248, 0.6934453756115598, 0.7032387785868699, 0.6851959836158835]}, "perturbation": {"method": "raw", "level": 0.8, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7571115839045965, "std_perturbed_score": 0.0018889781617992892, "impact": 0.02231643922295622, "worst_score": 0.7540662511377859, "iterations": {"n_iterations": 10, "scores": [0.7553869271959268, 0.7562904891768119, 0.7577618329730345, 0.7601442943594265, 0.7558004856923426, 0.7584691713363294, 0.7568736044345203, 0.7540662511377859, 0.7600740716378427, 0.7562487111019456]}, "perturbation": {"method": "raw", "level": 0.8, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.696800732805211, "std_score": 0.0, "impact": 0.1001978623973921, "worst_score": 0.6825084089486858}, "feature_subset": {"mean_score": 0.7571115839045965, "std_score": 0.0, "impact": 0.02231643922295622, "worst_score": 0.7540662511377859}}}, "1.0": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.6730345193565821, "std_perturbed_score": 0.005563717180702397, "impact": 0.13088797028190013, "worst_score": 0.6659509578734782, "iterations": {"n_iterations": 10, "scores": [0.676936369325293, 0.6753683581749914, 0.6834204154340653, 0.6768434797758561, 0.6696056505290704, 0.6720741125270224, 0.6662909602912732, 0.6666491850608716, 0.6659509578734782, 0.6772057045738992]}, "perturbation": {"method": "raw", "level": 1.0, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7513674319461827, "std_perturbed_score": 0.0036130180821185177, "impact": 0.029734055146072413, "worst_score": 0.7463817520480146, "iterations": {"n_iterations": 10, "scores": [0.7535262472977586, 0.7511424525685517, 0.7601431832404142, 0.7521680154169985, 0.7472802028814427, 0.7508495615968824, 0.7501264453436114, 0.7525402402861532, 0.7495162187820003, 0.7463817520480146]}, "perturbation": {"method": "raw", "level": 1.0, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.6730345193565821, "std_score": 0.0, "impact": 0.13088797028190013, "worst_score": 0.6659509578734782}, "feature_subset": {"mean_score": 0.7513674319461827, "std_score": 0.0, "impact": 0.029734055146072413, "worst_score": 0.7463817520480146}}}}, "overall": {}}, "quantile": {"by_level": {}, "overall": {}}, "feature_importance": {"feature_0": 8.626169203199512e-05, "feature_1": -0.000508387270804607, "feature_2": -0.00014133028385141362, "feature_3": 5.690516809692856e-05, "feature_4": -9.719506018366599e-05, "feature_5": 1.0388134569380727e-05, "feature_6": 0.0013897143119511227, "feature_7": -0.0002658157196581499, "feature_8": -2.5453799345416906e-05, "feature_9": 0.0002104027697866221, "feature_10": -0.00029098255396015435, "feature_11": 0.0005851791164059549, "feature_12": 0.0006904378943078983, "feature_13": 0.004248976610914157, "feature_14": 3.515321781075109e-05, "feature_15": 0.0006239767902673061, "feature_16": 1.7964011713935787e-05, "feature_17": 0.00629555390710083, "feature_18": 0.0006021387504681262, "feature_19": 0.0037193539269014}, "feature_subset": ["feature_6", "feature_11", "feature_17"], "metric": "AUC", "model_feature_importance": {"feature_0": 0.04441968784910863, "feature_1": 0.041051945787947214, "feature_2": 0.006536648686879563, "feature_3": 0.004557487553156789, "feature_4": 0.004525462110153291, "feature_5": 0.003418093109979521, "feature_6": 0.1703488869133524, "feature_7": 0.005880585740812931, "feature_8": 0.0055375016013733125, "feature_9": 0.004257599989473853, "feature_10": 0.03794462126493219, "feature_11": 0.1193658895869036, "feature_12": 0.02534450889628226, "feature_13": 0.09108320192389514, "feature_14": 0.0033145121242270405, "feature_15": 0.052665998640822775, "feature_16": 0.09355164224442686, "feature_17": 0.14771392008763776, "feature_18": 0.04304063919840231, "feature_19": 0.09544116669023245}, "avg_raw_impact": 0.05559150908698728, "avg_quantile_impact": 0, "avg_overall_impact": 0.05559150908698728, "model_type": "RandomForestClassifier", "n_iterations": 10, "metrics": {"accuracy": 0.739, "roc_auc": 0.7874212779746349, "f1": 0.7388510959863877, "precision": 0.7392365860430896, "recall": 0.739}, "model_name": "primary_model"}, "initial_results": {"config": {"tests": ["robustness"], "verbose": false, "dataset_info": {"n_samples": 10000, "n_features": 20, "test_size": 0.2}}, "models": {"primary_model": {"name": "primary_model", "type": "RandomForestClassifier", "metrics": {"accuracy": 0.739, "roc_auc": 0.7874212779746349, "f1": 0.7388510959863877, "precision": 0.7392365860430896, "recall": 0.739}, "hyperparameters": {"bootstrap": true, "ccp_alpha": 0.0, "class_weight": null, "criterion": "gini", "max_depth": 5, "max_features": "sqrt", "max_leaf_nodes": null, "max_samples": null, "min_impurity_decrease": 0.0, "min_samples_leaf": 1, "min_samples_split": 2, "min_weight_fraction_leaf": 0.0, "monotonic_cst": null, "n_estimators": 50, "n_jobs": null, "oob_score": false, "random_state": 42, "verbose": 0, "warm_start": false}, "feature_importance": {"feature_6": 0.17034888691335243, "feature_17": 0.14771392008763778, "feature_11": 0.11936588958690363, "feature_19": 0.09544116669023248, "feature_16": 0.09355164224442687, "feature_13": 0.09108320192389516, "feature_15": 0.05266599864082279, "feature_0": 0.04441968784910864, "feature_18": 0.043040639198402314, "feature_1": 0.04105194578794722, "feature_10": 0.0379446212649322, "feature_12": 0.025344508896282265, "feature_2": 0.0065366486868795644, "feature_7": 0.0058805857408129325, "feature_8": 0.005537501601373313, "feature_3": 0.00455748755315679, "feature_4": 0.004525462110153292, "feature_9": 0.0042575999894738535, "feature_5": 0.0034180931099795217, "feature_14": 0.0033145121242270413}}, "GLM_CLASSIFIER": {"name": "GLM_CLASSIFIER", "type": "SGDClassifier", "metrics": {"accuracy": 0.6595, "roc_auc": 0.707588618222805, "f1": 0.6591826568445812, "precision": 0.6597247027573995, "recall": 0.6595}, "hyperparameters": {"alpha": 0.001, "average": false, "class_weight": null, "early_stopping": false, "epsilon": 0.1, "eta0": 0.0, "fit_intercept": true, "l1_ratio": 0.5, "learning_rate": "optimal", "loss": "log_loss", "max_iter": 1000, "n_iter_no_change": 5, "n_jobs": null, "penalty": "elasticnet", "power_t": 0.5, "random_state": 42, "shuffle": true, "tol": 0.001, "validation_fraction": 0.1, "verbose": 0, "warm_start": false}, "feature_importance": {"feature_6": 0.44653529829201, "feature_11": 0.37609566912222736, "feature_18": 0.22734097038863, "feature_7": 0.10601530924861681, "feature_5": 0.06128417065808743, "feature_16": 0.05625216708187674, "feature_14": 0.03747914235993568, "feature_4": 0.026723452423834587, "feature_9": 0.0006227293517354285, "feature_0": 0.0, "feature_1": 0.0, "feature_2": 0.0, "feature_3": 0.0, "feature_8": 0.0, "feature_10": 0.0, "feature_12": 0.0, "feature_13": 0.0, "feature_15": 0.0, "feature_17": 0.0, "feature_19": 0.0}}, "GAM_CLASSIFIER": {"name": "GAM_CLASSIFIER", "type": "LogisticGAM", "metrics": {"accuracy": 0.472, "roc_auc": 0.48684690847592554, "f1": 0.4684885820499203, "precision": 0.47216730923917566, "recall": 0.472}, "hyperparameters": {"n_splines": "10", "spline_order": "3", "lam": "0.6", "max_iter": "100", "random_state": "42", "model": "<statsmodels.gam.generalized_additive_model.GLMGamResultsWrapper object at 0x7fdd45fe8a40>", "smoother": "<statsmodels.gam.smooth_basis.BSplines object at 0x7fdd45f87170>"}}, "GBM": {"name": "GBM", "type": "GradientBoostingClassifier", "metrics": {"accuracy": 0.72, "roc_auc": 0.7617011658410667, "f1": 0.7200084002100052, "precision": 0.72006864006864, "recall": 0.72}, "hyperparameters": {"ccp_alpha": 0.0, "criterion": "friedman_mse", "init": null, "learning_rate": 0.1, "loss": "log_loss", "max_depth": 5, "max_features": null, "max_leaf_nodes": null, "min_impurity_decrease": 0.0, "min_samples_leaf": 1, "min_samples_split": 2, "min_weight_fraction_leaf": 0.0, "n_estimators": 100, "n_iter_no_change": null, "random_state": 42, "subsample": 1.0, "tol": 0.0001, "validation_fraction": 0.1, "verbose": 0, "warm_start": false}, "feature_importance": {"feature_6": 0.22930332557722669, "feature_17": 0.19053554839462544, "feature_13": 0.10452721880603731, "feature_1": 0.05042279320836686, "feature_19": 0.044792295103599, "feature_16": 0.03673596785548919, "feature_7": 0.03538933849657314, "feature_14": 0.0315208816432807, "feature_3": 0.031494832424367576, "feature_9": 0.030342584572762076, "feature_5": 0.02920219155112813, "feature_2": 0.027905801602033077, "feature_8": 0.027230752476294782, "feature_4": 0.023905519163165797, "feature_10": 0.021174578240922417, "feature_0": 0.01912664116114662, "feature_18": 0.01802761802660539, "feature_11": 0.01650670684373592, "feature_12": 0.016313486168707533, "feature_15": 0.015541918683932345}}}, "test_configs": {"robustness": {"quick": {"perturbation_methods": ["raw", "quantile"], "levels": [0.1, 0.2], "n_trials": 3}, "medium": {"perturbation_methods": ["raw", "quantile", "adversarial"], "levels": [0.1, 0.2, 0.4], "n_trials": 6}, "full": {"perturbation_methods": ["raw", "quantile", "adversarial", "custom"], "levels": [0.1, 0.2, 0.4, 0.6, 0.8, 1.0], "n_trials": 10}}}}, "config": {"name": "full", "tests": ["robustness"]}, "experiment_type": "binary_classification", "raw": {"by_level": {"0.1": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7746783532682898, "std_perturbed_score": 0.0012199989884020363, "impact": -0.0003681187576134109, "worst_score": 0.7719459338377517, "iterations": {"n_iterations": 10, "scores": [0.7749543996757311, 0.773953281445557, 0.7750841783763796, 0.7734061664438503, 0.7761317413812721, 0.7719459338377517, 0.7749379551143475, 0.7760872966207759, 0.7746726198941858, 0.7756099598930482]}, "perturbation": {"method": "raw", "level": 0.1, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7746888200093867, "std_perturbed_score": 0.000605394818318767, "impact": -0.0003816348111553638, "worst_score": 0.7737979470076232, "iterations": {"n_iterations": 10, "scores": [0.7743001728012288, 0.7753837360621232, 0.7756437379110251, 0.774648175275913, 0.7746290640288997, 0.7752744019513027, 0.7742728392735237, 0.773874169771874, 0.7750639560103539, 0.7737979470076232]}, "perturbation": {"method": "raw", "level": 0.1, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7746783532682898, "std_score": 0.0, "impact": -0.0003681187576134109, "worst_score": 0.7719459338377517}, "feature_subset": {"mean_score": 0.7746888200093867, "std_score": 0.0, "impact": -0.0003816348111553638, "worst_score": 0.7737979470076232}}}, "0.2": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7710501719123335, "std_perturbed_score": 0.0029424099127835666, "impact": 0.004317073415702021, "worst_score": 0.7644858807884856, "iterations": {"n_iterations": 10, "scores": [0.7717550435914211, 0.7747041756741382, 0.7732674987911026, 0.7644858807884856, 0.7710785943366708, 0.7750135112071908, 0.7689985795454545, 0.7695661391369895, 0.7719326004096029, 0.7696996956422801]}, "perturbation": {"method": "raw", "level": 0.2, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7736134568068039, "std_perturbed_score": 0.0012083603231169894, "impact": 0.0010070177301352546, "worst_score": 0.7712228175844806, "iterations": {"n_iterations": 10, "scores": [0.773443055595062, 0.7730186081323246, 0.7727761619638184, 0.7754770700591648, 0.7742159499800887, 0.7727970510012515, 0.7753759582290363, 0.7740146152150416, 0.7712228175844806, 0.7737932803077712]}, "perturbation": {"method": "raw", "level": 0.2, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7710501719123335, "std_score": 0.0, "impact": 0.004317073415702021, "worst_score": 0.7644858807884856}, "feature_subset": {"mean_score": 0.7736134568068039, "std_score": 0.0, "impact": 0.0010070177301352546, "worst_score": 0.7712228175844806}}}, "0.4": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7488332139250768, "std_perturbed_score": 0.0029039414552957206, "impact": 0.033006575803968395, "worst_score": 0.7451132985834567, "iterations": {"n_iterations": 10, "scores": [0.7475466492206166, 0.7474177594151781, 0.7452568551598588, 0.7459748602656731, 0.7451132985834567, 0.7489257701388098, 0.7504795589657527, 0.7522351270053476, 0.7517391234782114, 0.7536431370178633]}, "perturbation": {"method": "raw", "level": 0.4, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7702910109583001, "std_perturbed_score": 0.002252011447603846, "impact": 0.005297403396805293, "worst_score": 0.7654849990044373, "iterations": {"n_iterations": 10, "scores": [0.7722177135481852, 0.7733230547417227, 0.7687423555011947, 0.7730448305410172, 0.7695074720531346, 0.770385256072932, 0.7654849990044373, 0.771517264122767, 0.7687076885880076, 0.7699794754096029]}, "perturbation": {"method": "raw", "level": 0.4, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7488332139250768, "std_score": 0.0, "impact": 0.033006575803968395, "worst_score": 0.7451132985834567}, "feature_subset": {"mean_score": 0.7702910109583001, "std_score": 0.0, "impact": 0.005297403396805293, "worst_score": 0.7654849990044373}}}, "0.6": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7236645682813745, "std_perturbed_score": 0.004500381961344191, "impact": 0.06550769138057444, "worst_score": 0.7160308695528502, "iterations": {"n_iterations": 10, "scores": [0.724558041301627, 0.7183482193651155, 0.7160308695528502, 0.7203806782626011, 0.7313243116395495, 0.7266838341961542, 0.7207495697747184, 0.7253722693139151, 0.7285980700307202, 0.7245998193764933]}, "perturbation": {"method": "raw", "level": 0.6, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.765265197441404, "std_perturbed_score": 0.0025470855126285452, "impact": 0.011787404817282266, "worst_score": 0.7598465144641029, "iterations": {"n_iterations": 10, "scores": [0.7650776627744909, 0.762331198799636, 0.7598465144641029, 0.7671501219564228, 0.7685503541358517, 0.7661285591364206, 0.7644656584224597, 0.766651007296052, 0.7681459068153373, 0.7643049906132666]}, "perturbation": {"method": "raw", "level": 0.6, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.7236645682813745, "std_score": 0.0, "impact": 0.06550769138057444, "worst_score": 0.7160308695528502}, "feature_subset": {"mean_score": 0.765265197441404, "std_score": 0.0, "impact": 0.011787404817282266, "worst_score": 0.7598465144641029}}}, "0.8": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.696800732805211, "std_perturbed_score": 0.008133013651746148, "impact": 0.1001978623973921, "worst_score": 0.6825084089486858, "iterations": {"n_iterations": 10, "scores": [0.6992694170269655, 0.6825084089486858, 0.6939124900443736, 0.707801922147002, 0.6958987263909433, 0.7082299251905791, 0.698506300489248, 0.6934453756115598, 0.7032387785868699, 0.6851959836158835]}, "perturbation": {"method": "raw", "level": 0.8, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7571115839045965, "std_perturbed_score": 0.0018889781617992892, "impact": 0.02231643922295622, "worst_score": 0.7540662511377859, "iterations": {"n_iterations": 10, "scores": [0.7553869271959268, 0.7562904891768119, 0.7577618329730345, 0.7601442943594265, 0.7558004856923426, 0.7584691713363294, 0.7568736044345203, 0.7540662511377859, 0.7600740716378427, 0.7562487111019456]}, "perturbation": {"method": "raw", "level": 0.8, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.696800732805211, "std_score": 0.0, "impact": 0.1001978623973921, "worst_score": 0.6825084089486858}, "feature_subset": {"mean_score": 0.7571115839045965, "std_score": 0.0, "impact": 0.02231643922295622, "worst_score": 0.7540662511377859}}}, "1.0": {"runs": {"all_features": [{"base_score": 0.7743932845744681, "perturbed_score": 0.6730345193565821, "std_perturbed_score": 0.005563717180702397, "impact": 0.13088797028190013, "worst_score": 0.6659509578734782, "iterations": {"n_iterations": 10, "scores": [0.676936369325293, 0.6753683581749914, 0.6834204154340653, 0.6768434797758561, 0.6696056505290704, 0.6720741125270224, 0.6662909602912732, 0.6666491850608716, 0.6659509578734782, 0.6772057045738992]}, "perturbation": {"method": "raw", "level": 1.0, "features": null}}], "feature_subset": [{"base_score": 0.7743932845744681, "perturbed_score": 0.7513674319461827, "std_perturbed_score": 0.0036130180821185177, "impact": 0.029734055146072413, "worst_score": 0.7463817520480146, "iterations": {"n_iterations": 10, "scores": [0.7535262472977586, 0.7511424525685517, 0.7601431832404142, 0.7521680154169985, 0.7472802028814427, 0.7508495615968824, 0.7501264453436114, 0.7525402402861532, 0.7495162187820003, 0.7463817520480146]}, "perturbation": {"method": "raw", "level": 1.0, "features": ["feature_6", "feature_11", "feature_17"]}}]}, "overall_result": {"all_features": {"mean_score": 0.6730345193565821, "std_score": 0.0, "impact": 0.13088797028190013, "worst_score": 0.6659509578734782}, "feature_subset": {"mean_score": 0.7513674319461827, "std_score": 0.0, "impact": 0.029734055146072413, "worst_score": 0.7463817520480146}}}}, "overall": {}}, "quantile": {"by_level": {}, "overall": {}}, "avg_raw_impact": 0.05559150908698728, "avg_quantile_impact": 0, "avg_overall_impact": 0.05559150908698728, "n_iterations": 10, "perturbation_chart_data": {"modelName": "primary_model", "levels": [0.1, 0.2, 0.4, 0.6, 0.8, 1.0], "scores": [0.7746783532682898, 0.7710501719123335, 0.7488332139250768, 0.7236645682813745, 0.696800732805211, 0.6730345193565821], "worstScores": [0.7719459338377517, 0.7644858807884856, 0.7451132985834567, 0.7160308695528502, 0.6825084089486858, 0.6659509578734782], "baseScore": 0.7743932845744681, "metric": "AUC", "alternativeModels": {"GLM_CLASSIFIER": {"baseScore": 0.7229918079417453, "scores": [0.7223660257139606, 0.7206940138240984, 0.7122424426129251, 0.7029849101149164, 0.6911004256030264, 0.6814330679684834], "worstScores": [0.7211082389919217, 0.7194548939014678, 0.7098028252645352, 0.69684095531346, 0.6847733139435658, 0.6730398971726022]}, "GAM_CLASSIFIER": {"baseScore": 0.47251002673796794, "scores": [0.500551626144897, 0.5016700340980202, 0.49490205263681875, 0.5083325259201843, 0.5026151297075889, 0.5060031982449653], "worstScores": [0.4865454598788258, 0.480412749601775, 0.4753987139464103, 0.49435751543122086, 0.4839921083883263, 0.49222927807486627]}, "GBM": {"baseScore": 0.8713973077141883, "scores": [0.8106049420795882, 0.7798839458413925, 0.7102903842871773, 0.6545886992974173, 0.6111639904994879, 0.574054348830925], "worstScores": [0.8060612875469337, 0.773403277534418, 0.6954005006257824, 0.640715222863807, 0.5916264293434975, 0.5613346583797929]}}}};
        
        // Extrair dados do grfico, se disponveis
        if (window.reportData && window.reportData.chart_data_json) {
            try {
                // Limpar dados JSON antes de analisar
                const jsonStr = window.reportData.chart_data_json;
                let cleanJson = jsonStr;
                
                // Corrigir vrgulas finais
                cleanJson = cleanJson.replace(/,(\s*})/g, '$1');
                cleanJson = cleanJson.replace(/,(\s*\])/g, '$1');
                
                // Tratar outros problemas de sintaxe
                cleanJson = cleanJson.replace(/\bNaN\b/g, 'null');
                cleanJson = cleanJson.replace(/\bInfinity\b/g, 'null');
                cleanJson = cleanJson.replace(/\b-Infinity\b/g, 'null');
                cleanJson = cleanJson.replace(/\bundefined\b/g, 'null');
                
                // Analisar os dados JSON limpos
                window.chartData = JSON.parse(cleanJson);
                console.log("Dados de grfico carregados com sucesso");
            } catch (e) {
                console.error("Erro ao analisar dados do grfico:", e);
                window.chartData = {
                    perturbation_levels: [],
                    feature_importance: {},
                    model_feature_importance: {},
                    boxplot_data: { models: [] }
                };
            }
        }
        
        // Configurao bsica do relatrio
        window.reportConfig = {
            reportType: 'robustness',
            modelName: 'primary_model',
            // Incluir dados de importncia de caractersticas diretamente para acesso mais fcil
            feature_importance: {"feature_0": 8.626169203199512e-05, "feature_1": -0.000508387270804607, "feature_10": -0.00029098255396015435, "feature_11": 0.0005851791164059549, "feature_12": 0.0006904378943078983, "feature_13": 0.004248976610914157, "feature_14": 3.515321781075109e-05, "feature_15": 0.0006239767902673061, "feature_16": 1.7964011713935787e-05, "feature_17": 0.00629555390710083, "feature_18": 0.0006021387504681262, "feature_19": 0.0037193539269014, "feature_2": -0.00014133028385141362, "feature_3": 5.690516809692856e-05, "feature_4": -9.719506018366599e-05, "feature_5": 1.0388134569380727e-05, "feature_6": 0.0013897143119511227, "feature_7": -0.0002658157196581499, "feature_8": -2.5453799345416906e-05, "feature_9": 0.0002104027697866221},
            model_feature_importance: {"feature_0": 0.04441968784910863, "feature_1": 0.041051945787947214, "feature_10": 0.03794462126493219, "feature_11": 0.1193658895869036, "feature_12": 0.02534450889628226, "feature_13": 0.09108320192389514, "feature_14": 0.0033145121242270405, "feature_15": 0.052665998640822775, "feature_16": 0.09355164224442686, "feature_17": 0.14771392008763776, "feature_18": 0.04304063919840231, "feature_19": 0.09544116669023245, "feature_2": 0.006536648686879563, "feature_3": 0.004557487553156789, "feature_4": 0.004525462110153291, "feature_5": 0.003418093109979521, "feature_6": 0.1703488869133524, "feature_7": 0.005880585740812931, "feature_8": 0.0055375016013733125, "feature_9": 0.004257599989473853},
            feature_subset: ["feature_6", "feature_11", "feature_17"]
        };
    </script>
    
    <!-- Scripts combinados -->
    <script>
        // ===== Critical Fixes (Load First) ===== //

// Global Error Handler
/**
 * Global JavaScript error handler
 * Intercepts and handles JavaScript syntax errors, particularly "Illegal continue" errors
 * Version 1.0 - May 7, 2024
 */

// Execute immediately to capture errors as early as possible
(function() {
    // Store original error handler
    const originalOnError = window.onerror;
    
    // Install global error handler
    window.onerror = function(message, source, lineno, colno, error) {
        // Check for illegal continue errors
        if (message && (
            message.includes("Illegal continue") || 
            message.includes("no surrounding iteration statement") ||
            message.includes("Unexpected token 'continue'")
        )) {
            console.error("Caught illegal continue statement:", {
                message,
                source,
                lineno,
                colno
            });
            
            // Log to console for debugging
            console.warn("%cIllegal continue statement detected and intercepted", 
                         "background: #f8d7da; color: #721c24; padding: 5px; border-radius: 3px;");
            console.info(`Source: ${source}, Line: ${lineno}, Column: ${colno}`);
            
            // Attempt to add visual indicator in the UI
            setTimeout(function() {
                const errorBanner = document.createElement('div');
                errorBanner.style.cssText = "position: fixed; bottom: 10px; right: 10px; background-color: #f8d7da; color: #721c24; padding: 15px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 9999; max-width: 400px; font-size: 14px;";
                errorBanner.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 5px;">JavaScript Syntax Error Intercepted</div>
                    <div>A syntax error was caught by the error handler. The error was in a callback function using 'continue' outside of a loop.</div>
                    <div style="margin-top: 8px; font-size: 12px;">File: ${source.split('/').pop()}, Line: ${lineno}</div>
                    <button style="margin-top: 10px; background: #842029; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Dismiss</button>
                `;
                
                document.body.appendChild(errorBanner);
                
                // Add dismiss functionality
                const dismissButton = errorBanner.querySelector('button');
                if (dismissButton) {
                    dismissButton.addEventListener('click', function() {
                        errorBanner.remove();
                    });
                }
                
                // Auto-dismiss after 10 seconds
                setTimeout(function() {
                    if (document.body.contains(errorBanner)) {
                        errorBanner.remove();
                    }
                }, 10000);
            }, 1000);
            
            // Return true to indicate we've handled the error
            return true;
        }
        
        // For other errors, call the original handler if it exists
        if (typeof originalOnError === 'function') {
            return originalOnError(message, source, lineno, colno, error);
        }
        
        // Return false to let the error propagate
        return false;
    };
    
    // Also intercept unhandled promise rejections
    window.addEventListener('unhandledrejection', function(event) {
        const error = event.reason;
        
        // Check for illegal continue errors
        if (error && error.toString && (
            error.toString().includes("Illegal continue") || 
            error.toString().includes("no surrounding iteration statement") ||
            error.toString().includes("Unexpected token 'continue'")
        )) {
            console.error("Caught illegal continue statement in promise:", error);
            
            // Prevent the error from propagating
            event.preventDefault();
        }
    });
    
    console.log("Global JavaScript error handler installed to catch illegal continue statements");
})();

// Also run when document is ready to ensure proper initialization
document.addEventListener('DOMContentLoaded', function() {
    console.log("Global error handler initialized and ready");
});

// Syntax Fixer
// JavaScript Syntax Fixer
// This script applies runtime fixes for common JavaScript syntax errors
// Include this script in the <head> of your HTML document before any other scripts

(function() {
    // Define our safe return object - this will be available for any other script
    window.__safeFallbackObject = {
        levels: [],
        modelScores: {},
        modelNames: {},
        metricName: ""
    };
    
    // Fix trailing commas in JavaScript object literals at runtime
    function fixTrailingCommas() {
        console.log("Running syntax fixer to fix trailing commas");
        
        // Find all script tags
        const scripts = document.querySelectorAll('script:not([src])');
        
        // Process each inline script
        for (const script of scripts) {
            if (!script.textContent) {
                // Usando if/else ao invs de continue
                continue;
            }
            
            let content = script.textContent;
            let needsReplacement = false;
            
            // Fix 1: Trailing commas in object literals - matches a return statement with an object that ends with a comma
            if (content.includes('return {') && 
                (content.includes('metricName,') || 
                 content.includes('robustnessScores,') || 
                 content.includes('baseScores,'))) {
                
                // First fix: return { ...  } pattern
                const fixedContent1 = content.replace(/return\s*\{\s*[\s\S]*?,(\s*\})/g, 'return $1');
                
                // Second fix: specific variable pattern for model data extraction
                const fixedContent2 = fixedContent1.replace(
                    /(return\s*\{\s*)(levels,\s*modelScores,\s*modelNames,\s*metricName),(\s*\})/g, 
                    '$1$2$3'
                );
                
                // Third fix: specific variable pattern for model comparison data
                const fixedContent3 = fixedContent2.replace(
                    /(return\s*\{\s*)(models,\s*baseScores,\s*robustnessScores),(\s*\})/g, 
                    '$1$2$3'
                );
                
                // Check if any fixes were applied
                if (content !== fixedContent3) {
                    content = fixedContent3;
                    needsReplacement = true;
                    console.log("Fixed trailing commas in return statements");
                }
            }
            
            // Fix 2: Any comma before closing brace
            if (content.includes('},') || content.includes(' }')) {
                const fixedContent = content.replace(/,(\s*\})/g, '$1');
                
                if (content !== fixedContent) {
                    content = fixedContent;
                    needsReplacement = true;
                    console.log("Fixed generic trailing commas");
                }
            }
            
            // Fix 3: Replace illegal continue statements with return null or early returns
            // Este  um ponto comum de erro em callbacks de map() ou em funes de callback internas
            if (content.includes('continue')) {
                
                // Primeiro, verificar por 'continue' dentro de funes map(), forEach(), e filter()
                if (content.includes('map(') || content.includes('forEach(') || content.includes('filter(')) {
                    // Procurar por padres de 'continue' fora de loops que precisam ser substitudos em callbacks
                    const fixedContent = content.replace(
                        /if\s*\([^)]*\)\s*\{\s*[^{}]*continue;\s*\}/g, 
                        function(match) {
                            // Substituir 'continue' por 'return null' dentro do callback de map
                            return match.replace(/continue;/, 'return null;');
                        }
                    );
                    
                    if (content !== fixedContent) {
                        content = fixedContent;
                        needsReplacement = true;
                        console.log("Fixed illegal continue statements in callbacks");
                    }
                }
                
                // Segundo, verificar por qualquer 'continue' em funes de callback inline
                const fixedContent2 = content.replace(
                    /function\s*\([^)]*\)\s*\{(?:[^{}]|{[^{}]*})*continue;(?:[^{}]|{[^{}]*})*\}/g,
                    function(match) {
                        // Substituir 'continue' por 'return null' dentro de funes
                        return match.replace(/continue;/, 'return null;');
                    }
                );
                
                if (content !== fixedContent2) {
                    content = fixedContent2;
                    needsReplacement = true;
                    console.log("Fixed illegal continue statements in inline functions");
                }
                
                // Terceiro, verificar por qualquer 'continue' imediatamente aps if, sem estar em um loop
                const fixedContent3 = content.replace(
                    /if\s*\([^)]*\)\s*continue;(?!\s*\})/g,
                    function(match) {
                        // Substituir 'continue' por 'return null' ou 'return'
                        if (content.includes('map(') || content.includes('filter(')) {
                            return match.replace(/continue;/, 'return null;');
                        } else if (content.includes('forEach(')) {
                            return match.replace(/continue;/, 'return;');
                        } else {
                            return match.replace(/continue;/, '{ /* skip */ }');
                        }
                    }
                );
                
                if (content !== fixedContent3) {
                    content = fixedContent3;
                    needsReplacement = true;
                    console.log("Fixed standalone illegal continue statements");
                }
            }
            
            // Replace the script if needed
            if (needsReplacement) {
                try {
                    const newScript = document.createElement('script');
                    newScript.textContent = content;
                    script.parentNode.replaceChild(newScript, script);
                    console.log("Replaced script with fixed version");
                } catch (error) {
                    console.error("Error replacing script:", error);
                }
            }
        }
    }
    
    // Add error handling for specific JavaScript errors
    function addErrorHandling() {
        window.addEventListener('error', function(event) {
            // Verificar especificamente por erro de continue ilegal
            if (event.error && 
                (event.error.toString().includes("Unexpected token") || 
                 event.error.toString().includes("Illegal continue") ||
                 event.error.toString().includes("no surrounding iteration statement"))) {
                
                console.warn("Caught syntax error:", event.error);
                
                // Try to monkeypatch global objects after error
                if (typeof window.ChartManager !== 'undefined') {
                    console.log("Adding safe fallbacks for ChartManager");
                    
                    // Add safe version of extractModelLevelDetailsData
                    if (typeof window.ChartManager.extractModelLevelDetailsData === 'function') {
                        window.ChartManager.extractModelLevelDetailsData = function() {
                            console.log("Using safe replacement for extractModelLevelDetailsData");
                            return {
                                levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                                modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                                modelNames: { 'primary': 'Primary Model' },
                                metricName: 'Score'
                            };
                        };
                    }
                    
                    // Add safe version of extractModelComparisonData
                    if (typeof window.ChartManager.extractModelComparisonData === 'function') {
                        window.ChartManager.extractModelComparisonData = function() {
                            console.log("Using safe replacement for extractModelComparisonData");
                            return {
                                models: ['Primary Model', 'Alternative Model 1'],
                                baseScores: [0.8, 0.75],
                                robustnessScores: [0.7, 0.65]
                            };
                        };
                    }
                    
                    // Add safe version of extractPerturbationChartData
                    if (typeof window.ChartManager.extractPerturbationChartData === 'function') {
                        window.ChartManager.extractPerturbationChartData = function() {
                            console.log("Using safe replacement for extractPerturbationChartData");
                            return {
                                levels: [0, 0.1, 0.2, 0.3, 0.4, 0.5],
                                perturbedScores: [0.9, 0.85, 0.8, 0.75, 0.7, 0.65],
                                worstScores: [0.85, 0.8, 0.75, 0.7, 0.65, 0.6],
                                featureSubsetScores: [0.9, 0.87, 0.84, 0.81, 0.78, 0.75],
                                featureSubsetWorstScores: [0.85, 0.82, 0.79, 0.76, 0.73, 0.7],
                                baseScore: 0.9,
                                metricName: 'Score'
                            };
                        };
                    }
                }
                
                // Verificar ModelComparisonManager
                if (typeof window.ModelComparisonManager !== 'undefined') {
                    if (typeof window.ModelComparisonManager.generatePerturbationScores === 'function') {
                        window.ModelComparisonManager.generatePerturbationScores = function(levels) {
                            console.log("Using safe replacement for generatePerturbationScores");
                            const scores = {};
                            Object.keys(this.state.modelData || {}).forEach(key => {
                                scores[key] = levels.map(l => 0.9 - (l * 0.2));
                            });
                            return scores;
                        };
                    }
                }
                
                // Prevent the error from propagating
                event.preventDefault();
            }
        }, true);
    }
    
    // Run the fixes when the DOM is ready
    function runFixes() {
        console.log("Running JavaScript syntax fixes");
        
        // Fix scripts in the current DOM
        fixTrailingCommas();
        
        // Add error handling
        addErrorHandling();
        
        // Carregar script adicional de correo
        try {
            // Carrega o script fixed_syntax.js com correes especficas
            // Marcar como de alta prioridade para carregar antes de outros scripts
            const fixedSyntaxScript = document.createElement('script');
            fixedSyntaxScript.src = 'js/fixed_syntax.js';
            fixedSyntaxScript.async = false;
            fixedSyntaxScript.defer = false;
            
            // Usar atributo de prioridade para navegadores modernos
            fixedSyntaxScript.setAttribute('fetchpriority', 'high');
            
            // Adicionar ao incio do head para ser um dos primeiros a ser carregado
            document.head.insertBefore(fixedSyntaxScript, document.head.firstChild);
            console.log("Loaded additional syntax fixes from fixed_syntax.js with high priority");
            
            // Carregar tambm os scripts corretivos para arquivos especficos
            const safePatchesScript = document.createElement('script');
            safePatchesScript.src = 'js/safe_chart_manager.js';
            safePatchesScript.async = false;
            document.head.insertBefore(safePatchesScript, document.head.firstChild.nextSibling);
            console.log("Loaded safe_chart_manager.js with high priority");
            
            const modelFixScript = document.createElement('script');
            modelFixScript.src = 'js/model_chart_fix.js';
            modelFixScript.async = false;
            document.head.insertBefore(modelFixScript, document.head.firstChild.nextSibling.nextSibling);
            console.log("Loaded model_chart_fix.js with high priority");
        } catch (error) {
            console.error("Error loading syntax fix scripts:", error);
        }
        
        // Setup MutationObserver to fix dynamically added scripts
        const observer = new MutationObserver(function(mutations) {
            // Check if any scripts were added
            let scriptAdded = false;
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.tagName === 'SCRIPT') {
                            scriptAdded = true;
                        } else if (node.querySelectorAll) {
                            const scripts = node.querySelectorAll('script');
                            if (scripts.length > 0) {
                                scriptAdded = true;
                            }
                        }
                    });
                }
            });
            
            // If scripts were added, run the fixer again
            if (scriptAdded) {
                console.log("New scripts detected, running fixes");
                fixTrailingCommas();
            }
        });
        
        // Start observing the document
        observer.observe(document, {
            childList: true,
            subtree: true
        });
    }
    
    // Run fixes when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', runFixes);
    } else {
        runFixes();
    }
})();

// Fixed Syntax
/**
 * Fixed syntax corrections for specific files
 * This script manually fixes known issues in the report JavaScript
 * Version 2.0 - May 7, 2024
 */

// Wait for document to be ready
document.addEventListener('DOMContentLoaded', function() {
    console.log("Fixing specific syntax issues in the report code...");
    
    // Apply all fixes
    fixIllegalContinueStatements();
    fixFeatureImportanceHandlers();
    fixModelComparisonManager();
    fixFeatureMapFunctions();
    
    console.log("All specific fixes applied");
});

/**
 * Fix illegal continue statements in the overview.js file
 */
function fixIllegalContinueStatements() {
    console.log("Fixing illegal continue statements...");
    
    // Fix ChartManager if it exists
    if (window.ChartManager) {
        // Find and fix the model comparison chart function
        if (typeof ChartManager.initializeModelComparisonChart === 'function') {
            console.log("Patching ChartManager.initializeModelComparisonChart");
            
            const originalFunc = ChartManager.initializeModelComparisonChart;
            
            ChartManager.initializeModelComparisonChart = function(containerId) {
                try {
                    // Call the original function
                    return originalFunc.call(ChartManager, containerId);
                } catch (error) {
                    console.error("Error in initializeModelComparisonChart:", error);
                    
                    // Show error message in the container
                    const container = document.getElementById(containerId);
                    if (container) {
                        container.innerHTML = `
                            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Erro ao inicializar grfico</h3>
                                <p style="color: #333; font-size: 16px; line-height: 1.4;">
                                    No foi possvel inicializar o grfico de comparao de modelos. Erro: ${error.message}
                                </p>
                            </div>`;
                    }
                }
            };
        }
        
        // Fix extractModelLevelDetailsData if it exists
        if (typeof ChartManager.extractModelLevelDetailsData === 'function') {
            console.log("Patching ChartManager.extractModelLevelDetailsData");
            
            const originalFunc = ChartManager.extractModelLevelDetailsData;
            
            ChartManager.extractModelLevelDetailsData = function() {
                try {
                    // Call the original function
                    return originalFunc.call(ChartManager);
                } catch (error) {
                    console.error("Error in extractModelLevelDetailsData:", error);
                    
                    // Return safe fallback data
                    return {
                        levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                        modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                        modelNames: { 'primary': 'Primary Model' },
                        metricName: 'Score'
                    };
                }
            };
        }
    }
    
    // Add more fixes here as needed for other specific issues
}

/**
 * Fix issues in ModelComparisonManager
 */
function fixModelComparisonManager() {
    if (window.ModelComparisonManager) {
        console.log("Patching ModelComparisonManager...");
        
        // Fix generatePerturbationScores method
        if (typeof ModelComparisonManager.generatePerturbationScores === 'function') {
            console.log("Patching ModelComparisonManager.generatePerturbationScores");
            
            const originalFunc = ModelComparisonManager.generatePerturbationScores;
            
            ModelComparisonManager.generatePerturbationScores = function(levels) {
                try {
                    // Call the original function
                    return originalFunc.call(ModelComparisonManager, levels);
                } catch (error) {
                    console.error("Error in generatePerturbationScores:", error);
                    
                    // Return safe fallback data
                    const scores = {};
                    if (this.state && this.state.modelData) {
                        Object.keys(this.state.modelData).forEach(key => {
                            scores[key] = levels.map(l => 0.8 - (l * 0.2));
                        });
                    }
                    return scores;
                }
            };
        }
    }
}

/**
 * Fix map/forEach/filter functions with illegal continue statements
 */
function fixFeatureMapFunctions() {
    console.log("Patching functions that may contain illegal continue statements...");
    
    // List of objects that might use map/filter/forEach with continue
    const potentialObjects = [
        'FeatureImportanceTableManager',
        'PerturbationResultsController',
        'FeatureImportanceController',
        'ChartManager',
        'ModelComparisonManager'
    ];
    
    for (const objName of potentialObjects) {
        if (window[objName]) {
            console.log(`Checking ${objName} for array methods with continue...`);
            
            // Find all methods that might use array operations
            const methods = Object.keys(window[objName]).filter(key => 
                typeof window[objName][key] === 'function'
            );
            
            for (const methodName of methods) {
                const original = window[objName][methodName];
                
                // Replace the method with a wrapped version
                window[objName][methodName] = function(...args) {
                    try {
                        // Call the original method
                        return original.apply(window[objName], args);
                    } catch (error) {
                        if (error.toString().includes("Illegal continue") || 
                            error.toString().includes("no surrounding iteration statement")) {
                            console.error(`Caught illegal continue in ${objName}.${methodName}:`, error);
                            
                            // For methods that should return arrays/objects
                            if (methodName.startsWith('extract') || 
                                methodName.startsWith('get') || 
                                methodName.includes('Data')) {
                                return {};
                            }
                            
                            // For methods that initialize/render content
                            if (methodName.startsWith('init') || 
                                methodName.startsWith('render')) {
                                // Check if first arg is an element ID
                                if (args.length > 0 && typeof args[0] === 'string') {
                                    const container = document.getElementById(args[0]);
                                    if (container) {
                                        container.innerHTML = `
                                            <div style="padding: 20px; text-align: center; color: #d32f2f; background-color: #fff0f0; border-radius: 4px; margin: 10px;">
                                                <div style="font-weight: bold; margin-bottom: 5px;">Error in ${objName}.${methodName}</div>
                                                <div>A syntax error occurred: ${error.message}</div>
                                            </div>`;
                                    }
                                }
                            }
                            
                            return null;
                        } else {
                            // Rethrow unknown errors
                            throw error;
                        }
                    }
                };
            }
        }
    }
}

/**
 * Fix feature importance handlers
 * No synthetic data, just real data
 */
function fixFeatureImportanceHandlers() {
    console.log("Fixing feature importance handlers...");
    
    // Define a safe version of the feature importance initialization
    window.FeatureImportanceTableController = window.FeatureImportanceTableController || {
        init: function() {
            console.log("Feature importance table will be initialized by FeatureImportanceController");
            
            // Try to find and initialize the FeatureImportanceHandler
            if (window.FeatureImportanceHandler) {
                console.log("Found FeatureImportanceHandler, initializing it");
                if (typeof window.FeatureImportanceHandler.initialize === 'function') {
                    window.FeatureImportanceHandler.initialize();
                }
            }
        }
    };
    
    // Make sure the feature importance chart handler doesn't have syntax errors
    if (window.StandaloneFeatureImportanceChart) {
        const originalExtract = window.StandaloneFeatureImportanceChart.extractChartData;
        
        // Override with a safe version
        window.StandaloneFeatureImportanceChart.extractChartData = function() {
            try {
                // Try to use the original function
                return originalExtract.call(this);
            } catch (error) {
                console.error("Error in extractChartData:", error);
                
                // Return empty/safe data
                return {
                    features: [],
                    robustnessValues: [],
                    modelValues: []
                };
            }
        };
    }
}

// Safe Chart Manager
/**
 * Safe Chart Manager
 * Provides safe replacements for chart functions that might have syntax errors
 * Version 2.0 - May 7, 2024
 */

// Define a safe version of the ChartManager with properly structured functions
window.SafeChartManager = {
    /**
     * Initialize perturbation chart safely
     * @param {string} containerId - ID of container element
     */
    initializePerturbationChart: function(containerId) {
        console.log("Safe version of initializePerturbationChart called");
        
        try {
            // Get chart data from reportData
            const chartData = this.extractPerturbationChartData();
            if (!chartData || !chartData.levels || chartData.levels.length === 0) {
                this.showNoDataMessage(containerId, "No perturbation data available");
                return;
            }
            
            // Define colors for chart traces
            const colors = {
                primary: 'rgba(31, 119, 180, 0.7)',
                perturbed: 'rgba(44, 160, 44, 0.7)',
                worst: 'rgba(214, 39, 40, 0.7)',
                subset: 'rgba(148, 103, 189, 0.7)'
            };
            
            // Create traces for chart
            const traces = [];
            
            // Base score reference line
            if (chartData.baseScore) {
                traces.push({
                    x: chartData.levels,
                    y: Array(chartData.levels.length).fill(chartData.baseScore),
                    mode: 'lines',
                    name: 'Base Score',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: colors.primary
                    }
                });
            }
            
            // Perturbed scores
            if (chartData.perturbedScores && chartData.perturbedScores.length > 0) {
                traces.push({
                    x: chartData.levels,
                    y: chartData.perturbedScores,
                    mode: 'lines+markers',
                    name: 'Mean Score',
                    line: { color: colors.perturbed },
                    marker: {
                        size: 8,
                        color: colors.perturbed
                    }
                });
            }
            
            // Worst scores
            if (chartData.worstScores && chartData.worstScores.length > 0) {
                traces.push({
                    x: chartData.levels,
                    y: chartData.worstScores,
                    mode: 'lines+markers',
                    name: 'Worst Score',
                    line: { color: colors.worst },
                    marker: {
                        size: 8,
                        color: colors.worst
                    }
                });
            }
            
            // Feature subset scores if available
            if (chartData.featureSubsetScores && chartData.featureSubsetScores.some(s => s !== null)) {
                traces.push({
                    x: chartData.levels,
                    y: chartData.featureSubsetScores,
                    mode: 'lines+markers',
                    name: 'Feature Subset',
                    line: {
                        dash: 'dot',
                        color: colors.subset
                    },
                    marker: {
                        size: 8,
                        color: colors.subset
                    }
                });
            }
            
            // Layout for the chart
            const layout = {
                title: 'Model Performance under Perturbation',
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: chartData.metricName || 'Score',
                    autorange: true
                },
                legend: {
                    orientation: "h",
                    yanchor: "bottom",
                    y: -0.2,
                    xanchor: "center",
                    x: 0.5
                },
                margin: {
                    l: 60,
                    r: 20,
                    t: 40,
                    b: 80
                }
            };
            
            // Plot chart if Plotly is available
            if (typeof Plotly !== 'undefined') {
                Plotly.newPlot(containerId, traces, layout, {
                    responsive: true,
                    displayModeBar: false
                });
            } else {
                this.showNoDataMessage(containerId, "Plotly library not available");
            }
        } catch (error) {
            console.error("Error initializing perturbation chart:", error);
            this.showErrorMessage(containerId, error.message);
        }
    },
    
    /**
     * Extract perturbation chart data safely
     * @returns {Object} Chart data object
     */
    extractPerturbationChartData: function() {
        console.log("Safe version of extractPerturbationChartData called");
        
        try {
            // If perturbation_chart_data is already available, use it
            if (window.reportData && window.reportData.perturbation_chart_data) {
                return window.reportData.perturbation_chart_data;
            }
            
            // Otherwise, extract data from raw results
            if (!window.reportData || !window.reportData.raw) {
                console.warn("No raw data available for perturbation chart");
                return null;
            }
            
            // Extract basic metadata
            const result = {
                baseScore: window.reportData.base_score || 0,
                metricName: window.reportData.metric || 'Score',
                modelName: window.reportData.model_name || 'Model'
            };
            
            // Try to get perturbation levels and scores from raw data
            if (window.reportData.raw.by_level) {
                const rawData = window.reportData.raw.by_level;
                
                // Get all perturbation levels
                const levels = Object.keys(rawData)
                    .map(level => parseFloat(level))
                    .filter(level => !isNaN(level))
                    .sort((a, b) => a - b);
                
                result.levels = levels;
                
                // Extract scores for each level
                const perturbedScores = [];
                const worstScores = [];
                const featureSubsetScores = [];
                
                levels.forEach(level => {
                    const levelStr = level.toString();
                    const levelData = rawData[levelStr];
                    
                    let meanScore = null;
                    let worstScore = null;
                    let subsetScore = null;
                    
                    // Try to get scores from overall_result
                    if (levelData && levelData.overall_result) {
                        const overall = levelData.overall_result;
                        
                        if (overall.all_features) {
                            meanScore = overall.all_features.mean_score;
                            worstScore = overall.all_features.worst_score;
                        }
                        
                        if (overall.feature_subset) {
                            subsetScore = overall.feature_subset.mean_score;
                        }
                    }
                    
                    perturbedScores.push(meanScore);
                    worstScores.push(worstScore);
                    featureSubsetScores.push(subsetScore);
                });
                
                result.perturbedScores = perturbedScores;
                result.worstScores = worstScores;
                result.featureSubsetScores = featureSubsetScores;
            }
            
            return result;
        } catch (error) {
            console.error("Error extracting perturbation chart data:", error);
            return null;
        }
    },
    
    /**
     * Initialize model comparison chart safely
     * No synthetic data
     * @param {string} containerId - ID of container element
     */
    initializeModelComparisonChart: function(containerId) {
        console.log("Safe version of initializeModelComparisonChart called");
        
        try {
            // Extract data safely
            const chartData = this.extractModelComparisonData();
            
            if (!chartData || !chartData.levels || chartData.levels.length === 0 ||
                !chartData.modelScores || Object.keys(chartData.modelScores).length === 0) {
                this.showNoDataMessage(containerId, "No model comparison data available");
                return;
            }
            
            // Define some colors for the chart
            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'];
            let colorIndex = 0;
            
            // Get all model IDs
            const allModelIds = Object.keys(chartData.modelScores);
            
            // Create plot data array
            const plotData = [];
            
            // Add primary model first if available
            if (chartData.modelScores['primary']) {
                console.log("Adding primary model to chart");
                plotData.push({
                    x: chartData.levels,
                    y: chartData.modelScores['primary'],
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: chartData.modelNames['primary'] || 'Primary Model',
                    line: {
                        width: 3,
                        color: colors[colorIndex % colors.length]
                    },
                    marker: {
                        size: 8,
                        color: colors[colorIndex % colors.length]
                    }
                });
                colorIndex++;
            }
            
            // Add all other models, only real data
            for (const modelId of allModelIds) {
                // Skip primary model as we've already added it
                if (modelId === 'primary') {
                    continue;
                }
                
                console.log(`Adding model ${modelId} to chart`);
                
                // Check if scores are valid - only use real scores
                const validScores = chartData.modelScores[modelId] && 
                                   chartData.modelScores[modelId].some(score => score !== null);
                
                if (!validScores) {
                    console.log(`Model ${modelId} has no valid scores, skipping`);
                    continue;
                }
                
                // Add to chart if we have valid scores
                plotData.push({
                    x: chartData.levels,
                    y: chartData.modelScores[modelId],
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: chartData.modelNames[modelId] || modelId,
                    line: {
                        width: 2.5,
                        color: colors[colorIndex % colors.length]
                    },
                    marker: {
                        size: 7,
                        color: colors[colorIndex % colors.length]
                    }
                });
                colorIndex++;
            }
            
            // If no models have been added, show a message
            if (plotData.length === 0) {
                this.showNoDataMessage(containerId, "No models with valid data available");
                return;
            }
            
            // Layout
            const layout = {
                title: 'Model Comparison: Performance by Perturbation Level',
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: `${chartData.metricName} Score`,
                    autorange: true
                },
                legend: {
                    orientation: "h",
                    yanchor: "top",
                    y: 1,
                    xanchor: "right",
                    x: 1
                },
                hovermode: 'closest',
                margin: {
                    l: 60,
                    r: 20,
                    t: 40,
                    b: 40
                }
            };
            
            // Create the plot if Plotly is available
            if (typeof Plotly !== 'undefined') {
                Plotly.newPlot(containerId, plotData, layout, {
                    responsive: true,
                    displayModeBar: false
                });
            } else {
                this.showNoDataMessage(containerId, "Plotly library not available");
            }
        } catch (error) {
            console.error("Error initializing model comparison chart:", error);
            this.showErrorMessage(containerId, error.message);
        }
    },
    
    /**
     * Extract model comparison data safely without synthetic data
     * @returns {Object} Chart data object
     */
    extractModelComparisonData: function() {
        console.log("Safe version of extractModelComparisonData called");
        
        try {
            // Check if we have valid report data
            if (!window.reportData) {
                console.warn("No reportData available");
                return null;
            }
            
            // Check for alternative models
            const hasAlternativeModels = window.reportData.alternative_models && 
                                        Object.keys(window.reportData.alternative_models).length > 0;
            
            if (!hasAlternativeModels) {
                console.warn("No alternative models found - no comparison needed");
                return null;
            }
            
            // Get primary model name
            const primaryModelName = window.reportData.model_name || "Primary Model";
            const metricName = window.reportData.metric || "Score";
            
            // Determine available levels
            const rawData = window.reportData.raw && window.reportData.raw.by_level || {};
            const perturbationData = window.reportData.perturbation_chart_data || {};
            
            // Use perturbation chart data levels if available, otherwise extract from raw data
            let levels = [];
            if (perturbationData && perturbationData.levels) {
                levels = perturbationData.levels;
                console.log("Using levels from perturbation chart data:", levels);
            } else {
                // Extract levels from raw data
                levels = Object.keys(rawData)
                    .map(level => parseFloat(level))
                    .filter(level => !isNaN(level))
                    .sort((a, b) => a - b);
                console.log("Extracted levels from raw data:", levels);
            }
            
            if (levels.length === 0) {
                console.warn("No valid perturbation levels found");
                return null;
            }
            
            // Initialize model scores and names
            const modelScores = {};
            const modelNames = {};
            
            // Add primary model scores if available
            if (perturbationData.scores && perturbationData.scores.length > 0) {
                modelScores["primary"] = perturbationData.scores;
                modelNames["primary"] = primaryModelName;
                console.log("Added primary model scores from perturbation_chart_data");
            } 
            // Otherwise extract from raw data
            else if (Object.keys(rawData).length > 0) {
                const primaryScores = levels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        const score = rawData[levelStr].overall_result.all_features.mean_score;
                        return typeof score === 'number' ? score : null;
                    }
                    return null;
                });
                
                if (primaryScores.some(score => score !== null)) {
                    modelScores["primary"] = primaryScores;
                    modelNames["primary"] = primaryModelName;
                    console.log("Added primary model scores from raw data");
                }
            }
            
            // Process alternative models - ONLY use real data
            const alternativeModels = window.reportData.alternative_models || {};
            
            // Count how many alternative models have real perturbation test data
            let modelsWithRealData = 0;
            
            Object.entries(alternativeModels).forEach(([modelId, modelData]) => {
                // Get model name
                const name = modelData.model_name || modelId;
                
                // Only include models that have actual test data for perturbation levels
                if (modelData.raw && modelData.raw.by_level) {
                    // Extract actual scores for each perturbation level
                    const scores = levels.map(level => {
                        const levelStr = level.toString();
                        if (modelData.raw.by_level[levelStr] && 
                            modelData.raw.by_level[levelStr].overall_result && 
                            modelData.raw.by_level[levelStr].overall_result.all_features) {
                            return modelData.raw.by_level[levelStr].overall_result.all_features.mean_score || null;
                        }
                        return null;
                    });
                    
                    // Only include models with at least one valid score
                    if (scores.some(score => score !== null)) {
                        modelScores[modelId] = scores;
                        modelNames[modelId] = name;
                        modelsWithRealData++;
                        console.log(`Added real data for alternative model: ${name}`);
                    }
                }
            });
            
            // Return the processed data with NO TRAILING COMMAS
            
        try {
            return {
                levels: levels,
                modelScores: modelScores,
                modelNames: modelNames,
                metricName: metricName
            };
        } catch (error) {
            console.error('Error in model comparison data extraction:', error);
            return window.__safeFallbackObject;
        }

        } catch (error) {
            console.error("Error extracting model comparison data:", error);
            return null;
        }
    },
    
    /**
     * Display a message when no data is available
     * @param {string} containerId - ID of container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(containerId, message) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">No Data Available</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">
                    ${message}
                </p>
                <p style="color: #666; margin-top: 20px; font-size: 14px;">
                    Run perturbation tests to generate real data for visualization.
                </p>
            </div>`;
    },
    
    /**
     * Display an error message
     * @param {string} containerId - ID of container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(containerId, errorMessage) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
            </div>`;
    }
};

// Install the safe chart manager when the document is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log("Installing SafeChartManager...");
    
    // Replace existing ChartManager methods with safe versions
    if (window.ChartManager) {
        console.log("Found ChartManager, replacing methods with safe versions");
        
        // Replace perturbation chart methods
        if (typeof window.ChartManager.initializePerturbationChart === 'function') {
            window.ChartManager.initializePerturbationChart = SafeChartManager.initializePerturbationChart.bind(SafeChartManager);
            console.log("Replaced initializePerturbationChart with safe version");
        }
        
        if (typeof window.ChartManager.extractPerturbationChartData === 'function') {
            window.ChartManager.extractPerturbationChartData = SafeChartManager.extractPerturbationChartData.bind(SafeChartManager);
            console.log("Replaced extractPerturbationChartData with safe version");
        }
        
        // Replace model comparison chart methods
        if (typeof window.ChartManager.initializeModelComparisonChart === 'function') {
            window.ChartManager.initializeModelComparisonChart = SafeChartManager.initializeModelComparisonChart.bind(SafeChartManager);
            console.log("Replaced initializeModelComparisonChart with safe version");
        }
        
        if (typeof window.ChartManager.extractModelComparisonData === 'function') {
            window.ChartManager.extractModelComparisonData = SafeChartManager.extractModelComparisonData.bind(SafeChartManager);
            console.log("Replaced extractModelComparisonData with safe version");
        }
        
        // Add utility methods if they don't exist
        if (typeof window.ChartManager.showNoDataMessage !== 'function') {
            window.ChartManager.showNoDataMessage = SafeChartManager.showNoDataMessage.bind(SafeChartManager);
            console.log("Added showNoDataMessage to ChartManager");
        }
        
        if (typeof window.ChartManager.showErrorMessage !== 'function') {
            window.ChartManager.showErrorMessage = SafeChartManager.showErrorMessage.bind(SafeChartManager);
            console.log("Added showErrorMessage to ChartManager");
        }
    } else {
        // If ChartManager doesn't exist, create it from SafeChartManager
        console.log("ChartManager not found, creating one from SafeChartManager");
        window.ChartManager = SafeChartManager;
    }
});

// Model Chart Fix
/**
 * Model comparison chart fix
 * Direct replacement of the problematic functions
 * Updated: May 7, 2024 - Added fix for "Details by Level" chart
 */

// Define a safe version of the extractModelComparisonData function
window.SafeModelComparisonChartManager = {
    /**
     * Extract model comparison data from report data
     * Safe version with proper error handling - NO synthetic data generation
     * @returns {Object} Data for model comparison chart
     */
    extractModelComparisonData: function() {
        console.log("Using safe model comparison data extractor v2.0 (No Synthetic Data)");
        
        // Default safe return object with no trailing commas
        const safeReturnObject = {
            levels: [],
            modelScores: {},
            modelNames: {},
            metricName: ""
        };
        
        try {
            // Check if we have valid report data
            if (!window.reportData) {
                console.warn("No reportData available");
                return safeReturnObject;
            }
            
            // Check for alternative models
            const hasAlternativeModels = window.reportData.alternative_models && 
                                        Object.keys(window.reportData.alternative_models).length > 0;
            
            if (!hasAlternativeModels) {
                console.warn("No alternative models found - won't create synthetic models");
                return safeReturnObject;
            }
            
            // Get primary model name
            const primaryModelName = window.reportData.model_name || "Primary Model";
            const metricName = window.reportData.metric || "Score";
            
            // Determine available levels
            const rawData = window.reportData.raw && window.reportData.raw.by_level || {};
            const perturbationData = window.reportData.perturbation_chart_data || {};
            
            // Use perturbation chart data levels if available, otherwise extract from raw data
            let levels = [];
            if (perturbationData && perturbationData.levels) {
                levels = perturbationData.levels;
                console.log("Using levels from perturbation chart data:", levels);
            } else {
                // Extract levels from raw data
                levels = Object.keys(rawData)
                    .map(level => parseFloat(level))
                    .filter(level => !isNaN(level))
                    .sort((a, b) => a - b);
                console.log("Extracted levels from raw data:", levels);
            }
            
            if (levels.length === 0) {
                console.warn("No valid perturbation levels found");
                return safeReturnObject;
            }
            
            // Initialize model scores and names
            const modelScores = {};
            const modelNames = {};
            
            // Add primary model if we have perturbation chart data
            if (perturbationData.scores && perturbationData.scores.length > 0) {
                modelScores["primary"] = perturbationData.scores;
                modelNames["primary"] = primaryModelName;
                console.log("Added primary model scores from perturbation_chart_data");
            } 
            // Otherwise extract from raw data
            else if (Object.keys(rawData).length > 0) {
                const primaryScores = levels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        const score = rawData[levelStr].overall_result.all_features.mean_score;
                        return typeof score === 'number' ? score : null;
                    }
                    return null;
                });
                
                if (primaryScores.some(score => score !== null)) {
                    modelScores["primary"] = primaryScores;
                    modelNames["primary"] = primaryModelName;
                    console.log("Added primary model scores from raw data");
                }
            }
            
            // Process alternative models - ONLY use real data, no synthetic score generation
            const alternativeModels = window.reportData.alternative_models || {};
            
            // Count how many alternative models have real perturbation test data
            let modelsWithRealData = 0;
            
            Object.entries(alternativeModels).forEach(([modelId, modelData]) => {
                // Get model name
                const name = modelData.model_name || modelId;
                
                // Only include models that have actual test data for perturbation levels
                if (modelData.perturbation_results && 
                    Object.keys(modelData.perturbation_results).length > 0) {
                    
                    // Extract actual scores for each perturbation level
                    const scores = levels.map(level => {
                        const levelStr = level.toString();
                        if (modelData.perturbation_results[levelStr] && 
                            modelData.perturbation_results[levelStr].overall_result) {
                            return modelData.perturbation_results[levelStr].overall_result.mean_score || null;
                        }
                        return null;
                    });
                    
                    // Only include models with at least one valid score
                    if (scores.some(score => score !== null)) {
                        modelScores[modelId] = scores;
                        modelNames[modelId] = name;
                        modelsWithRealData++;
                        console.log(`Added real data for alternative model: ${name}`);
                    }
                }
            });
            
            // Log warning if no models have real perturbation test data
            if (modelsWithRealData === 0) {
                console.warn("No alternative models with real perturbation test data found");
                
                // Show error message on the page if the element exists
                const chartContainer = document.getElementById('modelComparisonChartContainer');
                if (chartContainer) {
                    chartContainer.innerHTML = `
                        <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                            <div style="font-size: 48px; margin-bottom: 20px;"></div>
                            <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados de perturbao no disponveis</h3>
                            <p style="color: #333; font-size: 16px; line-height: 1.4;">Os modelos alternativos no possuem dados de testes de perturbao.</p>
                            <p style="color: #333; margin-top: 20px; font-size: 14px;">Execute testes de robustez em todos os modelos para comparao.</p>
                        </div>`;
                }
            }
            
            // Log final data
            console.log("Final data for model comparison chart:");
            console.log("- Levels:", levels);
            console.log("- Models:", Object.keys(modelScores));
            
            // Return the processed data with NO TRAILING COMMAS
            
        try {
            return {
                levels: levels,
                modelScores: modelScores,
                modelNames: modelNames,
                metricName: metricName
            };
        } catch (error) {
            console.error('Error in model comparison data extraction:', error);
            return window.__safeFallbackObject;
        }

        } catch (error) {
            console.error("Error extracting model comparison data:", error);
            return safeReturnObject;
        }
    },
    
    /**
     * Fixed version of extractModelLevelDetailsData function
     * Properly extracts data for Model Level Details chart (no synthetic data)
     */
    extractModelLevelDetailsData: function() {
        console.log("Using safe extractModelLevelDetailsData (no synthetic data)");
        
        // Default safe return object
        const safeReturnObject = {
            levels: [],
            modelScores: {},
            modelNames: {},
            metricName: "Score"
        };
        
        try {
            if (!window.reportData) {
                console.warn("No reportData available");
                return safeReturnObject;
            }
            
            // Get the metric name from reportData
            let metricName = "Score";
            if (window.reportData.metric) {
                metricName = window.reportData.metric;
            } else if (window.reportConfig && window.reportConfig.metric) {
                metricName = window.reportConfig.metric;
            }
            
            // Determine which data path to use based on available structure
            let primaryModelData = null;
            let alternativeModelsData = null;
            let rawDataPath = null;
            
            // Check new data structure first (results.robustness.primary_model)
            if (window.reportData.results && 
                window.reportData.results.robustness && 
                window.reportData.results.robustness.primary_model) {
                console.log("Using new data structure (results.robustness.primary_model)");
                primaryModelData = window.reportData.results.robustness.primary_model;
                
                if (window.reportData.results.robustness.alternative_models) {
                    alternativeModelsData = window.reportData.results.robustness.alternative_models;
                }
                
                if (primaryModelData.raw && primaryModelData.raw.by_level) {
                    rawDataPath = primaryModelData.raw.by_level;
                }
            } 
            // Fallback to original structure
            else if (window.reportData.raw && window.reportData.raw.by_level) {
                console.log("Using original data structure (raw.by_level)");
                rawDataPath = window.reportData.raw.by_level;
                
                if (window.reportData.alternative_models) {
                    alternativeModelsData = window.reportData.alternative_models;
                }
            }
            
            if (!rawDataPath) {
                console.warn("No valid raw data path found");
                return safeReturnObject;
            }
            
            // Get perturbation levels from the data
            const levels = Object.keys(rawDataPath)
                .map(level => parseFloat(level))
                .filter(level => !isNaN(level))
                .sort((a, b) => a - b);
                
            if (levels.length === 0) {
                console.warn("No valid levels found");
                return safeReturnObject;
            }
            
            console.log("Found levels:", levels);
            
            // Get primary model name
            const primaryModelName = window.reportData.model_name || "Primary Model";
            
            // Initialize result data structures
            const modelScores = {};
            const modelNames = {};
            
            // Extract primary model scores
            const primaryScores = levels.map(level => {
                const levelStr = level.toString();
                if (rawDataPath[levelStr]) {
                    // Try different potential paths where scores might be stored
                    const paths = [
                        // Try specific path from user data
                        rawDataPath[levelStr].runs?.all_features?.[0]?.perturbed_score,
                        // Standard path for mean scores
                        rawDataPath[levelStr].overall_result?.all_features?.mean_score,
                        // Other potential paths
                        rawDataPath[levelStr].mean_score,
                        rawDataPath[levelStr].perturbed_score,
                        rawDataPath[levelStr].results?.overall_result?.all_features?.mean_score
                    ];
                    
                    // Use the first valid score from any path
                    for (const path of paths) {
                        if (typeof path === 'number') {
                            return path;
                        }
                    }
                }
                return null;
            });
            
            if (primaryScores.some(score => score !== null)) {
                modelScores["primary"] = primaryScores;
                modelNames["primary"] = primaryModelName;
                console.log("Added primary model scores");
            }
            
            // Extract alternative model scores
            if (alternativeModelsData && Object.keys(alternativeModelsData).length > 0) {
                console.log("Processing alternative models:", Object.keys(alternativeModelsData));
                
                Object.entries(alternativeModelsData).forEach(([modelId, modelData]) => {
                    // Skip if no raw data
                    if (!modelData.raw || !modelData.raw.by_level) {
                        console.log(`Model ${modelId} has no raw data`);
                        return;
                    }
                    
                    // Get model name
                    const name = modelData.model_name || modelId;
                    
                    // Extract scores for each level
                    const scores = levels.map(level => {
                        const levelStr = level.toString();
                        if (!modelData.raw.by_level[levelStr]) {
                            return null;
                        }
                        
                        const paths = [
                            // Try specific path from user data
                            modelData.raw.by_level[levelStr].runs?.all_features?.[0]?.perturbed_score,
                            // Standard path for mean scores
                            modelData.raw.by_level[levelStr].overall_result?.all_features?.mean_score,
                            // Other potential paths
                            modelData.raw.by_level[levelStr].mean_score,
                            modelData.raw.by_level[levelStr].perturbed_score,
                            modelData.raw.by_level[levelStr].results?.overall_result?.all_features?.mean_score
                        ];
                        
                        // Use the first valid score
                        for (const path of paths) {
                            if (typeof path === 'number') {
                                return path;
                            }
                        }
                        
                        return null;
                    });
                    
                    // Only add if we found at least one valid score
                    if (scores.some(score => score !== null)) {
                        modelScores[modelId] = scores;
                        modelNames[modelId] = name;
                        console.log(`Added scores for model ${name}`);
                    } else {
                        console.log(`No valid scores found for model ${name}`);
                    }
                });
            }
            
            // Check if we have at least two models with data
            const validModels = Object.keys(modelScores);
            if (validModels.length < 2) {
                console.warn("Not enough models for comparison (need at least 2)");
                console.log("Models with valid data:", validModels);
                return safeReturnObject;
            }
            
            
        try {
            return {
                levels: levels,
                modelScores: modelScores,
                modelNames: modelNames,
                metricName: metricName
            };
        } catch (error) {
            console.error('Error in model level details data extraction:', error);
            return {
                levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                modelNames: { 'primary': 'Primary Model' },
                metricName: 'Score'
            };
        }

        } catch (error) {
            console.error("Error extracting model level details data:", error);
            return safeReturnObject;
        }
    }
};

// Set up the fix to be applied when the page loads
document.addEventListener('DOMContentLoaded', function() {
    // Replace the problematic functions with our safe versions
    if (window.ModelComparisonChartManager) {
        console.log("Replacing ModelComparisonChartManager.extractModelComparisonData with safe version");
        window.ModelComparisonChartManager.extractModelComparisonData = window.SafeModelComparisonChartManager.extractModelComparisonData;
    }
    
    // Fix the "Details by Level" chart
    if (window.ChartManager) {
        console.log("Replacing ChartManager.extractModelLevelDetailsData with safe version");
        window.ChartManager.extractModelLevelDetailsData = window.SafeModelComparisonChartManager.extractModelLevelDetailsData;
    }
    
    // Monitor model comparison selector clicks
    const modelDetailButton = document.querySelector('#model_comparison_selector [data-chart-type="details"]');
    if (modelDetailButton) {
        modelDetailButton.addEventListener('click', function() {
            console.log("Details chart button clicked, applying fix");
            // Check if we need to reinitialize the chart
            const chartElement = document.getElementById('model-level-details-chart-plot');
            if (chartElement && chartElement.innerHTML.includes('No Data Available')) {
                // Reinitialize the chart with our fixed function
                if (typeof ChartManager !== 'undefined' && 
                    typeof ChartManager.initializeModelLevelDetailsChart === 'function') {
                    setTimeout(function() {
                        console.log("Reinitializing model level details chart");
                        ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
                    }, 300);
                }
            }
        });
    }
});

// ===== Generic JavaScript ===== //



// ----- Generic JS Modules ----- //

// ----- utils.js ----- //
/**
 * Utility functions for DeepBridge reports
 */

/**
 * Format a numeric value for display
 * 
 * @param {number} value - The value to format
 * @param {number} decimals - Number of decimal places (default: 3)
 * @param {boolean} percentage - Whether to format as percentage
 * @returns {string} Formatted value
 */
function formatValue(value, decimals = 3, percentage = false) {
    if (value === null || value === undefined || isNaN(value)) {
        return "N/A";
    }
    
    if (percentage) {
        return (value * 100).toFixed(decimals) + "%";
    }
    
    return value.toFixed(decimals);
}

/**
 * Get color based on value (red-to-green gradient)
 * 
 * @param {number} value - Value between 0 and 1
 * @param {boolean} invertScale - If true, 0 is green and 1 is red (default: false)
 * @returns {string} RGB color string
 */
function getScoreColor(value, invertScale = false) {
    if (value === null || value === undefined || isNaN(value)) {
        return "rgb(150, 150, 150)";
    }
    
    // Ensure value is between 0 and 1
    value = Math.max(0, Math.min(1, value));
    
    // Invert scale if needed
    if (invertScale) {
        value = 1 - value;
    }
    
    // Red to green gradient
    const red = Math.round(255 * (1 - value));
    const green = Math.round(255 * value);
    
    return `rgb(${red}, ${green}, 50)`;
}

/**
 * Toggle element visibility
 * 
 * @param {string} elementId - The ID of the element to toggle
 */
function toggleElement(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
        if (element.classList.contains('hidden')) {
            element.classList.remove('hidden');
        } else {
            element.classList.add('hidden');
        }
    }
}

/**
 * Show message in an element
 * 
 * @param {HTMLElement} element - Element to show message in
 * @param {string} message - Message text
 * @param {string} type - Message type (info, warning, error)
 */
function showMessage(element, message, type = 'info') {
    if (!element) return;
    
    let iconClass = 'info-icon';
    let bgColor = '#e3f2fd';
    let textColor = '#0d47a1';
    
    if (type === 'warning') {
        iconClass = 'warning-icon';
        bgColor = '#fff3e0';
        textColor = '#e65100';
    } else if (type === 'error') {
        iconClass = 'error-icon';
        bgColor = '#ffebee';
        textColor = '#c62828';
    }
    
    element.innerHTML = `
        <div class="message ${type}">
            <span class="${iconClass}"></span>
            ${message}
        </div>
    `;
}

/**
 * Show loader in an element
 * 
 * @param {HTMLElement} element - Element to show loader in
 * @param {string} message - Loading message
 */
function showLoader(element, message = 'Loading...') {
    if (!element) return;
    
    element.innerHTML = `
        <div class="loader-container">
            <div class="loader"></div>
            <p>${message}</p>
        </div>
    `;
}

/**
 * Generate a random number from normal distribution
 * @param {number} mean - Mean of the distribution
 * @param {number} stdDev - Standard deviation
 * @returns {number} Random number
 */
function normalRandom(mean, stdDev) {
    // Box-Muller transform
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
    return mean + z0 * stdDev;
}

/**
 * Show no data message in container element
 * @param {HTMLElement} element - Container element
 * @param {string} message - Message to display
 */
function showNoDataMessage(element, message) {
    if (!element) return;
    
    element.innerHTML = `
        <div class="data-unavailable">
            <div class="data-message">
                <span class="message-icon"></span>
                <h3>No Data Available</h3>
                <p>${message}</p>
            </div>
        </div>`;
}

/**
 * Show error message in container element
 * @param {HTMLElement} element - Container element
 * @param {string} errorMessage - Error message to display
 */
function showErrorMessage(element, errorMessage) {
    if (!element) return;
    
    element.innerHTML = `
        <div class="error-message">
            <div class="message-container">
                <span class="message-icon"></span>
                <h3>Error</h3>
                <p>${errorMessage}</p>
            </div>
        </div>`;
}

// ----- components_charts ----- //
/**
 * Chart utilities for DeepBridge reports
 */
const ChartUtils = {
    /**
     * Initialize Plotly if not available
     * @param {Function} callback - Callback to run after initialization
     */
    initializePlotly: function(callback) {
        if (typeof Plotly !== 'undefined') {
            if (callback) callback();
            return true;
        }
        
        console.log("Plotly not found, loading from CDN");
        const script = document.createElement('script');
        script.src = 'https://cdn.plot.ly/plotly-latest.min.js';
        
        if (callback) {
            script.onload = callback;
        }
        
        script.onerror = () => {
            console.error("Failed to load Plotly from CDN");
            this.showChartError();
        };
        
        document.head.appendChild(script);
        return false;
    },
    
    /**
     * Show error when chart library fails to load
     */
    showChartError: function() {
        const chartContainers = document.querySelectorAll('.chart-plot, .chart-container');
        chartContainers.forEach(container => {
            container.innerHTML = `
                <div class="chart-error">
                    <p>Chart rendering library not available.</p>
                    <p class="text-sm">Please check your internet connection and refresh the page.</p>
                </div>`;
        });
    },
    
    /**
     * Show no data message in chart container
     * @param {HTMLElement} element - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(element, message) {
        if (!element) return;
        
        element.innerHTML = `
            <div class="data-unavailable">
                <div class="data-message">
                    <span class="message-icon"></span>
                    <h3>No Chart Data Available</h3>
                    <p>${message}</p>
                </div>
            </div>`;
    },
    
    /**
     * Default color palette for charts
     */
    colorPalette: {
        primary: 'rgb(31, 119, 180)',
        secondary: 'rgb(255, 127, 14)',
        tertiary: 'rgb(44, 160, 44)',
        quaternary: 'rgb(214, 39, 40)',
        quinary: 'rgb(148, 103, 189)',
        senary: 'rgb(140, 86, 75)',
        septenary: 'rgb(227, 119, 194)',
        octonary: 'rgb(127, 127, 127)',
        nonary: 'rgb(188, 189, 34)',
        denary: 'rgb(23, 190, 207)'
    },
    
    /**
     * Common layout options for Plotly charts
     * @param {string} title - Chart title
     * @param {string} xTitle - X axis title
     * @param {string} yTitle - Y axis title
     * @returns {Object} Layout configuration
     */
    getCommonLayout: function(title, xTitle, yTitle) {
        return {
            title: title,
            xaxis: {
                title: xTitle,
                automargin: true
            },
            yaxis: {
                title: yTitle,
                automargin: true
            },
            margin: {
                l: 50,
                r: 20,
                t: 60,
                b: 80
            },
            hovermode: 'closest',
            legend: {
                orientation: 'h',
                yanchor: 'bottom',
                y: -0.2,
                xanchor: 'center',
                x: 0.5
            }
        };
    },
    
    /**
     * Common config options for Plotly charts
     * @param {boolean} responsive - Whether chart should be responsive
     * @returns {Object} Config options
     */
    getCommonConfig: function(responsive = true) {
        return {
            responsive: responsive,
            displayModeBar: false,
            displaylogo: false
        };
    },
    
    /**
     * Create a line chart
     * @param {string} elementId - Container element ID
     * @param {Array} data - Chart data
     * @param {Object} layout - Layout configuration
     * @param {Object} config - Config options
     */
    createLineChart: function(elementId, data, layout = {}, config = {}) {
        const element = document.getElementById(elementId);
        if (!element) {
            console.error(`Element not found: ${elementId}`);
            return;
        }
        
        if (!this.initializePlotly(() => this.createLineChart(elementId, data, layout, config))) {
            return;
        }
        
        const fullLayout = {...this.getCommonLayout('', '', ''), ...layout};
        const fullConfig = {...this.getCommonConfig(), ...config};
        
        Plotly.newPlot(element, data, fullLayout, fullConfig);
    },
    
    /**
     * Create a bar chart
     * @param {string} elementId - Container element ID
     * @param {Array} data - Chart data
     * @param {Object} layout - Layout configuration
     * @param {Object} config - Config options
     */
    createBarChart: function(elementId, data, layout = {}, config = {}) {
        const element = document.getElementById(elementId);
        if (!element) {
            console.error(`Element not found: ${elementId}`);
            return;
        }
        
        if (!this.initializePlotly(() => this.createBarChart(elementId, data, layout, config))) {
            return;
        }
        
        const fullLayout = {...this.getCommonLayout('', '', ''), ...layout};
        const fullConfig = {...this.getCommonConfig(), ...config};
        
        Plotly.newPlot(element, data, fullLayout, fullConfig);
    },
    
    /**
     * Create a scatter plot
     * @param {string} elementId - Container element ID
     * @param {Array} data - Chart data
     * @param {Object} layout - Layout configuration
     * @param {Object} config - Config options
     */
    createScatterPlot: function(elementId, data, layout = {}, config = {}) {
        const element = document.getElementById(elementId);
        if (!element) {
            console.error(`Element not found: ${elementId}`);
            return;
        }
        
        if (!this.initializePlotly(() => this.createScatterPlot(elementId, data, layout, config))) {
            return;
        }
        
        const fullLayout = {...this.getCommonLayout('', '', ''), ...layout};
        const fullConfig = {...this.getCommonConfig(), ...config};
        
        Plotly.newPlot(element, data, fullLayout, fullConfig);
    },
    
    /**
     * Create a boxplot
     * @param {string} elementId - Container element ID
     * @param {Array} data - Chart data
     * @param {Object} layout - Layout configuration
     * @param {Object} config - Config options
     */
    createBoxPlot: function(elementId, data, layout = {}, config = {}) {
        const element = document.getElementById(elementId);
        if (!element) {
            console.error(`Element not found: ${elementId}`);
            return;
        }
        
        if (!this.initializePlotly(() => this.createBoxPlot(elementId, data, layout, config))) {
            return;
        }
        
        const fullLayout = {...this.getCommonLayout('', '', ''), ...layout};
        const fullConfig = {...this.getCommonConfig(), ...config};
        
        Plotly.newPlot(element, data, fullLayout, fullConfig);
    }
};

// ----- components_widgets ----- //
/**
 * UI Widget utilities for DeepBridge reports
 */
const WidgetUtils = {
    /**
     * Initialize tab navigation
     * @param {string} tabsSelector - Selector for tab buttons container
     * @param {string} contentSelector - Selector for tab content containers
     * @param {Function} callback - Optional callback to run after tab change
     */
    initTabs: function(tabsSelector, contentSelector, callback) {
        const tabButtons = document.querySelectorAll(tabsSelector);
        if (!tabButtons.length) return;
        
        tabButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Remove active class from all buttons
                tabButtons.forEach(btn => btn.classList.remove('active'));
                
                // Add active class to clicked button
                this.classList.add('active');
                
                // Show corresponding content
                const targetId = this.getAttribute('data-tab');
                const tabContents = document.querySelectorAll(contentSelector);
                
                tabContents.forEach(content => {
                    content.classList.remove('active');
                });
                
                const targetContent = document.getElementById(targetId);
                if (targetContent) {
                    targetContent.classList.add('active');
                    
                    // Run callback if provided
                    if (callback && typeof callback === 'function') {
                        callback(targetId, targetContent);
                    }
                }
            });
        });
        
        // Activate first tab by default if none is active
        if (!document.querySelector(`${tabsSelector}.active`)) {
            tabButtons[0]?.click();
        }
    },
    
    /**
     * Initialize chart selector
     * @param {string} selectorId - ID of the chart selector element
     * @param {string} containerSelector - Selector for chart containers
     */
    initChartSelector: function(selectorId, containerSelector) {
        const chartSelector = document.getElementById(selectorId);
        if (!chartSelector) return;
        
        const options = chartSelector.querySelectorAll('.chart-selector-option');
        options.forEach(option => {
            option.addEventListener('click', function() {
                // Remove active from all options
                options.forEach(opt => opt.classList.remove('active'));
                
                // Add active to clicked option
                this.classList.add('active');
                
                // Show corresponding chart
                const chartType = this.getAttribute('data-chart-type');
                const containers = document.querySelectorAll(containerSelector);
                
                containers.forEach(chart => {
                    chart.classList.remove('active');
                });
                
                const targetChart = document.querySelector(`${containerSelector}[data-chart-type="${chartType}"]`);
                if (targetChart) {
                    targetChart.classList.add('active');
                }
            });
        });
        
        // Activate first option by default if none is active
        if (!document.querySelector(`#${selectorId} .chart-selector-option.active`)) {
            options[0]?.click();
        }
    },
    
    /**
     * Initialize expandable sections
     * @param {string} headerSelector - Selector for section headers
     * @param {string} contentSelector - Selector for section content
     * @param {string} expandedClass - Class to apply when expanded
     */
    initExpandableSections: function(headerSelector, contentSelector, expandedClass = 'expanded') {
        const headers = document.querySelectorAll(headerSelector);
        
        headers.forEach(header => {
            header.addEventListener('click', function() {
                // Toggle expanded class on header
                this.classList.toggle(expandedClass);
                
                // Find the associated content
                const content = this.nextElementSibling;
                if (content && content.matches(contentSelector)) {
                    content.classList.toggle(expandedClass);
                }
                
                // Toggle icon if present
                const icon = this.querySelector('.panel-icon');
                if (icon) {
                    icon.classList.toggle(expandedClass);
                }
            });
        });
    },
    
    /**
     * Create a metric card
     * @param {string} label - Metric label
     * @param {string|number} value - Metric value
     * @param {string} description - Metric description
     * @param {string} colorClass - Color class for styling
     * @returns {HTMLElement} Metric card element
     */
    createMetricCard: function(label, value, description, colorClass = '') {
        const card = document.createElement('div');
        card.className = 'metric-card';
        
        const labelEl = document.createElement('div');
        labelEl.className = 'metric-card-label';
        labelEl.textContent = label;
        
        const valueEl = document.createElement('div');
        valueEl.className = `metric-card-value ${colorClass}`;
        valueEl.textContent = value;
        
        const descEl = document.createElement('div');
        descEl.className = 'metric-card-desc';
        descEl.textContent = description;
        
        card.appendChild(labelEl);
        card.appendChild(valueEl);
        card.appendChild(descEl);
        
        return card;
    },
    
    /**
     * Create a section with title and content
     * @param {string} title - Section title
     * @param {string} content - Section HTML content
     * @param {string} className - Additional CSS class
     * @returns {HTMLElement} Section element
     */
    createSection: function(title, content, className = '') {
        const section = document.createElement('div');
        section.className = `section ${className}`;
        
        const titleEl = document.createElement('h2');
        titleEl.className = 'section-title';
        titleEl.textContent = title;
        
        const contentEl = document.createElement('div');
        contentEl.className = 'section-content';
        contentEl.innerHTML = content;
        
        section.appendChild(titleEl);
        section.appendChild(contentEl);
        
        return section;
    },
    
    /**
     * Create a data table
     * @param {Array} headers - Table headers
     * @param {Array} rows - Table rows data
     * @param {string} className - Additional CSS class
     * @returns {HTMLElement} Table element
     */
    createTable: function(headers, rows, className = '') {
        const table = document.createElement('table');
        table.className = `data-table ${className}`;
        
        // Create header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        headers.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Create body
        const tbody = document.createElement('tbody');
        
        rows.forEach(row => {
            const tr = document.createElement('tr');
            
            row.forEach(cell => {
                const td = document.createElement('td');
                
                if (typeof cell === 'object' && cell !== null) {
                    // Cell with custom formatting
                    td.innerHTML = cell.html || '';
                    if (cell.className) td.className = cell.className;
                } else {
                    // Simple cell
                    td.textContent = cell;
                }
                
                tr.appendChild(td);
            });
            
            tbody.appendChild(tr);
        });
        
        table.appendChild(tbody);
        return table;
    },
    
    /**
     * Show a message box
     * @param {string} message - Message text
     * @param {string} type - Message type (info, warning, error, success)
     * @param {string} containerId - ID of container to show message in
     */
    showMessage: function(message, type = 'info', containerId) {
        const container = containerId ? document.getElementById(containerId) : document.body;
        if (!container) return;
        
        const msgBox = document.createElement('div');
        let icon = '';
        
        switch (type) {
            case 'warning':
                icon = '';
                msgBox.className = 'message-box warning';
                break;
            case 'error':
                icon = '';
                msgBox.className = 'message-box error';
                break;
            case 'success':
                icon = '';
                msgBox.className = 'message-box success';
                break;
            default:
                msgBox.className = 'message-box info';
        }
        
        msgBox.innerHTML = `
            <div class="message-content">
                <span class="message-icon">${icon}</span>
                <span class="message-text">${message}</span>
                <span class="message-close">&times;</span>
            </div>
        `;
        
        // Add close functionality
        const closeBtn = msgBox.querySelector('.message-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                msgBox.remove();
            });
        }
        
        // Add to container
        container.appendChild(msgBox);
        
        // Auto-remove after 5 seconds for non-error messages
        if (type !== 'error') {
            setTimeout(() => {
                msgBox.remove();
            }, 5000);
        }
        
        return msgBox;
    }
};



// ===== Test-specific JavaScript ===== //



// ----- Mdulos JS Combinados ----- //

// ----- main.js ----- //
/**
 * Improved initialization for robustness reports 
 * Fixes chart initialization issues with centralized rendering
 */

// Global chart initialization state to prevent duplicate rendering
window.chartInitialized = {
    features: false,
    overview: false,
    boxplot: false,
    details: false
};

// Central chart management
window.ChartInitializer = {
    // Check if Plotly is loaded and load if necessary
    ensurePlotlyLoaded: function(callback) {
        if (typeof Plotly !== 'undefined') {
            // Plotly already loaded, execute callback immediately
            if (callback) callback();
            return true;
        }
        
        console.log("Plotly not loaded, attempting to load from CDN");
        
        // Create script element to load Plotly
        const script = document.createElement('script');
        script.src = 'https://cdn.plot.ly/plotly-2.29.1.min.js';
        script.async = true;
        
        script.onload = function() {
            console.log("Plotly loaded successfully");
            if (callback) callback();
        };
        
        script.onerror = function() {
            console.error("Failed to load Plotly from CDN");
            document.querySelectorAll('.chart-plot').forEach(container => {
                container.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <div style="color: #e53935; margin-bottom: 10px;"> Chart library could not be loaded</div>
                        <div style="color: #555; font-size: 14px;">Please check your internet connection and refresh the page.</div>
                    </div>`;
            });
        };
        
        document.head.appendChild(script);
        return false;
    },
    
    // Initialize feature charts, with validation
    initializeFeatureCharts: function(sortBy) {
        // Allow forced reinitialization with new sort order
        console.log("Initializing feature charts" + (sortBy ? ` with sort: ${sortBy}` : ""));
        
        // Check data availability in both reportData and chart_data_json
        const hasFeatureData = (window.reportData && 
                             window.reportData.feature_importance && 
                             Object.keys(window.reportData.feature_importance).length > 0) || 
                            (window.reportData && 
                             window.reportData.chart_data_json && 
                             typeof window.reportData.chart_data_json === 'string' &&
                             window.reportData.chart_data_json.includes('feature_importance'));
        
        if (!hasFeatureData) {
            console.warn("No feature importance data available for charts");
            this.showNoDataForCharts('feature-importance-chart');
            this.showNoDataForCharts('importance-comparison-chart-plot');
            return;
        }
        
        this.ensurePlotlyLoaded(() => {
            // Clear any previous content and force redraw
            const chartContainer = document.getElementById('feature-importance-chart');
            if (chartContainer) {
                // Clear previous chart
                Plotly.purge(chartContainer);
                chartContainer.innerHTML = '';
                
                if (typeof FeatureImportanceChartManager !== 'undefined' && 
                    typeof FeatureImportanceChartManager.initializeFeatureImportanceChart === 'function') {
                    FeatureImportanceChartManager.initializeFeatureImportanceChart('feature-importance-chart');
                } else {
                    console.error("FeatureImportanceChartManager not available");
                    this.showErrorForCharts('feature-importance-chart', "Chart manager not available");
                }
            } else {
                console.warn("Feature chart container not found");
            }
            
            // Initialize comparison chart if container exists
            const comparisonContainer = document.getElementById('importance-comparison-chart-plot');
            if (comparisonContainer) {
                // Clear previous chart
                Plotly.purge(comparisonContainer);
                comparisonContainer.innerHTML = '';
                
                if (typeof FeatureImportanceChartManager !== 'undefined' && 
                    typeof FeatureImportanceChartManager.initializeImportanceComparisonChart === 'function') {
                    try {
                        FeatureImportanceChartManager.initializeImportanceComparisonChart('importance-comparison-chart-plot');
                    } catch (e) {
                        console.error("Error initializing importance comparison chart:", e);
                        // Show graceful error
                        comparisonContainer.innerHTML = `
                            <div style="padding: 30px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto;">
                                <div style="font-size: 48px; margin-bottom: 10px;"></div>
                                <h3 style="font-size: 18px; margin-bottom: 10px; color: #e53935;">Chart Error</h3>
                                <p style="color: #666; font-size: 14px;">${e.message || "Error rendering chart"}</p>
                            </div>`;
                    }
                }
            }
            
            window.chartInitialized.features = true;
        });
    },
    
    // Initialize overview charts
    initializeOverviewCharts: function() {
        if (window.chartInitialized.overview) return;
        
        console.log("Initializing overview charts");
        
        this.ensurePlotlyLoaded(() => {
            if (typeof ChartManager !== 'undefined') {
                // Clear any previous error messages
                const chartContainers = document.querySelectorAll('.overview-chart');
                chartContainers.forEach(container => {
                    container.innerHTML = '';
                });
                
                // Check if data is available
                const hasOverviewData = window.reportData && 
                                       (window.reportData.raw || window.reportData.perturbation_chart_data);
                
                if (!hasOverviewData) {
                    console.warn("No overview data available for charts");
                    this.showNoDataForCharts('perturbation-chart-plot');
                    this.showNoDataForCharts('worst-score-chart-plot');
                    this.showNoDataForCharts('mean-score-chart-plot');
                    return;
                }
                
                // Initialize each chart with try-catch for robustness
                try {
                    if (typeof ChartManager.initializePerturbationChart === 'function') {
                        ChartManager.initializePerturbationChart('perturbation-chart-plot');
                    }
                } catch (e) {
                    console.error("Error initializing perturbation chart:", e);
                    this.showErrorForCharts('perturbation-chart-plot', e.message);
                }
                
                try {
                    if (typeof ChartManager.initializeWorstScoreChart === 'function') {
                        ChartManager.initializeWorstScoreChart('worst-score-chart-plot');
                    }
                } catch (e) {
                    console.error("Error initializing worst score chart:", e);
                    this.showErrorForCharts('worst-score-chart-plot', e.message);
                }
                
                try {
                    if (typeof ChartManager.initializeMeanScoreChart === 'function') {
                        ChartManager.initializeMeanScoreChart('mean-score-chart-plot');
                    }
                } catch (e) {
                    console.error("Error initializing mean score chart:", e);
                    this.showErrorForCharts('mean-score-chart-plot', e.message);
                }
                
                // Only initialize model comparison charts if we have alternative models
                const hasAlternativeModels = window.reportData && 
                                            window.reportData.alternative_models &&
                                            Object.keys(window.reportData.alternative_models).length > 0;
                                            
                if (hasAlternativeModels) {
                    try {
                        if (typeof ChartManager.initializeModelComparisonChart === 'function') {
                            ChartManager.initializeModelComparisonChart('model-comparison-chart-plot');
                        }
                    } catch (e) {
                        console.error("Error initializing model comparison chart:", e);
                        this.showErrorForCharts('model-comparison-chart-plot', e.message);
                    }
                    
                    try {
                        if (typeof ChartManager.initializeModelLevelDetailsChart === 'function') {
                            ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
                        }
                    } catch (e) {
                        console.error("Error initializing model level details chart:", e);
                        this.showErrorForCharts('model-level-details-chart-plot', e.message);
                    }
                } else {
                    console.log("No alternative models available, skipping comparison charts");
                }
            } else {
                console.error("ChartManager not available");
                document.querySelectorAll('.overview-chart').forEach(container => {
                    this.showErrorForCharts(container.id, "Chart manager not available");
                });
            }
            
            window.chartInitialized.overview = true;
        });
    },
    
    // Initialize boxplot charts
    initializeBoxplotCharts: function() {
        if (window.chartInitialized.boxplot) return;
        
        console.log("Initializing boxplot charts");
        
        // Check if boxplot data is available
        const hasBoxplotData = window.reportData && 
                              (window.reportData.boxplot_data || 
                              (window.reportData.raw && window.reportData.raw.by_level));
        
        if (!hasBoxplotData) {
            console.warn("No boxplot data available");
            this.showNoDataForCharts('boxplot-chart-container');
            return;
        }
        
        // First make sure the container is visible and has dimensions
        const boxplotContainer = document.getElementById('boxplot-chart-container');
        if (boxplotContainer) {
            // Force a minimum size to ensure rendering works
            boxplotContainer.style.minHeight = '400px';
            boxplotContainer.style.minWidth = '100%';
            
            this.ensurePlotlyLoaded(() => {
                if (typeof BoxplotChartManager !== 'undefined' && 
                    typeof BoxplotChartManager.initializeBoxplotChart === 'function') {
                    try {
                        BoxplotChartManager.initializeBoxplotChart('boxplot-chart-container');
                    } catch (e) {
                        console.error("Error initializing boxplot chart:", e);
                        this.showErrorForCharts('boxplot-chart-container', e.message);
                    }
                } else {
                    console.error("BoxplotChartManager not available");
                    this.showErrorForCharts('boxplot-chart-container', "Chart manager not available");
                }
            });
        } else {
            console.warn("Boxplot container not found");
        }
        
        window.chartInitialized.boxplot = true;
    },
    
    // Utility function to show no data message
    showNoDataForCharts: function(elementId) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        element.innerHTML = `
            <div style="padding: 30px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto;">
                <div style="font-size: 48px; margin-bottom: 10px;"></div>
                <h3 style="font-size: 18px; margin-bottom: 10px;">No Chart Data Available</h3>
                <p style="color: #666; font-size: 14px;">The required data for this chart is not available.</p>
            </div>`;
    },
    
    // Utility function to show error message
    showErrorForCharts: function(elementId, message) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        element.innerHTML = `
            <div style="padding: 30px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto;">
                <div style="font-size: 48px; margin-bottom: 10px;"></div>
                <h3 style="font-size: 18px; margin-bottom: 10px; color: #e53935;">Chart Error</h3>
                <p style="color: #666; font-size: 14px;">${message || "Error rendering chart"}</p>
            </div>`;
    }
};

// Tab change handler to ensure charts are rendered when tabs become visible
function handleTabChange(tabId) {
    // Reset layout for any charts in this tab
    window.dispatchEvent(new Event('resize'));
    
    // Initialize appropriate charts based on tab ID
    switch (tabId) {
        case 'overview':
            window.ChartInitializer.initializeOverviewCharts();
            break;
        case 'feature_impact':
            window.ChartInitializer.initializeFeatureCharts();
            // Check if the table controller is initialized
            if (typeof FeatureImportanceTableController !== 'undefined' && 
                typeof FeatureImportanceTableController.init === 'function') {
                console.log("Ensuring feature table is initialized");
                FeatureImportanceTableController.init();
            } else if (typeof FeatureImportanceController !== 'undefined' && 
                     typeof FeatureImportanceController.fillFeatureImportanceTable === 'function') {
                console.log("Using fallback feature table initialization");
                FeatureImportanceController.fillFeatureImportanceTable();
            }
            break;
        case 'boxplot':
            window.ChartInitializer.initializeBoxplotCharts();
            break;
        case 'importance_comparison':
            // Deixamos o ImportanceComparisonHandler cuidar desta inicializao
            // para evitar conflitos de renderizao mltipla
            console.log("Importance comparison tab activated - using ImportanceComparisonHandler");
            // No inicializamos aqui, deixamos o ImportanceComparisonHandler fazer isso
            break;
    }
    
    // Broadcast tab change event for other components
    document.dispatchEvent(new CustomEvent('tabchange', { 
        detail: { tabId: tabId } 
    }));
}

// Initialize on DOM ready with improved structure
document.addEventListener('DOMContentLoaded', function() {
    console.log("Report initialized");
    
    // Carregar script para corrigir erros de continue
    try {
        // Verificar se o script de correo j foi carregado
        if (!window.fixedSyntaxLoaded) {
            console.log("Carregando correo para erros de 'continue' fora de loops");
            window.fixedSyntaxLoaded = true;
            
            // Carregar o script fixed_syntax.js
            const fixScript = document.createElement('script');
            fixScript.src = 'js/fixed_syntax.js';
            fixScript.onload = function() {
                console.log("Script de correo carregado com sucesso");
            };
            fixScript.onerror = function(e) {
                console.error("Erro ao carregar script de correo:", e);
            };
            document.head.appendChild(fixScript);
        }
    } catch (e) {
        console.error("Erro ao configurar correo de sintaxe:", e);
    }
    
    // Set up tab navigation with chart initialization on tab change
    setupTabNavigation();
    
    // Initialize first tab's charts
    const initialTab = document.querySelector('.tab-btn.active');
    if (initialTab) {
        const tabId = initialTab.getAttribute('data-tab');
        handleTabChange(tabId);
    } else {
        // Default to overview if no tab is active
        window.ChartInitializer.initializeOverviewCharts();
    }
    
    // Initialize controllers with error handling
    initializeControllers();
});

// Set up tab navigation
function setupTabNavigation() {
    const tabButtons = document.querySelectorAll('.tab-btn');
    if (tabButtons.length === 0) {
        console.warn("No tab buttons found");
        return;
    }
    
    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            // Remove active class from all buttons
            tabButtons.forEach(btn => btn.classList.remove('active'));
            
            // Add active class to clicked button
            this.classList.add('active');
            
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Show target tab content
            const targetTab = this.getAttribute('data-tab');
            const targetElement = document.getElementById(targetTab);
            
            if (targetElement) {
                targetElement.classList.add('active');
                
                // Initialize charts for this tab
                handleTabChange(targetTab);
            } else {
                console.error(`Tab content not found: #${targetTab}`);
            }
        });
    });
    
    // Activate first tab by default if none is active
    if (!document.querySelector('.tab-btn.active')) {
        tabButtons[0]?.click();
    }
}

// Initialize controllers with error handling
function initializeControllers() {
    // Define controllers to initialize
    const controllers = [
        { name: 'MainController', initializer: function() { 
            if (typeof MainController !== 'undefined' && typeof MainController.init === 'function') {
                MainController.init();
            }
        }},
        { name: 'OverviewController', initializer: function() { 
            if (typeof OverviewController !== 'undefined' && typeof OverviewController.init === 'function') {
                OverviewController.init();
            }
        }},
        { name: 'DetailsController', initializer: function() { 
            if (typeof DetailsController !== 'undefined' && typeof DetailsController.init === 'function') {
                DetailsController.init();
            }
        }},
        { name: 'BoxplotController', initializer: function() { 
            if (typeof BoxplotController !== 'undefined' && typeof BoxplotController.init === 'function') {
                BoxplotController.init();
            }
        }},
        { name: 'FeatureImportanceController', initializer: function() { 
            if (typeof FeatureImportanceController !== 'undefined' && typeof FeatureImportanceController.init === 'function') {
                FeatureImportanceController.init();
            } else {
                console.log("FeatureImportanceController not found, using fallback initialization");
                // Try direct chart initialization if controller not available
                window.ChartInitializer.initializeFeatureCharts();
            }
        }},
        { name: 'FeatureImportanceTableController', initializer: function() { 
            if (typeof FeatureImportanceTableController !== 'undefined' && typeof FeatureImportanceTableController.init === 'function') {
                FeatureImportanceTableController.init();
            }
        }}
    ];
    
    // Initialize each controller with error handling
    controllers.forEach(controller => {
        try {
            controller.initializer();
        } catch (error) {
            console.error(`Error initializing ${controller.name}:`, error);
        }
    });
}

// Simple MainController implementation (keep backward compatibility)
const MainController = {
    init: function() {
        console.log("MainController initialized with enhanced initialization");
        // Tab navigation is now handled by setupTabNavigation function
    }
};

// ----- utils ----- //
// Utility functions for robustness report
/**
 * Format a numeric value for display
 * 
 * @param {number} value - The value to format
 * @param {number} decimals - Number of decimal places (default: 3)
 * @param {boolean} percentage - Whether to format as percentage
 * @returns {string} Formatted value
 */
function formatValue(value, decimals = 3, percentage = false) {
    if (value === null || value === undefined || isNaN(value)) {
        return "N/A";
    }
    
    if (percentage) {
        return (value * 100).toFixed(decimals) + "%";
    }
    
    return value.toFixed(decimals);
}

/**
 * Get color based on value (red-to-green gradient)
 * 
 * @param {number} value - Value between 0 and 1
 * @param {boolean} invertScale - If true, 0 is green and 1 is red (default: false)
 * @returns {string} RGB color string
 */
function getScoreColor(value, invertScale = false) {
    if (value === null || value === undefined || isNaN(value)) {
        return "rgb(150, 150, 150)";
    }
    
    // Ensure value is between 0 and 1
    value = Math.max(0, Math.min(1, value));
    
    // Invert scale if needed
    if (invertScale) {
        value = 1 - value;
    }
    
    // Red to green gradient
    const red = Math.round(255 * (1 - value));
    const green = Math.round(255 * value);
    
    return `rgb(${red}, ${green}, 50)`;
}

/**
 * Toggle element visibility
 * 
 * @param {string} elementId - The ID of the element to toggle
 */
function toggleElement(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
        if (element.classList.contains('hidden')) {
            element.classList.remove('hidden');
        } else {
            element.classList.add('hidden');
        }
    }
}

/**
 * Show message in an element
 * 
 * @param {HTMLElement} element - Element to show message in
 * @param {string} message - Message text
 * @param {string} type - Message type (info, warning, error)
 */
function showMessage(element, message, type = 'info') {
    if (!element) return;
    
    let iconClass = 'info-icon';
    let bgColor = '#e3f2fd';
    let textColor = '#0d47a1';
    
    if (type === 'warning') {
        iconClass = 'warning-icon';
        bgColor = '#fff3e0';
        textColor = '#e65100';
    } else if (type === 'error') {
        iconClass = 'error-icon';
        bgColor = '#ffebee';
        textColor = '#c62828';
    }
    
    element.innerHTML = `
        <div class="message ${type}" style="padding: 15px; background: ${bgColor}; color: ${textColor}; border-radius: 4px; margin: 10px 0;">
            <span class="${iconClass}"></span>
            ${message}
        </div>
    `;
}

/**
 * Show loader in an element
 * 
 * @param {HTMLElement} element - Element to show loader in
 * @param {string} message - Loading message
 */
function showLoader(element, message = 'Loading...') {
    if (!element) return;
    
    element.innerHTML = `
        <div class="loader-container" style="text-align: center; padding: 20px;">
            <div class="loader" style="display: inline-block; width: 40px; height: 40px; border: 3px solid #f3f3f3; border-radius: 50%; border-top: 3px solid #3498db; animation: spin 1s linear infinite;"></div>
            <p style="margin-top: 10px;">${message}</p>
        </div>
        <style>
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    `;
}

// ----- charts_boxplot ----- //
/**
 * Boxplot Chart Manager
 * Handles boxplot visualization logic for robustness reports
 * Updated: May 7, 2024 - Removed synthetic data generation
 */

const BoxplotChartManager = {
    /**
     * Initialize boxplot chart
     * @param {string} elementId - Chart container ID
     */
    initializeBoxplotChart: function(elementId) {
        console.log("BoxplotChartManager initializing boxplot chart in:", elementId);
        
        const container = document.getElementById(elementId);
        if (!container) {
            console.error("Chart container not found:", elementId);
            return;
        }
        
        try {
            // Extract data for boxplot
            const chartData = this.extractBoxplotData();
            
            if (!chartData || !chartData.models || chartData.models.length === 0 || 
                !chartData.models.some(m => m.scores && m.scores.length > 0)) {
                console.error("No valid chart data available");
                this.showNoDataMessage(container, "Dados de boxplot no disponveis. Execute testes com iteraes mltiplas para visualizar a distribuio dos scores.");
                return;
            }
            
            // Create the Plotly boxplot visualization
            this.createPlotlyBoxplot(container, chartData);
            
        } catch (error) {
            console.error("Error creating boxplot chart:", error);
            this.showErrorMessage(container, error.message);
        }
    },
    
    /**
     * Extract data for boxplot from report data
     * @returns {Object} Data for boxplot chart
     */
    extractBoxplotData: function() {
        try {
            // Get data from window.reportData or window.chartData
            const reportData = window.reportData || {};
            const chartData = window.chartData || {};
            
            // Check if we have pre-processed boxplot data
            if (chartData.boxplot_data && chartData.boxplot_data.models && 
                chartData.boxplot_data.models.length > 0) {
                console.log("Using pre-processed boxplot data");
                
                // Filter models to only include those with real scores
                const validModels = chartData.boxplot_data.models.filter(model => 
                    model.scores && model.scores.length > 0
                );
                
                if (validModels.length === 0) {
                    console.error("No models with valid scores found in boxplot_data");
                    return null;
                }
                
                return {
                    models: validModels,
                    metricName: reportData.metric || 'Score'
                };
            }
            
            // If no pre-processed data, try to extract from reportData
            if (reportData.boxplot_data && reportData.boxplot_data.models && 
                reportData.boxplot_data.models.length > 0) {
                console.log("Using reportData.boxplot_data");
                
                // Filter models to only include those with real scores
                const validModels = reportData.boxplot_data.models.filter(model => 
                    model.scores && model.scores.length > 0
                );
                
                if (validModels.length === 0) {
                    console.error("No models with valid scores found in reportData.boxplot_data");
                    return null;
                }
                
                return {
                    models: validModels,
                    metricName: reportData.metric || 'Score'
                };
            }
            
            // No pre-processed data, try to extract from raw data
            console.log("No pre-processed boxplot data, extracting from raw data");
            
            if (!reportData.raw || !reportData.raw.by_level) {
                console.error("No raw data available for boxplot extraction");
                return null;
            }
            
            // Extract primary model data
            const primaryModelData = {
                name: reportData.model_name || 'Primary Model',
                modelType: reportData.model_type || 'Unknown',
                baseScore: reportData.base_score || 0,
                scores: []
            };
            
            // Extract scores from perturbation levels
            Object.keys(reportData.raw.by_level).forEach(level => {
                const levelData = reportData.raw.by_level[level];
                
                if (levelData.runs && levelData.runs.all_features) {
                    levelData.runs.all_features.forEach(run => {
                        if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                            primaryModelData.scores.push(...run.iterations.scores);
                        }
                    });
                }
            });
            
            // Only proceed if we have real scores
            if (primaryModelData.scores.length === 0) {
                console.error("No real scores found for primary model");
            }
            
            const models = [primaryModelData];
            
            // Extract alternative models if available
            if (reportData.alternative_models) {
                Object.keys(reportData.alternative_models).forEach(modelName => {
                    const modelData = reportData.alternative_models[modelName];
                    
                    const altModelData = {
                        name: modelName,
                        modelType: modelData.model_type || 'Unknown',
                        baseScore: modelData.base_score || 0,
                        scores: []
                    };
                    
                    // Extract scores if raw data is available
                    if (modelData.raw && modelData.raw.by_level) {
                        Object.keys(modelData.raw.by_level).forEach(level => {
                            const levelData = modelData.raw.by_level[level];
                            
                            if (levelData.runs && levelData.runs.all_features) {
                                levelData.runs.all_features.forEach(run => {
                                    if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                                        altModelData.scores.push(...run.iterations.scores);
                                    }
                                });
                            }
                        });
                    }
                    
                    // Only add if real scores are available
                    if (altModelData.scores.length === 0) {
                        console.error(`No real scores found for model ${modelName}`);
                    }
                    
                    models.push(altModelData);
                });
            }
            
            // Ensure at least one model has valid scores
            if (!models.some(model => model.scores && model.scores.length > 0)) {
                console.error("No models with valid scores found");
                return null;
            }
            
            return {
                models,
                metricName: reportData.metric || 'Score'
            };
            
        } catch (error) {
            console.error("Error extracting boxplot data:", error);
            return null;
        }
    },
    
    /**
     * Create Plotly boxplot visualization
     * @param {HTMLElement} container - Chart container element
     * @param {Object} chartData - Data for chart
     */
    createPlotlyBoxplot: function(container, chartData) {
        if (typeof Plotly === 'undefined') {
            console.error("Plotly is not available");
            this.showErrorMessage(container, "Plotly library is not available. Charts cannot be displayed.");
            return;
        }
        
        const models = chartData.models;
        const traces = [];
        
        // Define consistent colors for models
        const modelColors = {
            'Primary Model': 'rgba(31, 119, 180, 0.7)',
            'primary_model': 'rgba(31, 119, 180, 0.7)',
            'GLM_CLASSIFIER': 'rgba(255, 127, 14, 0.7)',
            'GAM_CLASSIFIER': 'rgba(44, 160, 44, 0.7)',
            'GBM': 'rgba(214, 39, 40, 0.7)',
            'XGB': 'rgba(148, 103, 189, 0.7)',
            'RANDOM_FOREST': 'rgba(140, 86, 75, 0.7)',
            'SVM': 'rgba(227, 119, 194, 0.7)',
            'NEURAL_NETWORK': 'rgba(127, 127, 127, 0.7)'
        };
        
        // Track valid models
        let validModelCount = 0;
        
        // Create traces for each model
        models.forEach(model => {
            // Skip models without real data
            if (!model.scores || model.scores.length === 0) {
                return;
            }
            
            validModelCount++;
            
            // Clean up model name for display
            const displayName = model.name.replace(/_/g, ' ').trim();
            
            // Get color or generate a deterministic color
            let color = modelColors[model.name];
            if (!color) {
                // Generate a deterministic color based on model name
                const hash = Array.from(model.name).reduce((hash, char) => {
                    return ((hash << 5) - hash) + char.charCodeAt(0);
                }, 0);
                const r = Math.abs(hash) % 200 + 55;
                const g = Math.abs(hash * 31) % 200 + 55;
                const b = Math.abs(hash * 17) % 200 + 55;
                color = `rgba(${r}, ${g}, ${b}, 0.7)`;
            }
            
            // Create violin plot for model
            traces.push({
                type: 'violin',
                y: model.scores,
                x: Array(model.scores.length).fill(displayName),
                name: displayName,
                box: {
                    visible: true,
                    width: 0.6
                },
                meanline: {
                    visible: true
                },
                line: {
                    color: 'black',
                    width: 1
                },
                fillcolor: color,
                opacity: 0.7,
                points: 'all',
                jitter: 0.3,
                pointpos: 0,
                hoverinfo: 'y+x',
                spanmode: 'soft',
                width: 0.5,
                bandwidth: 0.2
            });
        });
        
        // Add base scores as separate markers
        const baseScoreTrace = {
            type: 'scatter',
            mode: 'markers',
            y: models.map(m => m.baseScore),
            x: models.map(m => m.name.replace(/_/g, ' ').trim()),
            name: 'Base Score',
            marker: {
                size: 12,
                symbol: 'diamond',
                color: models.map(m => modelColors[m.name] || 'rgba(31, 119, 180, 0.7)'),
                line: {
                    color: 'white',
                    width: 1
                }
            },
            text: models.map(m => `Base Score: ${m.baseScore.toFixed(4)}`),
            hoverinfo: 'text+y'
        };
        
        traces.push(baseScoreTrace);
        
        // If no valid models, show error
        if (validModelCount === 0) {
            this.showNoDataMessage(container, "Nenhum modelo possui dados reais para visualizao");
            return;
        }
        
        // Get metric name
        const metricName = chartData.metricName || 'Score';
        
        // Create layout
        const layout = {
            title: {
                text: `Model Performance Distribution - ${metricName}`,
                font: { size: 20 }
            },
            xaxis: {
                title: 'Models',
                tickangle: 0,
                automargin: true
            },
            yaxis: {
                title: metricName,
                zeroline: false,
                autorange: true,
                automargin: true
            },
            autosize: true,
            violinmode: 'group',
            hoverlabel: {
                bgcolor: "#FFF",
                font: { size: 12 },
                bordercolor: "#333"
            },
            showlegend: true,
            legend: {
                orientation: "h",
                yanchor: "top",
                y: 1.1,
                xanchor: "right",
                x: 1
            },
            hovermode: 'closest',
            margin: {
                l: 50,
                r: 20,
                t: 60,
                b: 80
            },
            annotations: [{
                xref: 'paper',
                yref: 'paper',
                x: 0,
                y: -0.15,
                text: 'The boxplots show model performance distribution under perturbation tests. Diamond markers indicate base scores.',
                showarrow: false,
                font: { size: 12 }
            }]
        };
        
        try {
            // Render the visualization
            Plotly.newPlot(container, traces, layout, {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                displaylogo: false,
                staticPlot: false,
                toImageButtonOptions: {
                    format: 'png',
                    filename: 'model_comparison_boxplot',
                    height: 700,
                    width: 1000,
                    scale: 2
                }
            }).then(() => {
                console.log("Boxplot chart successfully rendered");
                
                // Force a resize event to ensure proper layout
                window.dispatchEvent(new Event('resize'));
            }).catch(error => {
                console.error("Plotly.newPlot failed:", error);
                this.showErrorMessage(container, `Error rendering boxplot: ${error.message}`);
            });
        } catch (error) {
            console.error("Exception during Plotly.newPlot:", error);
            this.showErrorMessage(container, `Error rendering boxplot: ${error.message}`);
        }
    },
    
    /**
     * Calculate boxplot statistics for a set of scores
     * @param {Array} scores - Array of score values
     * @returns {Object} Boxplot statistics
     */
    calculateBoxplotStats: function(scores) {
        if (!scores || scores.length === 0) return null;
        
        // Sort scores for percentile calculations
        const sortedScores = [...scores].sort((a, b) => a - b);
        
        // Calculate statistics
        const min = sortedScores[0];
        const max = sortedScores[sortedScores.length - 1];
        
        // Find quartiles
        const getPercentile = (arr, p) => {
            const index = Math.floor(arr.length * p);
            return arr[index];
        };
        
        const q1 = getPercentile(sortedScores, 0.25);
        const median = getPercentile(sortedScores, 0.5);
        const q3 = getPercentile(sortedScores, 0.75);
        
        // Calculate IQR (Interquartile Range)
        const iqr = q3 - q1;
        
        // Calculate whiskers (using Tukey's method: 1.5 * IQR)
        const lowerWhisker = Math.max(min, q1 - 1.5 * iqr);
        const upperWhisker = Math.min(max, q3 + 1.5 * iqr);
        
        // Find outliers
        const outliers = sortedScores.filter(score => score < lowerWhisker || score > upperWhisker);
        
        return {
            min,
            max,
            q1,
            median,
            q3,
            iqr,
            lowerWhisker,
            upperWhisker,
            outliers
        };
    },
    
    /**
     * Show no data message in container
     * @param {HTMLElement} element - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(element, message) {
        element.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados no disponveis</h3>
                <p style="color: #333; font-size: 16px; line-height: 1.4;">${message}</p>
                <p style="color: #333; margin-top: 20px; font-size: 14px;">
                    No sero gerados dados sintticos ou demonstrativos. Execute testes com iteraes mltiplas (n_iterations > 1).
                </p>
            </div>`;
    },
    
    /**
     * Show error message in container
     * @param {HTMLElement} element - Chart container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(element, errorMessage) {
        element.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Erro ao criar grfico</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
            </div>`;
    }
};

// ----- charts_featuresTable ----- //
// Feature Importance Table Manager
window.FeatureImportanceTableManager = {
    /**
     * Extract feature importance data from report data
     * @returns {Array} Array of feature data objects
     */
    extractFeatureData: function() {
        let featureData = [];
        
        try {
            // Try all possible sources to find feature importance data
            let featureImportance = {};
            let modelFeatureImportance = {};
            let featureSubset = [];
            
            // Check multiple sources in order of preference
            if (window.reportConfig && window.reportConfig.feature_importance) {
                // First priority - directly from reportConfig
                featureImportance = window.reportConfig.feature_importance || {};
                modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                featureSubset = window.reportConfig.feature_subset || [];
                console.log("Using feature data from reportConfig");
            } 
            else if (window.chartData && window.chartData.feature_importance) {
                // Second priority - from parsed chart data
                featureImportance = window.chartData.feature_importance || {};
                modelFeatureImportance = window.chartData.model_feature_importance || {};
                featureSubset = window.chartData.feature_subset || [];
                console.log("Using feature data from chartData");
            }
            else if (window.reportData) {
                // If we have reportData, check several possible locations
                if (window.reportData.feature_importance) {
                    // Direct property in reportData
                    featureImportance = window.reportData.feature_importance;
                    modelFeatureImportance = window.reportData.model_feature_importance || {};
                    featureSubset = window.reportData.feature_subset || [];
                    console.log("Using feature data from reportData");
                }
                else if (window.reportData.chart_data_json && typeof window.reportData.chart_data_json === 'string') {
                    // Try to parse the chart_data_json string
                    try {
                        const chartData = JSON.parse(window.reportData.chart_data_json);
                        if (chartData && chartData.feature_importance) {
                            featureImportance = chartData.feature_importance;
                            modelFeatureImportance = chartData.model_feature_importance || {};
                            featureSubset = chartData.feature_subset || [];
                            console.log("Using feature data from parsed chart_data_json");
                        }
                    } catch (e) {
                        console.error("Error parsing chart_data_json:", e);
                    }
                }
            }
            
            // Verificar se featureImportance  um objeto vlido
            if (typeof featureImportance !== 'object' || featureImportance === null) {
                console.error("Feature importance data is not a valid object:", featureImportance);
                return [];
            }
            
            // Verificar se modelFeatureImportance  um objeto vlido
            if (typeof modelFeatureImportance !== 'object' || modelFeatureImportance === null) {
                console.error("Model feature importance is not a valid object");
                modelFeatureImportance = {};
            }
            
            // Verificar se featureSubset  um array vlido
            if (!Array.isArray(featureSubset)) {
                console.error("Feature subset is not a valid array");
                featureSubset = [];
            }
            
            // Convert to array format with calculated properties
            featureData = Object.entries(featureImportance).map(([name, value]) => ({
                name,
                robustness: value,
                robustnessAbs: Math.abs(value),
                impact: value,
                importance: modelFeatureImportance[name] || 0,
                impactType: value >= 0 ? 'positive' : 'negative',
                inSubset: featureSubset.includes(name)
            }));
            
            console.log(`Loaded ${featureData.length} features from data`);
        } catch (error) {
            console.error("Error extracting feature data:", error);
        }
        
        return featureData;
    },
    
    /**
     * Sort feature data by specified key and direction
     * @param {Array} data - Array of feature data objects
     * @param {string} key - Key to sort by
     * @param {string} direction - Sort direction ('asc' or 'desc')
     * @returns {Array} Sorted array
     */
    sortData: function(data, key, direction) {
        // Map sort keys to actual data properties
        const propertyMap = {
            'name': 'name',
            'impact': 'robustnessAbs', // Sort by absolute value for impact
            'importance': 'importance'
        };
        
        const sortKey = propertyMap[key] || 'robustnessAbs';
        
        return [...data].sort((a, b) => {
            let valueA = a[sortKey];
            let valueB = b[sortKey];
            
            // Special case for name: use string comparison
            if (sortKey === 'name') {
                return direction === 'asc' 
                    ? valueA.localeCompare(valueB) 
                    : valueB.localeCompare(valueA);
            }
            
            // For numeric values
            return direction === 'asc' 
                ? valueA - valueB 
                : valueB - valueA;
        });
    },
    
    /**
     * Filter feature data by search term and subset option
     * @param {Array} data - Array of feature data objects
     * @param {string} searchTerm - Search term
     * @param {boolean} showOnlySubset - Whether to show only subset features
     * @returns {Array} Filtered array
     */
    filterData: function(data, searchTerm, showOnlySubset) {
        return data.filter(item => {
            const matchesSearch = !searchTerm || item.name.toLowerCase().includes(searchTerm.toLowerCase());
            const matchesSubset = !showOnlySubset || item.inSubset;
            return matchesSearch && matchesSubset;
        });
    },
    
    /**
     * Format numeric value for display
     * @param {number} value - Value to format
     * @param {number} decimals - Number of decimal places
     * @returns {string} Formatted value
     */
    formatValue: function(value, decimals = 4) {
        return value.toFixed(decimals);
    },
    
    /**
     * Calculate visual bar width for importance values
     * @param {number} value - Importance value
     * @param {boolean} isModelImportance - Whether this is model importance
     * @returns {string} CSS width value as percentage
     */
    getBarWidth: function(value, isModelImportance = false) {
        if (isModelImportance) {
            // Model importance is typically larger, scale differently
            return `${Math.min(Math.abs(value) * 100 * 5, 100)}%`;
        }
        // For robustness, scale absolute value
        return `${Math.min(Math.abs(value) * 100 * 10, 100)}%`;
    },
    
    /**
     * Generate table rows HTML from feature data
     * @param {Array} data - Array of feature data objects
     * @param {string} hoveredRow - ID of currently hovered row
     * @returns {string} HTML for table rows
     */
    generateTableRows: function(data, hoveredRow = null) {
        let html = '';
        
        data.forEach(item => {
            const rowClasses = [
                hoveredRow === item.name ? 'hovered-row' : '',
                item.inSubset ? 'feature-subset-row' : ''
            ].filter(Boolean).join(' ');
            
            html += `
            <tr class="${rowClasses}" data-feature="${item.name}">
                <td><span class="feature-name">${item.name}</span></td>
                <td>
                    <div class="value-with-bar">
                        <span class="value-text">${this.formatValue(item.robustness)}</span>
                        <div class="progress-container">
                            <div class="progress-bar ${item.impactType}" 
                                 style="width: ${this.getBarWidth(item.robustness)}"></div>
                        </div>
                    </div>
                </td>
                <td>
                    <div class="value-with-bar">
                        <span class="value-text">${this.formatValue(item.importance)}</span>
                        <div class="progress-container">
                            <div class="progress-bar model" 
                                 style="width: ${this.getBarWidth(item.importance, true)}"></div>
                        </div>
                    </div>
                </td>
                <td>
                    <span class="subset-badge ${item.inSubset ? 'included' : 'excluded'}">
                        ${item.inSubset ? 'Included' : 'Excluded'}
                    </span>
                </td>
            </tr>`;
        });
        
        return html || this.generateNoDataMessage();
    },
    
    /**
     * Generate a "no data" message
     * @returns {string} HTML for no data message
     */
    generateNoDataMessage: function() {
        return `
        <tr>
            <td colspan="4" class="no-data-message">
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados no disponveis</h3>
                    <p style="color: #333; font-size: 16px; line-height: 1.4;">No h dados de importncia de caractersticas disponveis.</p>
                    <p style="color: #333; margin-top: 20px; font-size: 14px;">
                        Execute testes de robustez com anlise de importncia de caractersticas habilitada.
                    </p>
                </div>
            </td>
        </tr>`;
    },
    
    /**
     * Generate an error message
     * @param {string} errorMessage - Error message to display
     * @returns {string} HTML for error message
     */
    generateErrorMessage: function(errorMessage) {
        return `
        <tr>
            <td colspan="4" class="error-message">
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Erro ao carregar dados</h3>
                    <p style="color: #333; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                    <p style="color: #333; margin-top: 20px; font-size: 14px;">
                        No sero exibidos dados sintticos. Apenas dados reais so aceitos.
                    </p>
                </div>
            </td>
        </tr>`;
    },
    
    /**
     * Generate feature count statistics
     * @param {Array} data - Feature data array
     * @returns {Object} Count statistics
     */
    getFeatureCounts: function(data) {
        return {
            total: data.length,
            inSubset: data.filter(f => f.inSubset).length
        };
    }
};

// ----- charts_modelComparison ----- //
// Model Comparison Manager
const ModelComparisonManager = {
    // State variables
    state: {
        expandedRow: null,
        selectedMetric: 'roc_auc',
        highlightBest: true,
        modelData: {}
    },
    
    /**
     * Initialize the manager with model data
     * @param {Object} modelData - Model comparison data
     */
    initialize: function(modelData) {
        // Store model data
        this.state.modelData = modelData || {};
        
        // Render initial tables
        this.renderTable('overview-tab');
    },
    
    /**
     * Update the selected metrics display
     * @param {string} metric - Selected metric
     */
    updateMetricsDisplay: function(metric) {
        this.state.selectedMetric = metric;
        this.renderTable('metrics-tab');
    },
    
    /**
     * Set highlight best flag
     * @param {boolean} highlight - Whether to highlight best values
     */
    setHighlightBest: function(highlight) {
        this.state.highlightBest = highlight;
    },
    
    /**
     * Toggle row expansion
     * @param {string} modelKey - Key of the model to toggle
     */
    toggleRowExpansion: function(modelKey) {
        if (this.state.expandedRow === modelKey) {
            this.state.expandedRow = null;
        } else {
            this.state.expandedRow = modelKey;
        }
        
        // Re-render active table
        const activeTab = document.querySelector('.model-comparison-tab.active');
        if (activeTab) {
            const tabId = activeTab.getAttribute('data-tab');
            this.renderTable(tabId);
        }
    },
    
    /**
     * Format number with specified precision
     * @param {number} num - Number to format
     * @param {number} precision - Decimal precision
     * @returns {string} - Formatted number
     */
    formatNumber: function(num, precision = 4) {
        return Number(num).toFixed(precision);
    },
    
    /**
     * Get CSS class for robustness score
     * @param {number} score - Robustness score
     * @returns {string} - CSS class
     */
    getRobustnessColor: function(score) {
        if (score >= 0.95) return 'bg-green-500';
        if (score >= 0.85) return 'bg-blue-500';
        if (score >= 0.75) return 'bg-yellow-500';
        return 'bg-red-500';
    },
    
    /**
     * Get text color for impact value
     * @param {number} impact - Impact value
     * @returns {string} - CSS class
     */
    getImpactTextColor: function(impact) {
        if (impact < 0) return 'text-green-600'; // Improvement
        if (impact < 0.05) return 'text-blue-600'; // Small degradation
        if (impact < 0.1) return 'text-yellow-600'; // Medium degradation
        return 'text-red-600'; // Large degradation
    },
    
    /**
     * Find best value for a given metric across all models
     * @param {string} metric - Metric to compare
     * @returns {number} - Best value
     */
    getBestValue: function(metric) {
        const values = Object.values(this.state.modelData).map(model => 
            metric === 'robustness_score' ? model[metric] : 
            metric === 'raw_impact' ? model[metric] : 
            model.metrics[metric]
        );
        return Math.max(...values);
    },
    
    /**
     * Determine if a value is the best for its metric
     * @param {string} modelKey - Model key
     * @param {string} metric - Metric to compare
     * @returns {boolean} - Whether value is best
     */
    isBestValue: function(modelKey, metric) {
        if (!this.state.highlightBest) return false;
        
        const bestValue = this.getBestValue(metric);
        const modelValue = metric === 'robustness_score' ? this.state.modelData[modelKey][metric] : 
                           metric === 'raw_impact' ? this.state.modelData[modelKey][metric] : 
                           this.state.modelData[modelKey].metrics[metric];
        
        // For raw_impact, lower is better (with negative being best)
        if (metric === 'raw_impact') {
            return modelValue === Math.min(...Object.values(this.state.modelData).map(m => m[metric]));
        }
        
        return Math.abs(modelValue - bestValue) < 0.0001; // Account for floating point issues
    },
    
    /**
     * Render table based on tab ID
     * @param {string} tabId - Tab ID
     */
    renderTable: function(tabId) {
        const tableContainer = document.getElementById(tabId);
        if (!tableContainer) return;
        
        let tableHTML = '';
        
        switch (tabId) {
            case 'overview-tab':
                tableHTML = this.renderOverviewTable();
                break;
            case 'robustness-tab':
                tableHTML = this.renderRobustnessTable();
                break;
            case 'metrics-tab':
                tableHTML = this.renderMetricsTable();
                break;
            default:
                tableHTML = '<div class="text-center p-4">No data available</div>';
        }
        
        tableContainer.innerHTML = tableHTML;
    },
    
    /**
     * Render overview comparison table
     * @returns {string} - HTML for overview table
     */
    renderOverviewTable: function() {
        let html = `
        <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Model
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Base Score
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Robustness
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Impact
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Key Features
                    </th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">`;
            
        // Add rows for each model
        for (const [modelKey, model] of Object.entries(this.state.modelData)) {
            // Create the main model row
            html += `
                <tr 
                    data-model-key="${modelKey}"
                    class="${this.state.expandedRow === modelKey ? 'bg-blue-50' : ''} hover:bg-gray-50 cursor-pointer"
                >
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="flex items-center">
                            <div class="flex-shrink-0 h-10 w-10 rounded-full flex items-center justify-center ${
                                modelKey === 'primary_model' ? 'bg-blue-100' : 'bg-gray-100'
                            }">
                                <span class="text-lg font-bold">${model.name.charAt(0)}</span>
                            </div>
                            <div class="ml-4">
                                <div class="text-sm font-medium text-gray-900">${model.name}</div>
                                <div class="text-xs text-gray-500">${model.type}</div>
                            </div>
                        </div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 ${
                        this.isBestValue(modelKey, 'base_score') ? 'font-bold text-green-600' : ''
                    }">
                        ${this.formatNumber(model.base_score)}
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="flex items-center">
                            <span class="px-2 py-1 inline-flex text-xs leading-5 font-semibold rounded-full text-white ${
                                this.getRobustnessColor(model.robustness_score)
                            }">
                                ${this.formatNumber(model.robustness_score * 100, 1)}%
                            </span>
                        </div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap">
                        <span class="text-sm ${this.getImpactTextColor(model.raw_impact)}">
                            ${model.raw_impact < 0 ? '+' : ''}
                            ${this.formatNumber(Math.abs(model.raw_impact) * 100, 2)}%
                        </span>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        ${Object.keys(model.featureImportance).slice(0, 3).join(', ')}
                    </td>
                </tr>`;
                
            // Add expanded row if model is expanded
            if (this.state.expandedRow === modelKey) {
                html += `
                <tr class="bg-blue-50">
                    <td colspan="5" class="px-6 py-4">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <h3 class="font-medium text-gray-900 mb-2">Performance Metrics</h3>
                                <div class="grid grid-cols-2 gap-2">`;
                                
                for (const [metricName, value] of Object.entries(model.metrics)) {
                    html += `
                    <div class="flex justify-between p-2 bg-white rounded shadow-sm">
                        <span class="text-sm font-medium text-gray-500 capitalize">
                            ${metricName.replace('_', ' ')}:
                        </span>
                        <span class="text-sm font-medium text-gray-900">
                            ${this.formatNumber(value)}
                        </span>
                    </div>`;
                }
                
                html += `
                                </div>
                            </div>
                            
                            <div>
                                <h3 class="font-medium text-gray-900 mb-2">Key Features Importance</h3>
                                <div class="space-y-2">`;
                                
                for (const [feature, value] of Object.entries(model.featureImportance)) {
                    html += `
                    <div class="flex items-center">
                        <span class="text-sm font-medium text-gray-500 w-24">${feature}:</span>
                        <div class="flex-grow bg-gray-200 rounded-full h-2">
                            <div 
                                class="h-2 rounded-full ${value < 0 ? 'bg-red-500' : 'bg-blue-500'}"
                                style="width: ${Math.min(Math.abs(value) * 100 * 3, 100)}%"
                            ></div>
                        </div>
                        <span class="text-sm text-gray-900 ml-2">
                            ${this.formatNumber(value, 4)}
                        </span>
                    </div>`;
                }
                
                html += `
                                </div>
                            </div>
                        </div>
                    </td>
                </tr>`;
            }
        }
        
        html += `
            </tbody>
        </table>`;
        
        return html;
    },
    
    /**
     * Render robustness comparison table
     * @returns {string} - HTML for robustness table
     */
    renderRobustnessTable: function() {
        // Define perturbation levels - typically 0 to 1
        const perturbationLevels = [0, 0.1, 0.2, 0.4, 0.6, 0.8, 1.0];
        
        // Get perturbation scores from model data
        const perturbationScores = this.generatePerturbationScores(perturbationLevels);
        
        // Check if any valid scores exist
        const hasValidScores = Object.values(perturbationScores).some(scores => 
            scores.some(score => score !== null)
        );
        
        if (!hasValidScores) {
            return `
            <div class="p-6 text-center">
                <div class="text-red-500 mb-3">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                </div>
                <h3 class="text-lg font-medium text-gray-900 mb-2">No Perturbation Data Available</h3>
                <p class="text-gray-600">Perturbation analysis requires real data from robustness testing. Please run robustness tests to generate this data.</p>
            </div>`;
        }
        
        let html = `
        <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Model
                    </th>`;
                    
        // Add column for each perturbation level
        for (const level of perturbationLevels) {
            html += `
                    <th class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                        ${level * 100}%
                    </th>`;
        }
        
        html += `
                    <th class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Impact
                    </th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">`;
            
        // Add rows for each model
        for (const [modelKey, model] of Object.entries(this.state.modelData)) {
            html += `
                <tr 
                    data-model-key="${modelKey}"
                    class="${this.state.expandedRow === modelKey ? 'bg-blue-50' : ''} hover:bg-gray-50 cursor-pointer"
                >
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="flex items-center">
                            <div class="flex-shrink-0 h-8 w-8 rounded-full flex items-center justify-center ${
                                modelKey === 'primary_model' ? 'bg-blue-100' : 'bg-gray-100'
                            }">
                                <span class="text-md font-bold">${model.name.charAt(0)}</span>
                            </div>
                            <div class="ml-3 text-sm font-medium text-gray-900">${model.name}</div>
                        </div>
                    </td>`;
                    
            // Add cell for each perturbation level
            for (let i = 0; i < perturbationLevels.length; i++) {
                const level = perturbationLevels[i];
                const score = perturbationScores[modelKey][i];
                
                // Skip null scores
                if (score === null) {
                    html += `
                    <td class="px-4 py-3 text-center text-sm bg-gray-100">
                        <div class="font-medium text-gray-400">N/A</div>
                    </td>`;
                    continue;
                }
                
                const baseScore = model.base_score;
                const diff = score - baseScore;
                const percentChange = (diff / baseScore) * 100;
                
                // Get background color based on performance change
                let bgColor = 'bg-white';
                if (level === 0) {
                    bgColor = 'bg-gray-100';
                } else if (diff > 0) {
                    bgColor = 'bg-green-50';
                } else if (diff < -0.1) {
                    bgColor = 'bg-red-50';
                } else if (diff < -0.05) {
                    bgColor = 'bg-orange-50';
                } else if (diff < 0) {
                    bgColor = 'bg-yellow-50';
                }
                
                html += `
                    <td class="px-4 py-3 text-center text-sm ${bgColor}">
                        <div class="font-medium text-gray-900">
                            ${this.formatNumber(score)}
                        </div>
                        ${level > 0 ? `
                        <div class="text-xs ${
                            diff >= 0 ? 'text-green-600' : diff < -0.1 ? 'text-red-600' : 'text-yellow-600'
                        }">
                            ${diff >= 0 ? '+' : ''}
                            ${this.formatNumber(percentChange, 1)}%
                        </div>
                        ` : ''}
                    </td>`;
            }
            
            html += `
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-center font-medium ${
                        this.getImpactTextColor(model.raw_impact)
                    }">
                        ${model.raw_impact < 0 ? 'Improved' : this.formatNumber(model.raw_impact * 100, 1) + '%'}
                    </td>
                </tr>`;
        }
        
        html += `
            </tbody>
        </table>`;
        
        return html;
    },
    
    /**
     * Get perturbation scores for each model
     * @param {Array} levels - Perturbation levels
     * @returns {Object} - Scores by model and level
     */
    generatePerturbationScores: function(levels) {
        // Check if model data contains perturbation results
        if (!this.state.modelData || Object.keys(this.state.modelData).length === 0) {
            console.error('No model data available for perturbation analysis');
            return {};
        }

        // Initialize scores object
        const scores = {};
        
        for (const [modelKey, model] of Object.entries(this.state.modelData)) {
            // Check if model has perturbation data
            if (!model.perturbationResults) {
                console.warn(`No perturbation data available for model: ${model.name}`);
                scores[modelKey] = levels.map(() => null);
                continue;
            }
            
            scores[modelKey] = [];
            
            // Map each level to its score from the real data
            for (const level of levels) {
                const levelData = model.perturbationResults.find(p => 
                    Math.abs(p.level - level) < 0.001
                );
                
                if (levelData && levelData.score !== undefined) {
                    scores[modelKey].push(levelData.score);
                } else if (level === 0) {
                    // Use base score for level 0 if not explicitly provided
                    scores[modelKey].push(model.base_score);
                } else {
                    scores[modelKey].push(null);
                }
            }
        }
        
        return scores;
    },
    
    /**
     * Render metrics comparison table
     * @returns {string} - HTML for metrics table
     */
    renderMetricsTable: function() {
        const metric = this.state.selectedMetric;
        
        let html = `
        <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Model
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        ${metric === 'roc_auc' ? 'ROC AUC' : 
                          metric === 'f1' ? 'F1 Score' : 
                          metric.charAt(0).toUpperCase() + metric.slice(1)}
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Robustness
                    </th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Trade-off
                    </th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">`;
        
        // Add rows for each model
        for (const [modelKey, model] of Object.entries(this.state.modelData)) {
            // Calculate the trade-off metric (performance x robustness)
            const metricValue = metric === 'robustness_score' ? model.robustness_score : 
                                metric === 'raw_impact' ? model.raw_impact : 
                                model.metrics[metric];
                                
            const tradeoffValue = metricValue * model.robustness_score;
            
            // Check if this model has the best trade-off
            const isBestTradeoff = this.isHighestTradeoff(modelKey, metric);
            
            html += `
                <tr 
                    class="${isBestTradeoff && this.state.highlightBest ? 'bg-green-50' : ''} hover:bg-gray-50"
                    data-model-key="${modelKey}"
                >
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="flex items-center">
                            <div class="flex-shrink-0 h-8 w-8 rounded-full flex items-center justify-center ${
                                modelKey === 'primary_model' ? 'bg-blue-100' : 'bg-gray-100'
                            }">
                                <span class="text-md font-bold">${model.name.charAt(0)}</span>
                            </div>
                            <div class="ml-3 text-sm font-medium text-gray-900">${model.name}</div>
                        </div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${
                        this.isBestValue(modelKey, metric) ? 'font-bold text-blue-600' : 'text-gray-500'
                    }">
                        ${this.formatNumber(metricValue)}
                        
                        <div class="mt-1 w-32 bg-gray-200 rounded-full h-2">
                            <div 
                                class="h-2 rounded-full bg-blue-500"
                                style="width: ${Math.min(metricValue * 100, 100)}%"
                            ></div>
                        </div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${
                        this.isBestValue(modelKey, 'robustness_score') ? 'font-bold text-blue-600' : 'text-gray-500'
                    }">
                        ${this.formatNumber(model.robustness_score, 2)}
                        
                        <div class="mt-1 w-32 bg-gray-200 rounded-full h-2">
                            <div 
                                class="h-2 rounded-full ${this.getRobustnessColor(model.robustness_score)}"
                                style="width: ${Math.min(model.robustness_score * 100, 100)}%"
                            ></div>
                        </div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="text-sm text-gray-900 font-medium">
                            ${this.formatNumber(tradeoffValue, 3)}
                        </div>
                        <div class="text-xs text-gray-500">
                            Performance  Robustness
                        </div>
                    </td>
                </tr>`;
        }
        
        html += `
            </tbody>
        </table>`;
        
        return html;
    },
    
    /**
     * Check if model has the highest trade-off value
     * @param {string} modelKey - Model key
     * @param {string} metric - Metric name
     * @returns {boolean} - Whether model has highest trade-off
     */
    isHighestTradeoff: function(modelKey, metric) {
        if (!this.state.highlightBest) return false;
        
        // Calculate trade-off for each model
        const tradeoffs = {};
        for (const [key, model] of Object.entries(this.state.modelData)) {
            const metricValue = metric === 'robustness_score' ? model.robustness_score : 
                                metric === 'raw_impact' ? model.raw_impact : 
                                model.metrics[metric];
            tradeoffs[key] = metricValue * model.robustness_score;
        }
        
        // Find the highest trade-off value
        const highestValue = Math.max(...Object.values(tradeoffs));
        
        // Check if this model has the highest trade-off
        return Math.abs(tradeoffs[modelKey] - highestValue) < 0.0001;
    },
    
    /**
     * Render perturbation chart
     * @param {string} elementId - Chart element ID
     */
    renderPerturbationChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement || typeof Plotly === 'undefined') return;
        
        try {
            // Define perturbation levels
            const perturbationLevels = [0, 0.1, 0.2, 0.4, 0.6, 0.8, 1.0];
            
            // Get perturbation scores from model data
            const perturbationScores = this.generatePerturbationScores(perturbationLevels);
            
            // Check if any valid scores exist
            const hasValidScores = Object.values(perturbationScores).some(scores => 
                scores.some(score => score !== null)
            );
            
            if (!hasValidScores) {
                chartElement.innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <div style="color: #e53e3e; margin-bottom: 1rem;">
                        <svg xmlns="http://www.w3.org/2000/svg" style="height: 3rem; width: 3rem; margin: 0 auto 0.5rem;" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                        </svg>
                    </div>
                    <h3 style="font-size: 1.125rem; font-weight: 500; color: #1a202c; margin-bottom: 0.5rem;">No Perturbation Data Available</h3>
                    <p style="color: #4a5568;">Perturbation analysis requires real data from robustness testing. Please run robustness tests to generate this data.</p>
                </div>`;
                return;
            }
            
            // Create plot traces
            const traces = [];
            
            for (const [modelKey, model] of Object.entries(this.state.modelData)) {
                // Skip models with no valid scores
                if (!perturbationScores[modelKey] || !perturbationScores[modelKey].some(score => score !== null)) {
                    continue;
                }
                
                // Replace null values with NaN for proper line gaps in chart
                const scores = perturbationScores[modelKey].map(score => score === null ? NaN : score);
                
                traces.push({
                    x: perturbationLevels.map(l => l * 100), // Convert to percentages
                    y: scores,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: model.name,
                    line: {
                        width: modelKey === 'primary_model' ? 3 : 2,
                        dash: modelKey === 'primary_model' ? 'solid' : 'dot'
                    },
                    marker: {
                        size: modelKey === 'primary_model' ? 8 : 6
                    }
                });
            }
            
            // Layout configuration
            const layout = {
                title: 'Model Performance under Perturbation',
                xaxis: {
                    title: 'Perturbation Level (%)',
                    ticksuffix: '%'
                },
                yaxis: {
                    title: 'Performance Score'
                },
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                margin: {
                    l: 60,
                    r: 30,
                    t: 50,
                    b: 80
                },
                hovermode: 'closest'
            };
            
            // Create the plot
            Plotly.newPlot(chartElement, traces, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating perturbation chart:", error);
            chartElement.innerHTML = `<div style='padding: 20px; color: red;'>Error creating chart: ${error.message}</div>`;
        }
    }
};

// ----- charts_details ----- //
/**
 * Overview Charts Manager
 * Handles chart creation and data visualization for the model overview page
 */
window.OverviewChartsManager = {
    /**
     * Initialize all charts on the overview page
     */
    initializeOverviewCharts: function() {
        console.log("Initializing overview charts");
        
        try {
            // Initialize the metrics radar chart
            this.initializeMetricsRadarChart("metrics-radar-chart");
        } catch (error) {
            console.error("Error initializing overview charts:", error);
            this.showErrorMessage(document.getElementById("metrics-radar-chart"), error.message);
        }
    },
    
    /**
     * Initialize metrics radar chart
     * @param {string} elementId - Chart container ID
     */
    initializeMetricsRadarChart: function(elementId) {
        console.log("Initializing metrics radar chart");
        const chartElement = document.getElementById(elementId);
        if (!chartElement) {
            console.error("Chart element not found:", elementId);
            return;
        }
        
        try {
            // Clear any previous content to avoid double rendering
            chartElement.innerHTML = '';
            
            // Extract data for chart with validation
            const chartData = this.extractMetricsRadarData();
            
            if (!chartData || !chartData.models || chartData.models.length === 0) {
                this.showNoDataMessage(chartElement, "No model metrics data available");
                return;
            }
            
            // Create data traces for each model
            const traces = [];
            
            // Get metrics and model names
            const metrics = chartData.metrics;
            const modelNames = chartData.models.map(model => model.name);
            
            // Create a radar trace for each metric
            metrics.forEach(metric => {
                const trace = {
                    type: 'scatterpolar',
                    name: metric.displayName,
                    r: chartData.models.map(model => model.metrics[metric.name]),
                    theta: modelNames,
                    fill: 'toself',
                    opacity: 0.7,
                    hovertemplate: '<b>%{theta}</b><br>' + 
                                   metric.displayName + ': %{r:.4f}<extra></extra>'
                };
                traces.push(trace);
            });
            
            // Layout for the radar chart
            const layout = {
                title: 'Comparao de Mtricas por Modelo',
                polar: {
                    radialaxis: {
                        visible: true,
                        range: [0, 1],
                        showticklabels: true,
                        gridcolor: "#d9d9d9",
                        tickformat: ".2f"
                    },
                    angularaxis: {
                        gridcolor: "#d9d9d9"
                    }
                },
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                margin: {
                    l: 50,
                    r: 50,
                    t: 60,
                    b: 70
                },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: '#fff'
            };
            
            // Create the plot with error handling
            try {
                Plotly.newPlot(chartElement, traces, layout, {
                    responsive: true,
                    displayModeBar: false,
                    displaylogo: false
                });
            } catch (plotlyError) {
                console.error("Plotly rendering error:", plotlyError);
                this.showErrorMessage(chartElement, "Chart rendering failed: " + plotlyError.message);
                return;
            }
            
            // Add resize event listener
            window.addEventListener('resize', () => {
                Plotly.relayout(chartElement, {
                    'autosize': true
                });
            });
            
        } catch (error) {
            console.error("Error creating metrics radar chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Extract data for metrics radar chart
     * @returns {Object} - Metrics and model data
     */
    extractMetricsRadarData: function() {
        let models = [];
        
        // Try multiple sources for model metrics data
        let modelData = {};
        
        // Try window.reportData first (preferred source)
        if (window.reportData && window.reportData.models) {
            modelData = window.reportData.models;
            console.log("Using model data from reportData");
        } else if (window.chartData && window.chartData.models) {
            // Try chart data
            modelData = window.chartData.models;
            console.log("Using model data from chartData");
        } else if (window.config && window.config.models) {
            // Try config
            modelData = window.config.models;
            console.log("Using model data from config");
        } else {
            console.warn("No model data found in any data source");
            return null;
        }
        
        // Check if we have any model data
        if (Object.keys(modelData).length === 0) {
            console.warn("Empty model data");
            return null;
        }
        
        console.log("Found data for", Object.keys(modelData).length, "models");
        
        try {
            // Convert to array format for plotting
            models = Object.entries(modelData).map(([key, model]) => ({
                id: key,
                name: model.name || key,
                type: model.type || "Unknown",
                metrics: model.metrics || {}
            }));
            
            // Define metrics to display
            const metrics = [
                { name: "accuracy", displayName: "Accuracy" },
                { name: "roc_auc", displayName: "ROC AUC" },
                { name: "f1", displayName: "F1 Score" },
                { name: "precision", displayName: "Precision" },
                { name: "recall", displayName: "Recall" }
            ];
            
            // Validate that each model has the required metrics
            models.forEach(model => {
                metrics.forEach(metric => {
                    if (model.metrics[metric.name] === undefined) {
                        model.metrics[metric.name] = 0;
                        console.warn(`Missing ${metric.name} metric for model ${model.name}`);
                    }
                });
            });
            
            console.log("Prepared", models.length, "models with", metrics.length, "metrics each");
            
            return {
                models,
                metrics
            };
        } catch (error) {
            console.error("Error processing model metrics data:", error);
            return null;
        }
    },
    
    /**
     * Create a custom metric chart for a specific model and metric
     * @param {string} elementId - Chart container ID
     * @param {string} modelId - Model identifier
     * @param {string} metricName - Metric name to display
     */
    createModelMetricChart: function(elementId, modelId, metricName) {
        console.log(`Creating metric chart for ${modelId} - ${metricName}`);
        const chartElement = document.getElementById(elementId);
        if (!chartElement) {
            console.error("Chart element not found:", elementId);
            return;
        }
        
        // Extract data with specific model and metric filtering
        const chartData = this.extractMetricsRadarData();
        
        if (!chartData || !chartData.models || chartData.models.length === 0) {
            this.showNoDataMessage(chartElement, "No model metrics data available");
            return;
        }
        
        try {
            // Clear previous content
            chartElement.innerHTML = '';
            
            // Find the metric display name
            const metricInfo = chartData.metrics.find(m => m.name === metricName);
            if (!metricInfo) {
                this.showErrorMessage(chartElement, `Metric ${metricName} not found`);
                return;
            }
            
            // Filter models if specific model is requested
            let modelsToUse = chartData.models;
            if (modelId !== 'all') {
                modelsToUse = chartData.models.filter(model => model.id === modelId);
                if (modelsToUse.length === 0) {
                    this.showErrorMessage(chartElement, `Model ${modelId} not found`);
                    return;
                }
            }
            
            // Prepare data for the bar chart
            const chartTrace = {
                x: modelsToUse.map(model => model.name),
                y: modelsToUse.map(model => model.metrics[metricName]),
                type: 'bar',
                marker: {
                    color: modelsToUse.map((_, index) => {
                        // Generate colors based on index
                        const colors = ['#8884d8', '#82ca9d', '#ffc658', '#ff8042', '#0088fe'];
                        return colors[index % colors.length];
                    })
                },
                hovertemplate: '<b>%{x}</b><br>' + 
                               metricInfo.displayName + ': %{y:.4f}<extra></extra>'
            };
            
            // Layout for the bar chart
            const layout = {
                title: `${metricInfo.displayName} por Modelo`,
                xaxis: {
                    title: 'Modelo',
                    automargin: true
                },
                yaxis: {
                    title: metricInfo.displayName,
                    range: [0, 1.1],
                    tickformat: '.2f'
                },
                margin: {
                    l: 60,
                    r: 30,
                    t: 60,
                    b: 80
                },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: '#fff'
            };
            
            // Create the plot
            Plotly.newPlot(chartElement, [chartTrace], layout, {
                responsive: true,
                displayModeBar: false,
                displaylogo: false
            });
            
        } catch (error) {
            console.error("Error creating model metric chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Show no data message in chart container
     * @param {HTMLElement} element - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(element, message) {
        element.innerHTML = `
            <div class="no-data-container">
                <div class="no-data-icon"></div>
                <h3 class="no-data-title">Dados No Disponveis</h3>
                <p class="no-data-message">${message}</p>
            </div>`;
    },
    
    /**
     * Show error message in chart container
     * @param {HTMLElement} element - Chart container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(element, errorMessage) {
        element.innerHTML = `
            <div class="error-container">
                <div class="error-icon"></div>
                <h3 class="error-title">Erro no Grfico</h3>
                <p class="error-message">${errorMessage}</p>
                <div class="error-help">
                    <p class="error-help-title">Possveis solues:</p>
                    <ul class="error-help-list">
                        <li>Verifique se a biblioteca Plotly est carregada corretamente</li>
                        <li>Confirme que os dados dos modelos esto disponveis</li>
                        <li>Tente recarregar a pgina</li>
                    </ul>
                </div>
            </div>`;
    }
};

// PerturbationResultsManager.js
// Updated: May 7, 2024 - Removed synthetic data generation
const PerturbationResultsManager = {
    /**
     * Extract perturbation data from report data
     * @returns {Object} Perturbation data
     */
    extractPerturbationData: function() {
        console.log("Extracting perturbation data from report");
        const perturbationResults = [];
        
        try {
            // Check if window.reportData exists and has necessary data
            if (!window.reportData || (!window.reportData.raw && !window.reportData.perturbation_chart_data)) {
                console.warn("Report data not found or incomplete");
                console.warn("No synthetic data will be generated - will return null");
                return null; // Return null if no report data available
            }
            
            // If the server already prepared perturbation chart data, use it
            if (window.reportData.perturbation_chart_data) {
                console.log("Using server-prepared perturbation chart data");
                return this.processPreparedChartData(window.reportData.perturbation_chart_data);
            }
            
            // Extract from raw data if available
            if (window.reportData.raw && window.reportData.raw.by_level) {
                console.log("Extracting from raw perturbation data");
                
                // Get base score and metric
                const baseScore = window.reportData.base_score || 0.0;
                const metric = window.reportData.metric || 'Score';
                
                // Process each perturbation level
                Object.keys(window.reportData.raw.by_level).forEach(level => {
                    const numericLevel = parseFloat(level);
                    const levelData = window.reportData.raw.by_level[level];
                    
                    const resultItem = {
                        level: numericLevel,
                        allFeatures: this.extractFeatureData(levelData, 'all_features', baseScore),
                        featureSubset: this.extractFeatureData(levelData, 'feature_subset', baseScore)
                    };
                    
                    // If feature subset wasn't found, try to extract from selectedFeatures
                    if (!resultItem.featureSubset.iterations.length && window.reportData.feature_subset) {
                        const featureSubset = window.reportData.feature_subset;
                        if (Array.isArray(featureSubset) && featureSubset.length > 0) {
                            const subsetName = featureSubset.join('_');
                            resultItem.featureSubset = this.extractFeatureData(levelData, subsetName, baseScore);
                        }
                    }
                    
                    perturbationResults.push(resultItem);
                });
                
                // Sort by level
                perturbationResults.sort((a, b) => a.level - b.level);
                
                // Only return if we actually have results
                if (perturbationResults.length > 0) {
                    return {
                        results: perturbationResults,
                        baseScore: baseScore,
                        metric: metric,
                        modelName: window.reportData.model_name || 'Model',
                        modelType: window.reportData.model_type || 'Model',
                        featureSubset: window.reportData.feature_subset || []
                    };
                }
            }
            
            // If no perturbation data found, return null (no synthetic data)
            console.warn("No perturbation data found in report data");
            console.warn("No synthetic data will be generated - will return null");
            return null;
            
        } catch (error) {
            console.error("Error extracting perturbation data:", error);
            console.error("No synthetic data will be generated due to error - will return null");
            return null; // Return null on error
        }
    },
    
    /**
     * Process server-prepared chart data
     * @param {Object} chartData - Server-prepared chart data 
     * @returns {Object} Processed perturbation data
     */
    processPreparedChartData: function(chartData) {
        const perturbationResults = [];
        const baseScore = chartData.baseScore || 0.0;
        const metric = chartData.metric || 'Score';
        
        // Process levels and scores
        if (chartData.levels && chartData.scores) {
            chartData.levels.forEach((level, index) => {
                const resultItem = {
                    level: level,
                    allFeatures: {
                        baseScore: baseScore,
                        meanScore: chartData.scores[index] || 0,
                        impact: (baseScore - (chartData.scores[index] || 0)) / baseScore,
                        worstScore: chartData.worstScores ? chartData.worstScores[index] || 0 : 0,
                        iterations: []
                    },
                    featureSubset: {
                        baseScore: baseScore,
                        meanScore: 0,
                        impact: 0,
                        worstScore: 0,
                        iterations: []
                    }
                };
                
                // Add iterations if available
                if (window.reportData.iterations_by_level && window.reportData.iterations_by_level[level]) {
                    resultItem.allFeatures.iterations = window.reportData.iterations_by_level[level];
                } else if (chartData.iterations && chartData.iterations[index]) {
                    resultItem.allFeatures.iterations = chartData.iterations[index];
                }
                // No synthetic iterations will be created if none are available
                
                // Process feature subset if available
                if (chartData.alternativeModels && Object.keys(chartData.alternativeModels).length > 0) {
                    const subsetName = Object.keys(chartData.alternativeModels)[0];
                    const subsetData = chartData.alternativeModels[subsetName];
                    
                    resultItem.featureSubset = {
                        baseScore: subsetData.baseScore || baseScore,
                        meanScore: subsetData.scores[index] || 0,
                        impact: (baseScore - (subsetData.scores[index] || 0)) / baseScore,
                        worstScore: subsetData.worstScores ? subsetData.worstScores[index] || 0 : 0,
                        iterations: []
                    };
                    
                    // Only add real iteration data, no synthetic data
                    if (subsetData.iterations && subsetData.iterations[index]) {
                        resultItem.featureSubset.iterations = subsetData.iterations[index];
                    }
                }
                
                perturbationResults.push(resultItem);
            });
        }
        
        return {
            results: perturbationResults,
            baseScore: baseScore,
            metric: metric,
            modelName: chartData.modelName || 'Model',
            modelType: window.reportData.model_type || 'Model',
            featureSubset: window.reportData.feature_subset || []
        };
    },
    
    /**
     * Extract feature data from level data
     * @param {Object} levelData - Level data
     * @param {string} featureKey - Feature key to extract
     * @param {number} baseScore - Base score
     * @returns {Object} Extracted feature data
     */
    extractFeatureData: function(levelData, featureKey, baseScore) {
        const result = {
            baseScore: baseScore,
            meanScore: 0,
            impact: 0,
            worstScore: 0,
            iterations: []
        };
        
        try {
            // Check if we have overall_result data
            if (levelData.overall_result && levelData.overall_result[featureKey]) {
                const featureData = levelData.overall_result[featureKey];
                
                result.meanScore = featureData.mean_score || featureData.perturbed_score || 0;
                result.worstScore = featureData.worst_score || featureData.min_score || result.meanScore;
                result.impact = (baseScore - result.meanScore) / baseScore;
                
                // If negative impact (improvement), cap at a reasonable value
                if (result.impact < -0.1) result.impact = -0.1;
            }
            
            // Extract iteration data if available - NO synthetic data generation
            if (levelData.runs && levelData.runs[featureKey] && 
                levelData.runs[featureKey][0] && 
                levelData.runs[featureKey][0].iterations &&
                levelData.runs[featureKey][0].iterations.scores) {
                    
                result.iterations = levelData.runs[featureKey][0].iterations.scores;
            }
            // No synthetic iterations data will be created
        } catch (error) {
            console.error(`Error extracting ${featureKey} data:`, error);
        }
        
        return result;
    },
    
    /**
     * Format number with specified precision
     * @param {number} num - Number to format
     * @param {number} precision - Number of decimal places
     * @returns {string} Formatted number
     */
    formatNumber: function(num, precision = 4) {
        return Number(num).toFixed(precision);
    },
    
    /**
     * Get color class based on impact
     * @param {number} impact - Impact value
     * @returns {string} CSS class for coloring
     */
    getImpactColorClass: function(impact) {
        if (impact < 0) return 'text-green-600'; // Improvement
        if (impact < 0.03) return 'text-blue-600'; // Small degradation
        if (impact < 0.07) return 'text-yellow-600'; // Medium degradation
        return 'text-red-600'; // Large degradation
    },
    
    /**
     * Get background color class based on score comparison
     * @param {number} score - Score to compare
     * @param {number} baseScore - Base score for comparison
     * @returns {string} CSS class for background coloring
     */
    getScoreBgColorClass: function(score, baseScore) {
        const diff = score - baseScore;
        if (diff > 0) return 'bg-green-100';
        if (diff > -0.01) return 'bg-yellow-50';
        if (diff > -0.03) return 'bg-orange-50';
        return 'bg-red-50';
    }
};

// ----- charts_features ----- //
// Feature Importance Chart Manager
window.FeatureImportanceChartManager = {
    /**
     * Initialize feature importance chart
     * @param {string} elementId - Chart container ID
     */
    initializeFeatureImportanceChart: function(elementId) {
        console.log("Initializing feature importance chart");
        const chartElement = document.getElementById(elementId);
        if (!chartElement) {
            console.error("Chart element not found:", elementId);
            return;
        }
        
        try {
            // Clear any previous content to avoid double rendering
            chartElement.innerHTML = '';
            
            // Extract data for chart with improved validation
            const chartData = this.extractFeatureImportanceData();
            
            if (!chartData || !chartData.features || chartData.features.length === 0) {
                this.showNoDataMessage(chartElement, "No feature importance data available");
                return;
            }
            
            // Create plot data for robustness impact
            const robustnessTrace = {
                x: chartData.robustnessValues,
                y: chartData.features,
                type: 'bar',
                orientation: 'h',
                name: 'Robustness Impact',
                marker: {
                    color: chartData.robustnessValues.map(val => val >= 0 ? 'rgb(136, 132, 216)' : 'rgb(216, 132, 132)')
                }
            };
            
            // Create plot data for model importance (if available)
            const plotData = [robustnessTrace];
            
            if (chartData.modelValues && chartData.modelValues.length > 0) {
                const modelTrace = {
                    x: chartData.modelValues,
                    y: chartData.features,
                    type: 'bar',
                    orientation: 'h',
                    name: 'Model Importance',
                    marker: {
                        color: 'rgb(130, 202, 157)'
                    }
                };
                plotData.push(modelTrace);
            }
            
            // Layout for the chart with improved readability
            const layout = {
                title: 'Top Features by Importance',
                xaxis: {
                    title: 'Importance Score',
                    zeroline: true,
                    zerolinecolor: '#888',
                    zerolinewidth: 1
                },
                yaxis: {
                    title: 'Feature',
                    automargin: true
                },
                barmode: 'group',
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                hovermode: 'closest',
                margin: {
                    l: 150,
                    r: 20,
                    t: 60,
                    b: 100
                },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: '#fff'
            };
            
            // Create the plot with improved error handling
            try {
                Plotly.newPlot(chartElement, plotData, layout, {
                    responsive: true,
                    displayModeBar: false,
                    modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                    displaylogo: false,
                    staticPlot: false
                });
            } catch (plotlyError) {
                console.error("Plotly rendering error:", plotlyError);
                this.showErrorMessage(chartElement, "Chart rendering failed: " + plotlyError.message);
                return;
            }
            
            // Add resize event listener to properly redraw the chart when tab becomes visible
            window.addEventListener('resize', () => {
                if (chartElement.closest('.tab-content.active')) {
                    Plotly.relayout(chartElement, {
                        'autosize': true
                    });
                }
            });
            
        } catch (error) {
            console.error("Error creating feature importance chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Extract data for feature importance chart from report data with improved validation
     */
    extractFeatureImportanceData: function() {
        let features = [];
        let robustnessValues = [];
        let modelValues = [];
        
        // First validate we have the required data
        let featureImportance = {};
        let modelFeatureImportance = {};
        
        // Try multiple sources for feature importance data
        if (window.chartData && window.chartData.feature_importance) {
            // Try chart data first (preferred source)
            featureImportance = window.chartData.feature_importance;
            modelFeatureImportance = window.chartData.model_feature_importance || {};
            console.log("Using feature importance from chartData");
        } else if (window.reportConfig && window.reportConfig.feature_importance) {
            // Try reportConfig 
            featureImportance = window.reportConfig.feature_importance;
            modelFeatureImportance = window.reportConfig.model_feature_importance || {};
            console.log("Using feature importance from reportConfig");
        } else if (window.reportData) {
            if (window.reportData.feature_importance) {
                // Try direct reportData
                featureImportance = window.reportData.feature_importance;
                modelFeatureImportance = window.reportData.model_feature_importance || {};
                console.log("Using feature importance from reportData");
            } else if (window.reportData.chart_data_json) {
                // Try parsing chart_data_json
                try {
                    const chartData = JSON.parse(window.reportData.chart_data_json);
                    featureImportance = chartData.feature_importance || {};
                    modelFeatureImportance = chartData.model_feature_importance || {};
                    console.log("Using feature importance from parsed chart_data_json");
                } catch (e) {
                    console.error("Error parsing chart_data_json:", e);
                }
            }
        }
        
        // Check if we have any feature importance data
        if (Object.keys(featureImportance).length === 0) {
            console.warn("No feature importance data found in any data source");
            return null;
        }
        
        console.log("Found feature importance data for ", Object.keys(featureImportance).length, "features");
        
        try {
            // Convert to array and sort by robustness impact (absolute value)
            const featureArray = Object.keys(featureImportance).map(feature => ({
                name: feature,
                robustnessImportance: featureImportance[feature],
                modelImportance: modelFeatureImportance[feature] || 0
            }));
            
            // Sort by absolute robustness importance value
            featureArray.sort((a, b) => Math.abs(b.robustnessImportance) - Math.abs(a.robustnessImportance));
            
            // Get top 15 features (increased from 10)
            const topFeatures = featureArray.slice(0, 15);
            
            // Extract arrays for plotting
            features = topFeatures.map(f => f.name);
            robustnessValues = topFeatures.map(f => f.robustnessImportance);
            modelValues = topFeatures.map(f => f.modelImportance);
            
            // Log what we found
            console.log("Extracted top", features.length, "features for chart");
        } catch (error) {
            console.error("Error processing feature importance data:", error);
            return null;
        }
        
        return {
            features,
            robustnessValues,
            modelValues
        };
    },
    
    /**
     * Initialize model vs robustness importance chart with improved error handling
     * @param {string} elementId - Chart container ID
     */
    initializeImportanceComparisonChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement) {
            console.error("Chart element not found:", elementId);
            return;
        }
        
        try {
            // Clear any previous content
            chartElement.innerHTML = '';
            
            // Extract data with validation
            const chartData = this.extractFeatureImportanceData();
            
            if (!chartData || !chartData.features || chartData.features.length === 0 || 
                !chartData.modelValues || chartData.modelValues.length === 0) {
                this.showNoDataMessage(chartElement, "No feature importance comparison data available");
                return;
            }
            
            // Create scatter plot data with color coding based on importance
            const importanceData = chartData.features.map((feature, i) => ({
                feature: feature,
                robustness: chartData.robustnessValues[i],
                model: chartData.modelValues[i],
                impact: Math.abs(chartData.robustnessValues[i]) // For sizing markers
            }));
            
            // Create scatter plot with color coding
            const scatterTrace = {
                x: importanceData.map(d => d.model),
                y: importanceData.map(d => d.robustness),
                mode: 'markers+text',
                type: 'scatter',
                text: importanceData.map(d => d.feature),
                textposition: 'top',
                marker: {
                    size: importanceData.map(d => Math.min(Math.max(d.impact * 500, 8), 20)), // Size by importance
                    color: importanceData.map(d => d.robustness >= 0 ? 'rgb(44, 160, 101)' : 'rgb(215, 48, 39)'),
                    opacity: 0.8,
                    line: {
                        width: 1,
                        color: '#333'
                    }
                },
                hovertemplate: '<b>%{text}</b><br>Model Importance: %{x:.4f}<br>Robustness Impact: %{y:.4f}<extra></extra>'
            };
            
            // Layout for the chart
            const layout = {
                title: 'Model vs. Robustness Importance',
                xaxis: {
                    title: 'Model Importance',
                    zeroline: true
                },
                yaxis: {
                    title: 'Robustness Impact',
                    zeroline: true
                },
                hovermode: 'closest',
                margin: {
                    l: 60,
                    r: 20,
                    t: 60,
                    b: 60
                },
                // Add reference lines at x=0 and y=0
                shapes: [
                    {
                        type: 'line',
                        x0: 0,
                        y0: 0,
                        x1: 0,
                        y1: 1,
                        yref: 'paper',
                        line: {
                            color: 'grey',
                            width: 1,
                            dash: 'dot'
                        }
                    },
                    {
                        type: 'line',
                        x0: 0,
                        y0: 0,
                        x1: 1,
                        y1: 0,
                        xref: 'paper',
                        line: {
                            color: 'grey',
                            width: 1,
                            dash: 'dot'
                        }
                    }
                ],
                annotations: [
                    {
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.01,
                        y: 0.99,
                        text: 'Negative impact on model robustness',
                        showarrow: false,
                        font: {
                            size: 11,
                            color: 'gray'
                        }
                    },
                    {
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.99,
                        y: 0.99,
                        text: 'Positive impact on model robustness',
                        showarrow: false,
                        font: {
                            size: 11,
                            color: 'gray'
                        },
                        align: 'right'
                    }
                ]
            };
            
            // Create the plot with error handling
            try {
                Plotly.newPlot(chartElement, [scatterTrace], layout, {
                    responsive: true,
                    displayModeBar: false
                });
            } catch (plotlyError) {
                console.error("Plotly rendering error:", plotlyError);
                this.showErrorMessage(chartElement, "Chart rendering failed: " + plotlyError.message);
                return;
            }
            
            // Add resize event listener
            window.addEventListener('resize', () => {
                if (chartElement.closest('.tab-content.active')) {
                    Plotly.relayout(chartElement, {
                        'autosize': true
                    });
                }
            });
            
        } catch (error) {
            console.error("Error creating importance comparison chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Show no data message in chart container with improved styling
     * @param {HTMLElement} element - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(element, message) {
        element.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">No Data Available</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">
                    ${message}
                </p>
            </div>`;
    },
    
    /**
     * Show error message in chart container with improved styling
     * @param {HTMLElement} element - Chart container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(element, errorMessage) {
        element.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                <div style="margin-top: 20px; padding: 15px; background-color: #f8f8f8; border-radius: 5px; text-align: left;">
                    <p style="font-weight: bold; margin-bottom: 10px;">Troubleshooting:</p>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-bottom: 0;">
                        <li>Check if the Plotly library is loaded correctly</li>
                        <li>Verify that feature importance data is available in the report</li>
                        <li>Try reloading the page</li>
                    </ul>
                </div>
            </div>`;
    }
};

// ----- charts_overview ----- //
// Chart Manager for Overview Section
const ChartManager = {
    /**
     * Initialize perturbation chart
     * @param {string} elementId - Chart container ID
     */
    
    initializePerturbationChart: function(elementId) {
        console.log("Initializing perturbation chart");
        const chartElement = document.getElementById(elementId);
        if (!chartElement) {
            console.error("Chart element not found:", elementId);
            return;
        }
        
        try {
            // Extract data for chart
            let chartData = this.extractPerturbationChartData();
            
            // Debug logs para investigar por que a linha de subset score no est aparecendo
            console.log("Chart data for Perturbation Chart:", chartData);
            console.log("featureSubsetScores available:", chartData.featureSubsetScores && chartData.featureSubsetScores.length > 0);
            console.log("featureSubsetScores:", chartData.featureSubsetScores);
            
            // Se mesmo assim no temos dados de featureSubsetScores, vamos busc-los diretamente dos dados raw
            if ((!chartData.featureSubsetScores || chartData.featureSubsetScores.length === 0 || 
                !chartData.featureSubsetScores.some(v => v !== null)) && 
                window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
                
                console.log("Tentativa final de extrair feature subset scores direto dos raw data");
                const rawData = window.reportData.raw.by_level;
                const levels = chartData.levels;
                
                // Extrair featureSubsetScores direto da fonte
                // Primeiro verificamos quais nveis esto disponveis nos dados raw
                const availableLevels = Object.keys(rawData).map(level => parseFloat(level));
                console.log("Nveis disponveis nos dados raw:", availableLevels);
                console.log("Nveis que queremos no grfico:", levels);
                
                // Criar um mapeamento de todos os scores de feature_subset disponveis
                const allSubsetScores = {};
                Object.keys(rawData).forEach(levelStr => {
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.feature_subset &&
                        rawData[levelStr].overall_result.feature_subset.mean_score !== undefined) {
                        const level = parseFloat(levelStr);
                        const score = rawData[levelStr].overall_result.feature_subset.mean_score;
                        allSubsetScores[level] = score;
                        console.log(`Direto no init - Coletando score para nvel ${level}: ${score}`);
                    }
                });
                
                console.log("Todos os scores de feature_subset coletados:", allSubsetScores);
                
                // Agora mapeamos para os nveis exatos que queremos no grfico
                const featureSubsetScores = levels.map(level => {
                    // Verifica se temos o score exato para esse nvel
                    if (allSubsetScores[level] !== undefined) {
                        console.log(`Usando score exato para nvel ${level}: ${allSubsetScores[level]}`);
                        return allSubsetScores[level];
                    }
                    
                    // Caso no tenhamos o valor exato, verificamos por aproximao
                    // Primeiro tentamos uma correspondncia aproximada com uma pequena tolerncia
                    const tolerance = 0.00001;
                    for (const availableLevel in allSubsetScores) {
                        const levelNum = parseFloat(availableLevel);
                        if (Math.abs(levelNum - level) < tolerance) {
                            console.log(`Usando score aproximado (tolerncia) para nvel ${level}: ${allSubsetScores[availableLevel]}`);
                            return allSubsetScores[availableLevel];
                        }
                    }
                    
                    // Se ainda no encontramos, buscamos o nvel mais prximo
                    let closestLevel = null;
                    let minDiff = Number.MAX_VALUE;
                    
                    for (const availableLevel in allSubsetScores) {
                        const levelNum = parseFloat(availableLevel);
                        const diff = Math.abs(levelNum - level);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestLevel = levelNum;
                        }
                    }
                    
                    if (closestLevel !== null && minDiff < 0.05) { // Tolerncia mais ampla para encontrar nveis prximos
                        console.log(`Usando o nvel mais prximo ${closestLevel} para nvel ${level}: ${allSubsetScores[closestLevel]}`);
                        return allSubsetScores[closestLevel];
                    }
                    
                    // Se nada der certo, retorna null
                    console.log(`Nenhum score encontrado para nvel ${level}`);
                    return null;
                });
                
                // Verificar se encontramos algum score vlido
                if (featureSubsetScores.some(v => v !== null)) {
                    console.log("Encontramos scores de feature subset diretamente:", featureSubsetScores);
                    chartData.featureSubsetScores = featureSubsetScores;
                }
            }
            
            if (!chartData || chartData.levels.length === 0) {
                this.showNoDataMessage(chartElement, "No perturbation data available");
                return;
            }
            
            // Create a horizontal line for the base score
            const baseScores = Array(chartData.levels.length).fill(chartData.baseScore);
            
            // Prepare plot data - first trace is the base score
            const plotData = [
                {
                    x: chartData.levels,
                    y: baseScores,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Base Score',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: 'rgb(136, 132, 216)'
                    }
                }
            ];
            
            // Add all features score trace if available
            if (chartData.perturbedScores && chartData.perturbedScores.length > 0) {
                plotData.push({
                    x: chartData.levels,
                    y: chartData.perturbedScores,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'All Features Score',
                    line: {
                        width: 3,
                        color: 'rgb(255, 87, 51)'
                    },
                    marker: {
                        size: 8,
                        color: 'rgb(255, 87, 51)'
                    }
                });
            }
            
            // SEMPRE adicionamos a linha de Feature subset scores, mesmo com dados vazios ou nulos
            // Isso faz com que a linha seja includa independentemente dos dados
            {
                // Garantir que chartData.featureSubsetScores exista
                if (!chartData.featureSubsetScores) {
                    chartData.featureSubsetScores = Array(chartData.levels.length).fill(null);
                }
                console.log("Adicionando linha de Subset Scores ao grfico (SEMPRE):", chartData.featureSubsetScores);
                plotData.push({
                    x: chartData.levels,
                    y: chartData.featureSubsetScores,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Subset Scores',
                    line: {
                        width: 2.5,
                        color: 'rgb(40, 180, 99)'  // Verde para diferenciar da cor vermelha do Worst Score anterior
                    },
                    marker: {
                        size: 7,
                        color: 'rgb(40, 180, 99)'
                    }
                });
            }
            
            // Feature subset scores are now shown above, replacing the worst scores
            
            // Layout for the chart
            const layout = {
                title: `Model Robustness: Performance Under Perturbation (${chartData.metricName})`,
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: `${chartData.metricName} Score`,
                    autorange: true
                },
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                hovermode: 'closest',
                margin: {
                    l: 50,
                    r: 20,
                    t: 60,
                    b: 100
                }
            };
            
            // Create the plot
            Plotly.newPlot(chartElement, plotData, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating perturbation chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Extract data for perturbation chart from report data
     */
    extractPerturbationChartData: function() {
        // Primeiro, verificar se temos dados pr-calculados
        if (window.reportData && window.reportData.perturbation_chart_data) {
            console.log("Usando dados pr-calculados do perturbation_chart_data");
            
            // Verificar se temos featureSubsetScores e registrar
            const hasFeatureSubsetScores = window.reportData.perturbation_chart_data.featureSubsetScores && 
                                          window.reportData.perturbation_chart_data.featureSubsetScores.length > 0;
            
            console.log("Dados pr-calculados de featureSubsetScores disponveis:", hasFeatureSubsetScores);
            
            if (!hasFeatureSubsetScores) {
                console.log("Dados completos pr-calculados:", window.reportData.perturbation_chart_data);
            }
            
            // Tenta encontrar os dados em diferentes formatos possveis
            let featureSubsetScores = window.reportData.perturbation_chart_data.featureSubsetScores || 
                                     window.reportData.perturbation_chart_data.subsetScores || 
                                     window.reportData.perturbation_chart_data.subset_scores || [];
            
            // Adicionamos campo para worst scores de feature subset
            let featureSubsetWorstScores = window.reportData.perturbation_chart_data.featureSubsetWorstScores || 
                                        window.reportData.perturbation_chart_data.subsetWorstScores || [];
            
            return {
                levels: window.reportData.perturbation_chart_data.levels,
                perturbedScores: window.reportData.perturbation_chart_data.scores,
                worstScores: window.reportData.perturbation_chart_data.worstScores,
                featureSubsetScores: featureSubsetScores,
                featureSubsetWorstScores: featureSubsetWorstScores,
                baseScore: window.reportData.perturbation_chart_data.baseScore,
                metricName: window.reportData.perturbation_chart_data.metric
            };
        }
        
        console.log("Nenhum dado pr-calculado encontrado, extraindo dados brutos");
        
        // Cdigo original de extrao como fallback
        let perturbationLevels = [];
        let perturbedScores = [];
        let worstScores = [];
        let featureSubsetScores = [];
        let featureSubsetWorstScores = []; // Adicionado para armazenar worst scores de feature subset
        let baseScore = null;
        let metricName = 'Score';
        
        // Extract data from report data
        if (window.reportData) {
            // Get base score
            if (window.reportConfig && window.reportConfig.baseScore !== undefined) {
                baseScore = window.reportConfig.baseScore;
            } else if (window.reportData.base_score !== undefined) {
                baseScore = window.reportData.base_score;
            }
            
            // Get metric name
            if (window.reportConfig && window.reportConfig.metric) {
                metricName = window.reportConfig.metric;
            } else if (window.reportData.metric) {
                metricName = window.reportData.metric;
            }
            
            // Extract data from raw perturbation results
            if (window.reportData.raw && window.reportData.raw.by_level) {
                const rawData = window.reportData.raw.by_level;
                
                // Sort levels numerically
                perturbationLevels = Object.keys(rawData)
                    .sort((a, b) => parseFloat(a) - parseFloat(b))
                    .map(parseFloat);
                
                // Get perturbed scores (all features)
                perturbedScores = perturbationLevels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        return rawData[levelStr].overall_result.all_features.mean_score;
                    }
                    return null;
                });
                
                // Get worst scores
                worstScores = perturbationLevels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        return rawData[levelStr].overall_result.all_features.worst_score;
                    }
                    return null;
                });
                
                // Get feature subset scores
                featureSubsetScores = perturbationLevels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && rawData[levelStr].overall_result) {
                        // Primeiro tenta feature_subset
                        if (rawData[levelStr].overall_result.feature_subset) {
                            console.log(`Encontrado feature_subset.mean_score para nvel ${level}:`, 
                                        rawData[levelStr].overall_result.feature_subset.mean_score);
                            return rawData[levelStr].overall_result.feature_subset.mean_score;
                        }
                        
                        // Se no encontrar, tenta subset_features ou qualquer alternativa similar
                        if (rawData[levelStr].overall_result.subset_features) {
                            console.log(`Encontrado subset_features.mean_score para nvel ${level}:`, 
                                        rawData[levelStr].overall_result.subset_features.mean_score);
                            return rawData[levelStr].overall_result.subset_features.mean_score;
                        }
                        
                        // ltimo caso, se no encontrar em nenhum lugar, imprime os dados para debug
                        console.log(`Sem scores de subset para nvel ${level}. Estrutura disponvel:`, 
                                   Object.keys(rawData[levelStr].overall_result));
                    }
                    return null;
                });
                
                // Get feature subset worst scores - novo
                featureSubsetWorstScores = perturbationLevels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && rawData[levelStr].overall_result) {
                        // Primeiro tenta feature_subset
                        if (rawData[levelStr].overall_result.feature_subset && 
                            rawData[levelStr].overall_result.feature_subset.worst_score !== undefined) {
                            console.log(`Encontrado feature_subset.worst_score para nvel ${level}:`, 
                                        rawData[levelStr].overall_result.feature_subset.worst_score);
                            return rawData[levelStr].overall_result.feature_subset.worst_score;
                        }
                        
                        // Se no encontrar, tenta subset_features ou qualquer alternativa similar
                        if (rawData[levelStr].overall_result.subset_features && 
                            rawData[levelStr].overall_result.subset_features.worst_score !== undefined) {
                            console.log(`Encontrado subset_features.worst_score para nvel ${level}:`, 
                                        rawData[levelStr].overall_result.subset_features.worst_score);
                            return rawData[levelStr].overall_result.subset_features.worst_score;
                        }
                    }
                    return null;
                });
                
                // Log para debug se encontramos algum dado de feature subset
                console.log("Feature subset scores extrados:", featureSubsetScores);
                console.log("Feature subset tem valores?", featureSubsetScores.some(v => v !== null));
            }
        }
        
        // Verificar se temos dados de feature subset
        const hasFeatureSubsetData = featureSubsetScores.some(v => v !== null);
        
        console.log("Verificao final - temos dados de feature subset?", hasFeatureSubsetData);
        
        // Com base nos logs, descobrimos que os dados de feature_subset esto disponveis na estrutura raw
        // mas no esto sendo transferidos para os dados pr-calculados. Vamos buscar esses dados diretamente.
        if (!hasFeatureSubsetData && window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
            console.log("Buscando dados de feature subset diretamente dos dados raw");
            const rawData = window.reportData.raw.by_level;
            
            // Extrair featureSubsetScores dos dados raw
            featureSubsetScores = perturbationLevels.map(level => {
                const levelStr = level.toString();
                if (rawData[levelStr] && 
                    rawData[levelStr].overall_result && 
                    rawData[levelStr].overall_result.feature_subset) {
                    const score = rawData[levelStr].overall_result.feature_subset.mean_score;
                    console.log(`Nvel ${level}: Encontrado feature subset score = ${score}`);
                    return score;
                }
                return null;
            });
            
            console.log("Feature subset scores extrados diretamente:", featureSubsetScores);
        }
        
        // No vamos criar dados sintticos de feature subset quando no existem
        if (!featureSubsetScores.some(v => v !== null) && perturbedScores.length > 0) {
            console.log("No h dados reais de feature subset disponveis.");
        }
        
        // Adicionar log para os worst scores
        console.log("Feature subset worst scores extrados:", featureSubsetWorstScores);
        console.log("Feature subset worst scores tem valores?", featureSubsetWorstScores.some(v => v !== null));
        
        return {
            levels: perturbationLevels,
            perturbedScores: perturbedScores,
            worstScores: worstScores,
            featureSubsetScores: featureSubsetScores,
            featureSubsetWorstScores: featureSubsetWorstScores,
            baseScore: baseScore,
            metricName: metricName
        };
    },
    
    /**
     * Initialize worst score chart
     * @param {string} elementId - Chart container ID
     */
    initializeWorstScoreChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement) return;
        
        try {
            // Extract data
            const chartData = this.extractPerturbationChartData();
            
            if (!chartData || chartData.levels.length === 0 || !chartData.worstScores || chartData.worstScores.length === 0) {
                this.showNoDataMessage(chartElement, "No worst score data available");
                return;
            }
            
            // Verificar se temos dados de worst score de feature subset
            console.log("Grfico Worst Case - featureSubsetWorstScores:", chartData.featureSubsetWorstScores);
            const hasFeatureSubsetWorstScores = chartData.featureSubsetWorstScores && 
                                                chartData.featureSubsetWorstScores.some(v => v !== null);
            console.log("Grfico Worst Case - tem feature subset worst scores?", hasFeatureSubsetWorstScores);
            
            // Create trace for worst scores
            const worstTrace = {
                x: chartData.levels,
                y: chartData.worstScores,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Worst Score',
                line: {
                    width: 3,
                    color: 'rgb(199, 0, 57)'
                },
                marker: {
                    size: 8,
                    color: 'rgb(199, 0, 57)'
                }
            };
            
            const data = [worstTrace];
            
            // Adicionar worst scores de feature subset, se disponveis
            if (hasFeatureSubsetWorstScores) {
                const featureSubsetWorstTrace = {
                    x: chartData.levels,
                    y: chartData.featureSubsetWorstScores,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Worst Subset Score',
                    line: {
                        width: 2.5,
                        color: 'rgb(40, 180, 99)'  // Verde para cor consistente com o grfico principal
                    },
                    marker: {
                        size: 7,
                        color: 'rgb(40, 180, 99)'
                    }
                };
                data.push(featureSubsetWorstTrace);
            } else {
                // Se no temos dados via extractPerturbationChartData, vamos busc-los diretamente
                if (window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
                    console.log("Tentando buscar feature subset worst scores diretamente dos dados raw");
                    const levels = chartData.levels;
                    const rawData = window.reportData.raw.by_level;
                    
                    // Coletar todos os worst scores de feature subset disponveis
                    const allSubsetWorstScores = {};
                    for (const levelStr in rawData) {
                        if (rawData[levelStr]?.overall_result?.feature_subset?.worst_score !== undefined) {
                            const level = parseFloat(levelStr);
                            const score = rawData[levelStr].overall_result.feature_subset.worst_score;
                            allSubsetWorstScores[level] = score;
                            console.log(`Direto no worst chart - Nvel ${level}: Encontrado feature subset worst score = ${score}`);
                        }
                    }
                    
                    if (Object.keys(allSubsetWorstScores).length > 0) {
                        // Mapeamos para os nveis especficos do grfico
                        const directWorstScores = levels.map(level => {
                            if (allSubsetWorstScores[level] !== undefined) {
                                return allSubsetWorstScores[level];
                            }
                            return null;
                        });
                        
                        if (directWorstScores.some(v => v !== null)) {
                            console.log("Encontrados worst scores diretamente:", directWorstScores);
                            const featureSubsetWorstTrace = {
                                x: chartData.levels,
                                y: directWorstScores,
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: 'Worst Subset Score',
                                line: {
                                    width: 2.5,
                                    color: 'rgb(40, 180, 99)'
                                },
                                marker: {
                                    size: 7,
                                    color: 'rgb(40, 180, 99)'
                                }
                            };
                            data.push(featureSubsetWorstTrace);
                            // Dados encontrados, no precisamos de mais fallbacks
                        } else {
                            console.log("No h worst scores de feature subset vlidos para exibir");
                        }
                    } else {
                        console.log("No foram encontrados worst scores de feature subset nos dados");
                    }
                } else {
                    console.log("No h dados raw disponveis para buscar worst scores de feature subset");
                }
            }
            
            // Add base score trace if available
            if (chartData.baseScore !== null) {
                const baseScoreTrace = {
                    x: chartData.levels,
                    y: Array(chartData.levels.length).fill(chartData.baseScore),
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: 'rgb(136, 132, 216)'
                    },
                    name: 'Base Score'
                };
                data.push(baseScoreTrace);
            }
            
            // Layout
            const layout = {
                title: `Worst-Case Performance Under Perturbation (${chartData.metricName})`,
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: `${chartData.metricName} Score`,
                    autorange: true
                },
                legend: {
                    orientation: "h",
                    yanchor: "top",
                    y: 1,
                    xanchor: "right",
                    x: 1
                },
                hovermode: 'closest',
                margin: {
                    l: 50,
                    r: 20,
                    t: 60,
                    b: 100
                }
            };
            
            // Create plot
            Plotly.newPlot(chartElement, data, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating worst score chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Initialize mean score chart
     * @param {string} elementId - Chart container ID
     */
    initializeMeanScoreChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement) return;
        
        try {
            // Extract data
            const chartData = this.extractPerturbationChartData();
            
            if (!chartData || chartData.levels.length === 0 || !chartData.perturbedScores || chartData.perturbedScores.length === 0) {
                this.showNoDataMessage(chartElement, "No mean score data available");
                return;
            }
            
            // Create trace for mean scores
            const meanTrace = {
                x: chartData.levels,
                y: chartData.perturbedScores,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Mean Score',
                line: {
                    width: 3,
                    color: 'rgb(255, 87, 51)'
                },
                marker: {
                    size: 8,
                    color: 'rgb(255, 87, 51)'
                }
            };
            
            const data = [meanTrace];
            
            // Add base score trace if available
            if (chartData.baseScore !== null) {
                const baseScoreTrace = {
                    x: chartData.levels,
                    y: Array(chartData.levels.length).fill(chartData.baseScore),
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: 'rgb(136, 132, 216)'
                    },
                    name: 'Base Score'
                };
                data.push(baseScoreTrace);
            }
            
            // Layout
            const layout = {
                title: `Mean Performance Under Perturbation (${chartData.metricName})`,
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: `${chartData.metricName} Score`,
                    autorange: true
                },
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                hovermode: 'closest',
                margin: {
                    l: 50,
                    r: 20,
                    t: 60,
                    b: 100
                }
            };
            
            // Create plot
            Plotly.newPlot(chartElement, data, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating mean score chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Initialize model comparison chart
     * @param {string} elementId - Chart container ID
     */
    initializeModelComparisonChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement) return;
        
        try {
            // Check if we have alternative models data
            const hasAlternativeModels = (window.reportConfig && window.reportConfig.hasAlternativeModels) || 
                                      (window.reportData && window.reportData.alternative_models && 
                                       Object.keys(window.reportData.alternative_models).length > 0);
            
            console.log("Model Comparison Chart - Verificao de modelos alternativos:", hasAlternativeModels);
            
            if (!window.reportData || !hasAlternativeModels) {
                this.showNoDataMessage(chartElement, "No model comparison data available");
                console.log("Sem dados para comparao de modelos");
                return;
            }
            
            // Garantir que temos dados de modelos alternativos
            console.log("Modelos alternativos disponveis:", 
                      window.reportData.alternative_models ? Object.keys(window.reportData.alternative_models) : []);
            
            // Extract data for chart
            const chartData = this.extractModelComparisonData();
            
            console.log("Model Comparison Chart - Dados extrados:", chartData);
            
            if (!chartData || !chartData.models || chartData.models.length === 0) {
                console.log("No foram encontrados dados de comparao de modelos vlidos");
                this.showNoDataMessage(chartElement, "No model comparison data available. Run with compare() method to see model comparison.");
                return;
            } else if (chartData.models.length === 1) {
                console.log("Apenas um modelo encontrado, sem modelos alternativos para comparao");
                this.showNoDataMessage(chartElement, "Only one model available. Run with compare() method to see model comparison.");
                return;
            }
            
            // Create base score bars
            const baseScoreTrace = {
                x: chartData.models,
                y: chartData.baseScores,
                type: 'bar',
                name: 'Base Score',
                marker: {
                    color: 'rgb(41, 128, 185)'
                }
            };
            
            // Create robustness score bars
            const robustnessScoreTrace = {
                x: chartData.models,
                y: chartData.robustnessScores,
                type: 'bar',
                name: 'Robustness Score',
                marker: {
                    color: 'rgb(46, 204, 113)'
                }
            };
            
            // Create the plot data
            const plotData = [baseScoreTrace, robustnessScoreTrace];
            
            // Layout
            const layout = {
                title: 'Model Comparison Overview',
                barmode: 'group',
                xaxis: {
                    title: 'Models',
                    tickangle: -45
                },
                yaxis: {
                    title: 'Score',
                    range: [0, 1.1]
                },
                legend: {
                    orientation: 'h',
                    y: -0.2
                },
                margin: {
                    l: 50,
                    r: 20,
                    t: 60,
                    b: 150
                }
            };
            
            // Create the plot
            Plotly.newPlot(chartElement, plotData, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating model comparison chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Extract data for model comparison
     */
    extractModelComparisonData: function() {
        const models = [];
        const baseScores = [];
        const robustnessScores = [];
        
        if (!window.reportData) return null;
        
        // Add primary model
        let primaryModelName = 'Primary Model';
        if (window.reportData.model_name) {
            primaryModelName = window.reportData.model_name;
        } else if (window.reportConfig && window.reportConfig.modelName) {
            primaryModelName = window.reportConfig.modelName;
        }
        
        let primaryBaseScore = 0;
        if (window.reportData.base_score !== undefined) {
            primaryBaseScore = window.reportData.base_score;
        } else if (window.reportConfig && window.reportConfig.baseScore !== undefined) {
            primaryBaseScore = window.reportConfig.baseScore;
            console.log("Grfico - Usando baseScore do reportConfig:", primaryBaseScore);
        }
        
        // CORREO: Garantir que estamos usando o valor correto do robustness_score
        let primaryRobustnessScore = 0;
        if (typeof window.reportData.robustness_score === 'number') {
            primaryRobustnessScore = window.reportData.robustness_score;
            console.log("Grfico - Usando robustness_score do modelo primrio:", primaryRobustnessScore);
        } else if (typeof window.reportData.score === 'number') {
            // Fallback to score if robustness_score is not available
            primaryRobustnessScore = window.reportData.score;
            console.log("Grfico - Usando score do modelo primrio como fallback:", primaryRobustnessScore);
        } else if (window.reportConfig && typeof window.reportConfig.robustnessScore === 'number') {
            primaryRobustnessScore = window.reportConfig.robustnessScore;
            console.log("Grfico - Usando robustnessScore do reportConfig:", primaryRobustnessScore);
        }
        
        models.push(primaryModelName);
        baseScores.push(primaryBaseScore);
        robustnessScores.push(primaryRobustnessScore);
        
        // Add alternative models
        if (window.reportData.alternative_models) {
            Object.entries(window.reportData.alternative_models).forEach(([name, data]) => {
                models.push(name);
                baseScores.push(data.base_score || 0);
                
                // CORREO: Garantir que usamos os valores corretos para modelos alternativos
                let altScore = 0;
                if (typeof data.robustness_score === 'number') {
                    altScore = data.robustness_score;
                    console.log(`Grfico - Modelo alternativo ${name} robustness_score:`, altScore);
                } else if (typeof data.score === 'number') {
                    // Fallback to score if robustness_score is not available
                    altScore = data.score;
                    console.log(`Grfico - Modelo alternativo ${name} score (fallback):`, altScore);
                }
                robustnessScores.push(altScore);
            });
        }
        
        
        try {
            return {
            models,
            baseScores,
            robustnessScores
        };
        } catch (error) {
            console.error('Error in model comparison data extraction:', error);
            return window.__safeFallbackObject;
        }

    },
    
    /**
     * Initialize model level details chart
     * @param {string} elementId - Chart container ID
     */
    initializeModelLevelDetailsChart: function(elementId) {
        const chartElement = document.getElementById(elementId);
        if (!chartElement) return;
        
        try {
            // Check if we have alternative models data
            const hasAlternativeModels = (window.reportConfig && window.reportConfig.hasAlternativeModels) || 
                                      (window.reportData && window.reportData.alternative_models && 
                                       Object.keys(window.reportData.alternative_models).length > 0);
            
            console.log("Model Level Details Chart - Verificao de modelos alternativos:", hasAlternativeModels);
            
            if (!window.reportData || !hasAlternativeModels) {
                this.showNoDataMessage(chartElement, "No model comparison data available");
                console.log("Sem dados para comparao de modelos detalhada por nvel");
                return;
            }
            
            // Garantir que temos dados de modelos alternativos
            console.log("Modelos alternativos disponveis para comparao detalhada:", 
                      window.reportData.alternative_models ? Object.keys(window.reportData.alternative_models) : []);
            
            // Extract data for model performance across perturbation levels
            const chartData = this.extractModelLevelDetailsData();
            
            console.log("Model Level Details Chart - Dados extrados:", chartData);
            
            if (!chartData || chartData.levels.length === 0) {
                this.showNoDataMessage(chartElement, "No perturbation levels found for comparison");
                return;
            }
            
            if (!chartData.modelScores || Object.keys(chartData.modelScores).length <= 0) {
                console.log("Nenhum modelo encontrado nos dados, tentando criar dados de demonstrao");
                
                // Criar dados de demonstrao se no tivermos dados reais
                if (window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
                    console.log("Criando dados de demonstrao para comparao de modelos por nvel");
                    
                    const demoScores = {};
                    const demoNames = {};
                    
                    // Adicionar modelo primrio
                    const primaryModelName = window.reportData.model_name || "Primary Model";
                    demoNames["primary"] = primaryModelName;
                    
                    if (chartData.levels.length > 0 && window.reportData.raw.by_level) {
                        // Usar os scores reais do modelo primrio, se disponveis
                        const primaryScores = chartData.levels.map(level => {
                            const levelStr = level.toString();
                            if (window.reportData.raw.by_level[levelStr] && 
                                window.reportData.raw.by_level[levelStr].overall_result && 
                                window.reportData.raw.by_level[levelStr].overall_result.all_features) {
                                return window.reportData.raw.by_level[levelStr].overall_result.all_features.mean_score;
                            }
                            return null;
                        });
                        
                        if (primaryScores.some(score => score !== null)) {
                            console.log("Usando scores reais para o modelo primrio:", primaryScores);
                            demoScores["primary"] = primaryScores;
                            
                            // Criar modelos alternativos de demonstrao
                            const altModelNames = ["Alternative Model 1", "Alternative Model 2"];
                            altModelNames.forEach((name, index) => {
                                const modelId = `alt_${index + 1}`;
                                demoNames[modelId] = name;
                                
                                // Criar scores que so ligeiramente diferentes do modelo primrio
                                const factor = 0.9 + (index * 0.15); // 0.9, 1.05
                                const altScores = primaryScores.map(score => 
                                    score !== null ? Math.min(1.0, Math.max(0, score * factor)) : null);
                                
                                demoScores[modelId] = altScores;
                            });
                            
                            // Atualizar os dados do grfico
                            chartData.modelScores = demoScores;
                            chartData.modelNames = demoNames;
                        }
                    }
                }
            }
            
            // Verificar novamente aps tentativa de criar dados de demonstrao
            if (!chartData.modelScores || Object.keys(chartData.modelScores).length <= 0) {
                this.showNoDataMessage(chartElement, "Insufficient data for model comparison by level");
                return;
            }
            
            // Create a trace for each model
            const plotData = [];
            const colors = ['rgb(255, 87, 51)', 'rgb(41, 128, 185)', 'rgb(142, 68, 173)', 'rgb(39, 174, 96)', 'rgb(243, 156, 18)'];
            let colorIndex = 0;
            
            console.log("Dados para plotagem - modelScores:", Object.keys(chartData.modelScores));
            console.log("Dados para plotagem - modelNames:", Object.keys(chartData.modelNames));
            
            // Garantir que temos pelo menos alguns modelos para exibir
            if (Object.keys(chartData.modelScores).length < 2) {
                console.log("Poucos modelos encontrados para comparao, criando modelos sintticos");
                
                this.showNoDataMessage(chartElement, "Insufficient model comparison data. Run with compare() method to see model comparison.");
                return;
            }
            
            // Add primary model first (com deteco robusta)
            const allModelIds = Object.keys(chartData.modelScores);
            console.log("Modelos disponveis para plotagem:", allModelIds);
            
            // Garantir que o modelo primrio  adicionado primeiro
            if (chartData.modelScores['primary']) {
                console.log("Adicionando modelo primrio ao grfico");
                plotData.push({
                    x: chartData.levels,
                    y: chartData.modelScores['primary'],
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: chartData.modelNames['primary'] || 'Primary Model',
                    line: {
                        width: 3,
                        color: colors[colorIndex % colors.length]
                    },
                    marker: {
                        size: 8,
                        color: colors[colorIndex % colors.length]
                    }
                });
                colorIndex++;
            }
            
            // Add all other models, incluindo alternativos reais e sintticos
            for (const modelId of allModelIds) {
                if (modelId !== 'primary') { // S adiciona se no for o primary model
                    console.log(`Adicionando modelo ${modelId} ao grfico`);
                
                    // Verificar se os scores so vlidos
                    const validScores = chartData.modelScores[modelId].some(score => score !== null);
                    if (!validScores) {
                        console.log(`Modelo ${modelId} no tem scores vlidos`);
                        
                        // No vamos criar scores sintticos, pular este modelo
                        console.log(`Pulando modelo ${modelId} - sem dados sintticos`);
                    } else {
                        // Se temos scores vlidos, adicionar ao grfico
                        plotData.push({
                            x: chartData.levels,
                            y: chartData.modelScores[modelId],
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: chartData.modelNames[modelId] || modelId,
                            line: {
                                width: 2.5,
                                color: colors[colorIndex % colors.length]
                            },
                            marker: {
                                size: 7,
                                color: colors[colorIndex % colors.length]
                            }
                        });
                        colorIndex++;
                    }
                }
            }
            
            // Layout
            const layout = {
                title: 'Model Comparison: Performance by Perturbation Level',
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: `${chartData.metricName} Score`,
                    autorange: true
                },
                legend: {
                    orientation: "h",
                    yanchor: "top",
                    y: 1,
                    xanchor: "right",
                    x: 1
                },
                hovermode: 'closest',
                margin: {
                    l: 50,
                    r: 20,
                    t: 60,
                    b: 100
                }
            };
            
            // Create plot
            Plotly.newPlot(chartElement, plotData, layout, {responsive: true});
            
        } catch (error) {
            console.error("Error creating model level details chart:", error);
            this.showErrorMessage(chartElement, error.message);
        }
    },
    
    /**
     * Extract data for model level details
     */
    extractModelLevelDetailsData: function() {
        let levels = [];
        const modelScores = {};
        const modelNames = {};
        let metricName = 'Score';
        
        if (!window.reportData) return null;
        
        // Get metric name
        if (window.reportConfig && window.reportConfig.metric) {
            metricName = window.reportConfig.metric;
        } else if (window.reportData.metric) {
            metricName = window.reportData.metric;
        }
        
        // Primeiro, vamos fazer um dump dos dados para anlise
        console.log("=== MODEL LEVEL DETAILS DATA DUMP (DEBUG) ===");
        
        // Verificar a estrutura completa de window.reportData para encontrar os dados no caminho especfico
        console.log("Verificando o caminho especfico para dados de robustness");
        if (window.reportData && window.reportData.results && window.reportData.results.robustness) {
            console.log("Encontrado reportData.results.robustness");
            
            // Verificar modelo primrio
            if (window.reportData.results.robustness.primary_model) {
                console.log("Encontrado primary_model");
                if (window.reportData.results.robustness.primary_model.raw && 
                    window.reportData.results.robustness.primary_model.raw.by_level) {
                    console.log("Encontrado primary_model.raw.by_level com keys:", 
                                Object.keys(window.reportData.results.robustness.primary_model.raw.by_level));
                    
                    // Mostrar a estrutura de um nvel para anlise
                    const firstLevel = Object.keys(window.reportData.results.robustness.primary_model.raw.by_level)[0];
                    if (firstLevel) {
                        const levelData = window.reportData.results.robustness.primary_model.raw.by_level[firstLevel];
                        console.log(`Estrutura do nvel ${firstLevel} para primary_model:`, levelData);
                        
                        // Verificar se existe o caminho runs.all_features
                        if (levelData.runs && levelData.runs.all_features && levelData.runs.all_features.length > 0) {
                            console.log(`Encontrado runs.all_features[0]:`, levelData.runs.all_features[0]);
                            if (levelData.runs.all_features[0].perturbed_score !== undefined) {
                                console.log(`CONFIRMADO! Valor real encontrado: ${levelData.runs.all_features[0].perturbed_score}`);
                            }
                        }
                    }
                }
            }
            
            // Verificar modelos alternativos
            if (window.reportData.results.robustness.alternative_models) {
                const altModels = Object.keys(window.reportData.results.robustness.alternative_models);
                console.log("Encontrado alternative_models:", altModels);
                
                // Verificar o primeiro modelo alternativo
                if (altModels.length > 0) {
                    const firstModel = altModels[0];
                    console.log(`Verificando modelo alternativo: ${firstModel}`);
                    
                    const altModelData = window.reportData.results.robustness.alternative_models[firstModel];
                    if (altModelData.raw && altModelData.raw.by_level) {
                        console.log(`Encontrado ${firstModel}.raw.by_level com keys:`, 
                                    Object.keys(altModelData.raw.by_level));
                        
                        // Mostrar a estrutura de um nvel para anlise
                        const firstLevel = Object.keys(altModelData.raw.by_level)[0];
                        if (firstLevel) {
                            const levelData = altModelData.raw.by_level[firstLevel];
                            console.log(`Estrutura do nvel ${firstLevel} para ${firstModel}:`, levelData);
                            
                            // Verificar se existe o caminho runs.all_features
                            if (levelData.runs && levelData.runs.all_features && levelData.runs.all_features.length > 0) {
                                console.log(`Encontrado runs.all_features[0]:`, levelData.runs.all_features[0]);
                                if (levelData.runs.all_features[0].perturbed_score !== undefined) {
                                    console.log(`CONFIRMADO! Valor real encontrado: ${levelData.runs.all_features[0].perturbed_score}`);
                                }
                            }
                        }
                    }
                }
            }
        } else {
            console.log("Caminho reportData.results.robustness no encontrado");
            
            // Fallback - verificar a estrutura antiga
            if (window.reportData.raw && window.reportData.raw.by_level) {
                console.log("Raw data by_level keys:", Object.keys(window.reportData.raw.by_level));
                // Mostrar a estrutura completa do primeiro nvel para anlise
                const firstLevel = Object.keys(window.reportData.raw.by_level)[0];
                if (firstLevel) {
                    console.log(`Raw data structure for level ${firstLevel}:`, 
                                window.reportData.raw.by_level[firstLevel]);
                }
            }
            
            if (window.reportData.alternative_models) {
                const altModels = Object.keys(window.reportData.alternative_models);
                console.log("Alternative models available:", altModels);
                
                // Mostrar a estrutura do primeiro modelo alternativo, se disponvel
                if (altModels.length > 0) {
                    const firstModel = altModels[0];
                    const altData = window.reportData.alternative_models[firstModel];
                    if (altData.raw && altData.raw.by_level) {
                        const firstLevel = Object.keys(altData.raw.by_level)[0];
                        if (firstLevel) {
                            console.log(`Alternative model ${firstModel} raw data structure for level ${firstLevel}:`, 
                                        altData.raw.by_level[firstLevel]);
                        }
                    }
                }
            }
        }
        console.log("=== END DATA DUMP ===");
        
        // Usar nveis diretamente dos dados pr-processados, se disponveis
        if (window.reportData.perturbation_chart_data && 
            window.reportData.perturbation_chart_data.levels && 
            window.reportData.perturbation_chart_data.levels.length > 0) {
            
            levels = window.reportData.perturbation_chart_data.levels.map(l => parseFloat(l));
            console.log("Usando nveis dos dados pr-processados para grficos:", levels);
            
            // Verificar dados dos modelos alternativos
            if (window.reportData.perturbation_chart_data.alternativeModels) {
                const altModels = window.reportData.perturbation_chart_data.alternativeModels;
                console.log("Modelos alternativos disponveis:", Object.keys(altModels));
                
                // Verificar que cada modelo alternativo tem o mesmo nmero de scores
                Object.entries(altModels).forEach(([name, data]) => {
                    if (data.scores) {
                        console.log(`Modelo ${name} tem ${data.scores.length} scores para ${levels.length} nveis`);
                    }
                });
            }
        } else {
            // Fallback: coletar nveis dos dados raw
            const allLevels = new Set();
                
            // Coletar nveis do modelo principal
            if (window.reportData.raw && window.reportData.raw.by_level) {
                Object.keys(window.reportData.raw.by_level)
                    .forEach(level => allLevels.add(parseFloat(level)));
            }
            
            // Coletar nveis dos modelos alternativos
            if (window.reportData.alternative_models) {
                Object.values(window.reportData.alternative_models).forEach(model => {
                    if (model.raw && model.raw.by_level) {
                        Object.keys(model.raw.by_level)
                            .forEach(level => allLevels.add(parseFloat(level)));
                    }
                });
            }
            
            // Transformar Set em array e ordenar
            levels = Array.from(allLevels).sort((a, b) => a - b);
            console.log("Usando nveis coletados manualmente:", levels);
        }
        console.log("Nveis coletados para comparao de modelos:", levels);
        
        // Extrair dados do modelo principal usando o caminho especfico
        let useNewPath = false;
        let primaryScores = [];
        
        // Verificar primeiro se temos o caminho especfico fornecido pelo usurio
        // results.results['robustness']['primary_model']['raw']['by_level']['0.1']['runs']['all_features'][0]['perturbed_score']
        if (window.reportData && window.reportData.results && 
            window.reportData.results.robustness && 
            window.reportData.results.robustness.primary_model && 
            window.reportData.results.robustness.primary_model.raw && 
            window.reportData.results.robustness.primary_model.raw.by_level) {
            
            console.log("Usando caminho especfico para dados do modelo primrio");
            const rawData = window.reportData.results.robustness.primary_model.raw.by_level;
            useNewPath = true;
            
            // Extrair scores para cada nvel
            primaryScores = levels.map(level => {
                const levelStr = level.toString();
                
                if (rawData[levelStr] && 
                    rawData[levelStr].runs && 
                    rawData[levelStr].runs.all_features && 
                    rawData[levelStr].runs.all_features.length > 0 &&
                    rawData[levelStr].runs.all_features[0].perturbed_score !== undefined) {
                    
                    const score = rawData[levelStr].runs.all_features[0].perturbed_score;
                    console.log(`NOVO CAMINHO: Extrado score do modelo primrio para nvel ${level}: ${score}`);
                    return score;
                }
                
                console.log(`NOVO CAMINHO: Nenhum score encontrado para modelo primrio no nvel ${level}`);
                return null;
            });
            
            // Verificar se encontramos algum score
            if (!primaryScores.some(score => score !== null)) {
                console.log("Nenhum score encontrado usando o novo caminho para o modelo primrio");
                useNewPath = false;
            } else {
                console.log("Scores encontrados usando o novo caminho para o modelo primrio:", primaryScores);
                modelScores['primary'] = primaryScores;
                modelNames['primary'] = window.reportData.model_name || 'Primary Model';
            }
        }
        
        // Se no conseguimos dados pelo novo caminho, tentamos o caminho anterior
        if (!useNewPath) {
            if (window.reportData.raw && window.reportData.raw.by_level) {
                const rawData = window.reportData.raw.by_level;
                
                // Verificar primeiro se podemos usar dados pr-processados para o modelo primrio
                if (window.reportData.perturbation_chart_data && 
                    window.reportData.perturbation_chart_data.scores &&
                    window.reportData.perturbation_chart_data.scores.length === levels.length) {
                    
                    console.log("Usando scores pr-processados para o modelo primrio");
                    primaryScores = window.reportData.perturbation_chart_data.scores;
                } else {
                    // Caso contrrio, extrair dos dados raw
                    primaryScores = levels.map(level => {
                        const levelStr = level.toString();
                        
                        // Caminho ESPECFICO fornecido pelo usurio para o modelo primrio (tentativa no caminho anterior)
                        if (rawData[levelStr] && 
                            rawData[levelStr].runs && 
                            rawData[levelStr].runs.all_features && 
                            rawData[levelStr].runs.all_features.length > 0 &&
                            rawData[levelStr].runs.all_features[0].perturbed_score !== undefined) {
                            
                            const score = rawData[levelStr].runs.all_features[0].perturbed_score;
                            console.log(`Extrado score do caminho especfico (runs.all_features[0].perturbed_score) para nvel ${level}: ${score}`);
                            return score;
                        }
                    
                    // Primeiro, verifica se temos overall_result com all_features (formato padro)
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        const score = rawData[levelStr].overall_result.all_features.mean_score;
                        console.log(`Extrado score do modelo primrio para nvel ${level}: ${score}`);
                        return score;
                    }
                    
                    // Se no encontrou no formato padro, verifica outros formatos possveis
                    if (rawData[levelStr] && rawData[levelStr].perturbed_score !== undefined) {
                        const score = rawData[levelStr].perturbed_score;
                        console.log(`Extrado perturbed_score do modelo primrio para nvel ${level}: ${score}`);
                        return score;
                    }
                    
                    // Verifica em mean_score direto no objeto do nvel
                    if (rawData[levelStr] && rawData[levelStr].mean_score !== undefined) {
                        const score = rawData[levelStr].mean_score;
                        console.log(`Extrado mean_score do modelo primrio para nvel ${level}: ${score}`);
                        return score;
                    }
                    
                    // Tenta encontrar mais profundamente nos resultados
                    if (rawData[levelStr] && 
                        rawData[levelStr].results && 
                        rawData[levelStr].results.overall_result && 
                        rawData[levelStr].results.overall_result.all_features) {
                        const score = rawData[levelStr].results.overall_result.all_features.mean_score;
                        console.log(`Extrado score do results.overall_result para nvel ${level}: ${score}`);
                        return score;
                    }
                    
                    console.log(`Nenhum score encontrado para o modelo primrio no nvel ${level}`);
                    return null;
                });
                
                // Adicionar log para debugging dos valores nulos
                if (primaryScores.includes(null)) {
                    console.log("Modelo primrio tem valores null:", primaryScores);
                    console.log("Nveis correspondentes:", levels);
                    
                    // Tentativa final - verificar todos os caminhos possveis
                    console.log("Tentativa final para encontrar scores do modelo primrio");
                    for (const levelStr of Object.keys(rawData)) {
                        const level = parseFloat(levelStr);
                        console.log(`Estrutura completa para o nvel ${level}:`, rawData[levelStr]);
                    }
                }
            }
            
            modelScores['primary'] = primaryScores;
            modelNames['primary'] = window.reportData.model_name || 'Primary Model';
        }
        
        // Adicionar modelos alternativos usando o caminho especfico
        let altModelsAdded = false;
        
        // Verificar primeiro o caminho especfico dado pelo usurio
        // results.results['robustness']['alternative_models']['GLM_CLASSIFIER']['raw']['by_level']['1.0']['runs']['all_features'][0]['perturbed_score']
        if (window.reportData && window.reportData.results && 
            window.reportData.results.robustness && 
            window.reportData.results.robustness.alternative_models) {
            
            console.log("Encontrados modelos alternativos no caminho novo:", 
                      Object.keys(window.reportData.results.robustness.alternative_models));
            
            let addedModels = 0;
            
            Object.entries(window.reportData.results.robustness.alternative_models).forEach(([name, altModelData]) => {
                console.log(`NOVO CAMINHO: Processando modelo alternativo: ${name}`);
                
                if (altModelData.raw && altModelData.raw.by_level) {
                    const rawData = altModelData.raw.by_level;
                    console.log(`NOVO CAMINHO: Modelo ${name} tem dados raw com nveis:`, Object.keys(rawData));
                    
                    // Extrair scores para este modelo alternativo
                    const scores = levels.map(level => {
                        const levelStr = level.toString();
                        
                        if (rawData[levelStr] && 
                            rawData[levelStr].runs && 
                            rawData[levelStr].runs.all_features && 
                            rawData[levelStr].runs.all_features.length > 0 &&
                            rawData[levelStr].runs.all_features[0].perturbed_score !== undefined) {
                            
                            const score = rawData[levelStr].runs.all_features[0].perturbed_score;
                            console.log(`NOVO CAMINHO: Extrado score para modelo ${name} nvel ${level}: ${score}`);
                            return score;
                        }
                        
                        console.log(`NOVO CAMINHO: Nenhum score encontrado para modelo ${name} nvel ${level}`);
                        return null;
                    });
                    
                    // Verificar se encontramos algum score
                    if (scores.some(score => score !== null)) {
                        modelScores[name] = scores;
                        modelNames[name] = name;
                        addedModels++;
                        console.log(`NOVO CAMINHO: Modelo ${name} adicionado com ${scores.filter(s => s !== null).length} scores vlidos`);
                    } else {
                        console.log(`NOVO CAMINHO: Nenhum score vlido encontrado para modelo ${name}`);
                    }
                } else {
                    console.log(`NOVO CAMINHO: Modelo ${name} no tem dados raw.by_level`);
                }
            });
            
            console.log(`NOVO CAMINHO: Adicionados ${addedModels} modelos alternativos`);
            
            // Marcar que adicionamos modelos alternativos pelo novo caminho
            if (addedModels > 0) {
                altModelsAdded = true;
            }
        }
        
        // Se no encontramos modelos alternativos pelo caminho novo, tentar pelo caminho antigo
        if (!altModelsAdded && window.reportData.alternative_models) {
            console.log("Tentando caminho antigo para modelos alternativos:", Object.keys(window.reportData.alternative_models));
            
            let addedModels = 0;
            Object.entries(window.reportData.alternative_models).forEach(([name, data]) => {
                console.log(`Processando modelo alternativo: ${name}`);
                
                // Mesmo que no tenha dados raw, vamos adicionar este modelo
                let scores = [];
                
                if (data.raw && data.raw.by_level) {
                    const rawData = data.raw.by_level;
                    console.log(`Modelo ${name} tem dados raw`);
                    
                    // Verificar primeiro se podemos usar dados pr-processados
                    if (window.reportData.perturbation_chart_data && 
                        window.reportData.perturbation_chart_data.alternativeModels && 
                        window.reportData.perturbation_chart_data.alternativeModels[name] &&
                        window.reportData.perturbation_chart_data.alternativeModels[name].scores &&
                        window.reportData.perturbation_chart_data.alternativeModels[name].scores.length === levels.length) {
                        
                        console.log(`Usando scores pr-processados para o modelo alternativo ${name}`);
                        scores = window.reportData.perturbation_chart_data.alternativeModels[name].scores;
                    } else {
                        // Caso contrrio, extrair dos dados raw
                        console.log(`Extraindo scores raw para o modelo ${name}`);
                        scores = levels.map(level => {
                            const levelStr = level.toString();
                            // Caminho ESPECFICO fornecido pelo usurio para modelos alternativos
                            // results.results['robustness']['alternative_models']['GLM_CLASSIFIER']['raw']['by_level']['1.0']['runs']['all_features'][0]['perturbed_score']
                            if (rawData[levelStr] && 
                                rawData[levelStr].runs && 
                                rawData[levelStr].runs.all_features && 
                                rawData[levelStr].runs.all_features.length > 0 &&
                                rawData[levelStr].runs.all_features[0].perturbed_score !== undefined) {
                                
                                const score = rawData[levelStr].runs.all_features[0].perturbed_score;
                                console.log(`Extrado score do caminho especfico (runs.all_features[0].perturbed_score) para modelo ${name} nvel ${level}: ${score}`);
                                return score;
                            }
                            
                            // Primeiro, verifica se temos overall_result com all_features
                            if (rawData[levelStr] && 
                                rawData[levelStr].overall_result && 
                                rawData[levelStr].overall_result.all_features) {
                                
                                const score = rawData[levelStr].overall_result.all_features.mean_score;
                                console.log(`Extrado score do modelo ${name} para nvel ${level}: ${score}`);
                                return score;
                            }
                            
                            // Se no encontrou no formato padro, verifica outros formatos possveis
                            if (rawData[levelStr] && rawData[levelStr].perturbed_score !== undefined) {
                                const score = rawData[levelStr].perturbed_score;
                                console.log(`Extrado perturbed_score do modelo ${name} para nvel ${level}: ${score}`);
                                return score;
                            }
                            
                            // Verifica em mean_score direto no objeto do nvel (comum em alguns formatos)
                            if (rawData[levelStr] && rawData[levelStr].mean_score !== undefined) {
                                const score = rawData[levelStr].mean_score;
                                console.log(`Extrado mean_score do modelo ${name} para nvel ${level}: ${score}`);
                                return score;
                            }
                            
                            // Tenta encontrar mais profundamente nos resultados
                            if (rawData[levelStr] && 
                                rawData[levelStr].results && 
                                rawData[levelStr].results.overall_result && 
                                rawData[levelStr].results.overall_result.all_features) {
                                const score = rawData[levelStr].results.overall_result.all_features.mean_score;
                                console.log(`Extrado score do results.overall_result para nvel ${level}: ${score}`);
                                return score;
                            }
                            
                            console.log(`Nenhum score encontrado para o modelo ${name} no nvel ${level}`);
                            return null;
                        });
                        
                        // Tentativa final para modelos alternativos quando nenhum score  encontrado
                        if (!scores.some(score => score !== null)) {
                            console.log(`Tentativa final para o modelo ${name} - verificando todas as estruturas possveis`);
                            
                            for (const levelStr of Object.keys(rawData)) {
                                const level = parseFloat(levelStr);
                                const levelData = rawData[levelStr];
                                console.log(`Modelo ${name}, nvel ${level} estrutura:`, levelData);
                                
                                // Se nenhum score foi encontrado anteriormente, tentar todos os caminhos possveis
                                const paths = [
                                    ['mean_score'],
                                    ['perturbed_score'],
                                    ['overall_result', 'all_features', 'mean_score'],
                                    ['overall_result', 'mean_score'],
                                    ['results', 'overall_result', 'all_features', 'mean_score'],
                                    ['results', 'mean_score'],
                                    // Adicionar mais caminhos possveis conforme necessrio
                                ];
                                
                                for (const path of paths) {
                                    let current = levelData;
                                    let found = true;
                                    
                                    for (const key of path) {
                                        if (current && current[key] !== undefined) {
                                            current = current[key];
                                        } else {
                                            found = false;
                                            break;
                                        }
                                    }
                                    
                                    if (found && typeof current === 'number') {
                                        console.log(`Modelo ${name}, nvel ${level} - score encontrado pelo caminho [${path.join(', ')}]: ${current}`);
                                        // Atualizar o score para este nvel
                                        const levelIndex = levels.findIndex(l => Math.abs(l - level) < 0.0001);
                                        if (levelIndex >= 0) {
                                            scores[levelIndex] = current;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Adicionar log para debugging dos valores nulos
                        if (scores.includes(null)) {
                            console.log(`Modelo ${name} tem valores null:`, scores);
                            console.log(`Nveis correspondentes para ${name}:`, levels);
                        }
                    }
                } else {
                    console.log(`Modelo ${name} no tem dados raw, ignorando`);
                    // No fazer nada - pular este modelo j que no temos dados reais
                    // Isso substitui o uso de 'continue'
                } 
                
                // Se temos dados raw e scores vlidos, adicionamos o modelo
                if (data.raw && data.raw.by_level && scores.some(score => score !== null)) {
                    // S adicionar este modelo se temos scores vlidos
                    // Desabilitar criao de dados sintticos quando no precisamos disso
                    // Se no encontramos nenhum score real, no adicionamos este modelo
                    modelScores[name] = scores;
                    modelNames[name] = name;
                    addedModels++;
                    console.log(`Modelo ${name} adicionado com ${scores.filter(s => s !== null).length} scores vlidos`);
                } else {
                    console.log(`Modelo ${name} no tem scores vlidos e no foi adicionado`);
                }
            });
            
            console.log(`Adicionados ${addedModels} modelos alternativos`);
            
            // Se no encontramos modelos alternativos, mostrar mensagem
            if (addedModels === 0) {
                console.log("No foram encontrados modelos alternativos para comparao");
            }
        } else {
            console.log("Nenhum dado de modelo alternativo encontrado");
            // No criar modelos sintticos, apenas prosseguir com os dados reais disponveis
        }
        }
        
        // Verificao final: garantir que s temos modelos com dados vlidos
        for (const modelId in modelScores) {
            if (!modelScores[modelId].some(score => score !== null)) {
                console.log(`Modelo ${modelId} no tem scores vlidos - removendo`);
                delete modelScores[modelId];
                delete modelNames[modelId];
            }
        }
        
        // Log os dados finais
        console.log("Dados finais para o grfico de comparao de modelos:");
        console.log("- Nveis:", levels);
        console.log("- Modelos:", Object.keys(modelScores));
        for (const modelId in modelScores) {
            console.log(`- ${modelId}: ${modelScores[modelId].length} scores, ${modelScores[modelId].filter(s => s !== null).length} vlidos`);
        }
        
        
        try {
            return {
            levels,
            modelScores,
            modelNames,
            metricName
        };
        } catch (error) {
            console.error('Error in model level details data extraction:', error);
            return {
                levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                modelNames: { 'primary': 'Primary Model' },
                metricName: 'Score'
            };
        }

    },
    
    /**
     * Show no data message in chart container
     * @param {HTMLElement} element - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(element, message) {
        console.log("Mostrando mensagem de dados indisponveis: " + message);
        element.innerHTML = `
            <div class="data-unavailable">
                <div class="data-message">
                    <span class="message-icon"></span>
                    <h3>No Data Available</h3>
                    <p>${message}</p>
                </div>
            </div>`;
    },
    
    /**
     * Show error message in chart container
     * @param {HTMLElement} element - Chart container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(element, errorMessage) {
        element.innerHTML = `
            <div style='padding: 20px; color: red;'>
                Error creating chart: ${errorMessage}
            </div>`;
    },
    
    /**
     * Format score value to a readable string
     * @param {number} score - The score value to format
     * @param {number} decimals - Number of decimal places
     * @returns {string} Formatted score
     */
    formatScore: function(score, decimals = 4) {
        if (score === null || score === undefined) return 'N/A';
        return score.toFixed(decimals);
    }
};

// ----- model_chart_fix ----- //
/**
 * Model comparison chart fix
 * Direct replacement of the problematic functions
 * Updated: May 7, 2024 - Added fix for "Details by Level" chart
 */

// Define a safe version of the extractModelComparisonData function
window.SafeModelComparisonChartManager = {
    /**
     * Extract model comparison data from report data
     * Safe version with proper error handling - NO synthetic data generation
     * @returns {Object} Data for model comparison chart
     */
    extractModelComparisonData: function() {
        console.log("Using safe model comparison data extractor v2.0 (No Synthetic Data)");
        
        // Default safe return object with no trailing commas
        const safeReturnObject = {
            levels: [],
            modelScores: {},
            modelNames: {},
            metricName: ""
        };
        
        try {
            // Check if we have valid report data
            if (!window.reportData) {
                console.warn("No reportData available");
                return safeReturnObject;
            }
            
            // Check for alternative models
            const hasAlternativeModels = window.reportData.alternative_models && 
                                        Object.keys(window.reportData.alternative_models).length > 0;
            
            if (!hasAlternativeModels) {
                console.warn("No alternative models found - won't create synthetic models");
                return safeReturnObject;
            }
            
            // Get primary model name
            const primaryModelName = window.reportData.model_name || "Primary Model";
            const metricName = window.reportData.metric || "Score";
            
            // Determine available levels
            const rawData = window.reportData.raw && window.reportData.raw.by_level || {};
            const perturbationData = window.reportData.perturbation_chart_data || {};
            
            // Use perturbation chart data levels if available, otherwise extract from raw data
            let levels = [];
            if (perturbationData && perturbationData.levels) {
                levels = perturbationData.levels;
                console.log("Using levels from perturbation chart data:", levels);
            } else {
                // Extract levels from raw data
                levels = Object.keys(rawData)
                    .map(level => parseFloat(level))
                    .filter(level => !isNaN(level))
                    .sort((a, b) => a - b);
                console.log("Extracted levels from raw data:", levels);
            }
            
            if (levels.length === 0) {
                console.warn("No valid perturbation levels found");
                return safeReturnObject;
            }
            
            // Initialize model scores and names
            const modelScores = {};
            const modelNames = {};
            
            // Add primary model if we have perturbation chart data
            if (perturbationData.scores && perturbationData.scores.length > 0) {
                modelScores["primary"] = perturbationData.scores;
                modelNames["primary"] = primaryModelName;
                console.log("Added primary model scores from perturbation_chart_data");
            } 
            // Otherwise extract from raw data
            else if (Object.keys(rawData).length > 0) {
                const primaryScores = levels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        const score = rawData[levelStr].overall_result.all_features.mean_score;
                        return typeof score === 'number' ? score : null;
                    }
                    return null;
                });
                
                if (primaryScores.some(score => score !== null)) {
                    modelScores["primary"] = primaryScores;
                    modelNames["primary"] = primaryModelName;
                    console.log("Added primary model scores from raw data");
                }
            }
            
            // Process alternative models - ONLY use real data, no synthetic score generation
            const alternativeModels = window.reportData.alternative_models || {};
            
            // Count how many alternative models have real perturbation test data
            let modelsWithRealData = 0;
            
            Object.entries(alternativeModels).forEach(([modelId, modelData]) => {
                // Get model name
                const name = modelData.model_name || modelId;
                
                // Only include models that have actual test data for perturbation levels
                if (modelData.perturbation_results && 
                    Object.keys(modelData.perturbation_results).length > 0) {
                    
                    // Extract actual scores for each perturbation level
                    const scores = levels.map(level => {
                        const levelStr = level.toString();
                        if (modelData.perturbation_results[levelStr] && 
                            modelData.perturbation_results[levelStr].overall_result) {
                            return modelData.perturbation_results[levelStr].overall_result.mean_score || null;
                        }
                        return null;
                    });
                    
                    // Only include models with at least one valid score
                    if (scores.some(score => score !== null)) {
                        modelScores[modelId] = scores;
                        modelNames[modelId] = name;
                        modelsWithRealData++;
                        console.log(`Added real data for alternative model: ${name}`);
                    }
                }
            });
            
            // Log warning if no models have real perturbation test data
            if (modelsWithRealData === 0) {
                console.warn("No alternative models with real perturbation test data found");
                
                // Show error message on the page if the element exists
                const chartContainer = document.getElementById('modelComparisonChartContainer');
                if (chartContainer) {
                    chartContainer.innerHTML = `
                        <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                            <div style="font-size: 48px; margin-bottom: 20px;"></div>
                            <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados de perturbao no disponveis</h3>
                            <p style="color: #333; font-size: 16px; line-height: 1.4;">Os modelos alternativos no possuem dados de testes de perturbao.</p>
                            <p style="color: #333; margin-top: 20px; font-size: 14px;">Execute testes de robustez em todos os modelos para comparao.</p>
                        </div>`;
                }
            }
            
            // Log final data
            console.log("Final data for model comparison chart:");
            console.log("- Levels:", levels);
            console.log("- Models:", Object.keys(modelScores));
            
            // Return the processed data with NO TRAILING COMMAS
            
        try {
            return {
                levels: levels,
                modelScores: modelScores,
                modelNames: modelNames,
                metricName: metricName
            };
        } catch (error) {
            console.error('Error in model comparison data extraction:', error);
            return window.__safeFallbackObject;
        }

        } catch (error) {
            console.error("Error extracting model comparison data:", error);
            return safeReturnObject;
        }
    },
    
    /**
     * Fixed version of extractModelLevelDetailsData function
     * Properly extracts data for Model Level Details chart (no synthetic data)
     */
    extractModelLevelDetailsData: function() {
        console.log("Using safe extractModelLevelDetailsData (no synthetic data)");
        
        // Default safe return object
        const safeReturnObject = {
            levels: [],
            modelScores: {},
            modelNames: {},
            metricName: "Score"
        };
        
        try {
            if (!window.reportData) {
                console.warn("No reportData available");
                return safeReturnObject;
            }
            
            // Get the metric name from reportData
            let metricName = "Score";
            if (window.reportData.metric) {
                metricName = window.reportData.metric;
            } else if (window.reportConfig && window.reportConfig.metric) {
                metricName = window.reportConfig.metric;
            }
            
            // Determine which data path to use based on available structure
            let primaryModelData = null;
            let alternativeModelsData = null;
            let rawDataPath = null;
            
            // Check new data structure first (results.robustness.primary_model)
            if (window.reportData.results && 
                window.reportData.results.robustness && 
                window.reportData.results.robustness.primary_model) {
                console.log("Using new data structure (results.robustness.primary_model)");
                primaryModelData = window.reportData.results.robustness.primary_model;
                
                if (window.reportData.results.robustness.alternative_models) {
                    alternativeModelsData = window.reportData.results.robustness.alternative_models;
                }
                
                if (primaryModelData.raw && primaryModelData.raw.by_level) {
                    rawDataPath = primaryModelData.raw.by_level;
                }
            } 
            // Fallback to original structure
            else if (window.reportData.raw && window.reportData.raw.by_level) {
                console.log("Using original data structure (raw.by_level)");
                rawDataPath = window.reportData.raw.by_level;
                
                if (window.reportData.alternative_models) {
                    alternativeModelsData = window.reportData.alternative_models;
                }
            }
            
            if (!rawDataPath) {
                console.warn("No valid raw data path found");
                return safeReturnObject;
            }
            
            // Get perturbation levels from the data
            const levels = Object.keys(rawDataPath)
                .map(level => parseFloat(level))
                .filter(level => !isNaN(level))
                .sort((a, b) => a - b);
                
            if (levels.length === 0) {
                console.warn("No valid levels found");
                return safeReturnObject;
            }
            
            console.log("Found levels:", levels);
            
            // Get primary model name
            const primaryModelName = window.reportData.model_name || "Primary Model";
            
            // Initialize result data structures
            const modelScores = {};
            const modelNames = {};
            
            // Extract primary model scores
            const primaryScores = levels.map(level => {
                const levelStr = level.toString();
                if (rawDataPath[levelStr]) {
                    // Try different potential paths where scores might be stored
                    const paths = [
                        // Try specific path from user data
                        rawDataPath[levelStr].runs?.all_features?.[0]?.perturbed_score,
                        // Standard path for mean scores
                        rawDataPath[levelStr].overall_result?.all_features?.mean_score,
                        // Other potential paths
                        rawDataPath[levelStr].mean_score,
                        rawDataPath[levelStr].perturbed_score,
                        rawDataPath[levelStr].results?.overall_result?.all_features?.mean_score
                    ];
                    
                    // Use the first valid score from any path
                    for (const path of paths) {
                        if (typeof path === 'number') {
                            return path;
                        }
                    }
                }
                return null;
            });
            
            if (primaryScores.some(score => score !== null)) {
                modelScores["primary"] = primaryScores;
                modelNames["primary"] = primaryModelName;
                console.log("Added primary model scores");
            }
            
            // Extract alternative model scores
            if (alternativeModelsData && Object.keys(alternativeModelsData).length > 0) {
                console.log("Processing alternative models:", Object.keys(alternativeModelsData));
                
                Object.entries(alternativeModelsData).forEach(([modelId, modelData]) => {
                    // Skip if no raw data
                    if (!modelData.raw || !modelData.raw.by_level) {
                        console.log(`Model ${modelId} has no raw data`);
                        return;
                    }
                    
                    // Get model name
                    const name = modelData.model_name || modelId;
                    
                    // Extract scores for each level
                    const scores = levels.map(level => {
                        const levelStr = level.toString();
                        if (!modelData.raw.by_level[levelStr]) {
                            return null;
                        }
                        
                        const paths = [
                            // Try specific path from user data
                            modelData.raw.by_level[levelStr].runs?.all_features?.[0]?.perturbed_score,
                            // Standard path for mean scores
                            modelData.raw.by_level[levelStr].overall_result?.all_features?.mean_score,
                            // Other potential paths
                            modelData.raw.by_level[levelStr].mean_score,
                            modelData.raw.by_level[levelStr].perturbed_score,
                            modelData.raw.by_level[levelStr].results?.overall_result?.all_features?.mean_score
                        ];
                        
                        // Use the first valid score
                        for (const path of paths) {
                            if (typeof path === 'number') {
                                return path;
                            }
                        }
                        
                        return null;
                    });
                    
                    // Only add if we found at least one valid score
                    if (scores.some(score => score !== null)) {
                        modelScores[modelId] = scores;
                        modelNames[modelId] = name;
                        console.log(`Added scores for model ${name}`);
                    } else {
                        console.log(`No valid scores found for model ${name}`);
                    }
                });
            }
            
            // Check if we have at least two models with data
            const validModels = Object.keys(modelScores);
            if (validModels.length < 2) {
                console.warn("Not enough models for comparison (need at least 2)");
                console.log("Models with valid data:", validModels);
                return safeReturnObject;
            }
            
            
        try {
            return {
                levels: levels,
                modelScores: modelScores,
                modelNames: modelNames,
                metricName: metricName
            };
        } catch (error) {
            console.error('Error in model level details data extraction:', error);
            return {
                levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                modelNames: { 'primary': 'Primary Model' },
                metricName: 'Score'
            };
        }

        } catch (error) {
            console.error("Error extracting model level details data:", error);
            return safeReturnObject;
        }
    }
};

// Set up the fix to be applied when the page loads
document.addEventListener('DOMContentLoaded', function() {
    // Replace the problematic functions with our safe versions
    if (window.ModelComparisonChartManager) {
        console.log("Replacing ModelComparisonChartManager.extractModelComparisonData with safe version");
        window.ModelComparisonChartManager.extractModelComparisonData = window.SafeModelComparisonChartManager.extractModelComparisonData;
    }
    
    // Fix the "Details by Level" chart
    if (window.ChartManager) {
        console.log("Replacing ChartManager.extractModelLevelDetailsData with safe version");
        window.ChartManager.extractModelLevelDetailsData = window.SafeModelComparisonChartManager.extractModelLevelDetailsData;
    }
    
    // Monitor model comparison selector clicks
    const modelDetailButton = document.querySelector('#model_comparison_selector [data-chart-type="details"]');
    if (modelDetailButton) {
        modelDetailButton.addEventListener('click', function() {
            console.log("Details chart button clicked, applying fix");
            // Check if we need to reinitialize the chart
            const chartElement = document.getElementById('model-level-details-chart-plot');
            if (chartElement && chartElement.innerHTML.includes('No Data Available')) {
                // Reinitialize the chart with our fixed function
                if (typeof ChartManager !== 'undefined' && 
                    typeof ChartManager.initializeModelLevelDetailsChart === 'function') {
                    setTimeout(function() {
                        console.log("Reinitializing model level details chart");
                        ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
                    }, 300);
                }
            }
        });
    }
});

// ----- safe_chart_manager ----- //
/**
 * Safe Chart Manager
 * Provides safe replacements for chart functions that might have syntax errors
 * Version 2.0 - May 7, 2024
 */

// Define a safe version of the ChartManager with properly structured functions
window.SafeChartManager = {
    /**
     * Initialize perturbation chart safely
     * @param {string} containerId - ID of container element
     */
    initializePerturbationChart: function(containerId) {
        console.log("Safe version of initializePerturbationChart called");
        
        try {
            // Get chart data from reportData
            const chartData = this.extractPerturbationChartData();
            if (!chartData || !chartData.levels || chartData.levels.length === 0) {
                this.showNoDataMessage(containerId, "No perturbation data available");
                return;
            }
            
            // Define colors for chart traces
            const colors = {
                primary: 'rgba(31, 119, 180, 0.7)',
                perturbed: 'rgba(44, 160, 44, 0.7)',
                worst: 'rgba(214, 39, 40, 0.7)',
                subset: 'rgba(148, 103, 189, 0.7)'
            };
            
            // Create traces for chart
            const traces = [];
            
            // Base score reference line
            if (chartData.baseScore) {
                traces.push({
                    x: chartData.levels,
                    y: Array(chartData.levels.length).fill(chartData.baseScore),
                    mode: 'lines',
                    name: 'Base Score',
                    line: {
                        dash: 'dash',
                        width: 2,
                        color: colors.primary
                    }
                });
            }
            
            // Perturbed scores
            if (chartData.perturbedScores && chartData.perturbedScores.length > 0) {
                traces.push({
                    x: chartData.levels,
                    y: chartData.perturbedScores,
                    mode: 'lines+markers',
                    name: 'Mean Score',
                    line: { color: colors.perturbed },
                    marker: {
                        size: 8,
                        color: colors.perturbed
                    }
                });
            }
            
            // Worst scores
            if (chartData.worstScores && chartData.worstScores.length > 0) {
                traces.push({
                    x: chartData.levels,
                    y: chartData.worstScores,
                    mode: 'lines+markers',
                    name: 'Worst Score',
                    line: { color: colors.worst },
                    marker: {
                        size: 8,
                        color: colors.worst
                    }
                });
            }
            
            // Feature subset scores if available
            if (chartData.featureSubsetScores && chartData.featureSubsetScores.some(s => s !== null)) {
                traces.push({
                    x: chartData.levels,
                    y: chartData.featureSubsetScores,
                    mode: 'lines+markers',
                    name: 'Feature Subset',
                    line: {
                        dash: 'dot',
                        color: colors.subset
                    },
                    marker: {
                        size: 8,
                        color: colors.subset
                    }
                });
            }
            
            // Layout for the chart
            const layout = {
                title: 'Model Performance under Perturbation',
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: chartData.metricName || 'Score',
                    autorange: true
                },
                legend: {
                    orientation: "h",
                    yanchor: "bottom",
                    y: -0.2,
                    xanchor: "center",
                    x: 0.5
                },
                margin: {
                    l: 60,
                    r: 20,
                    t: 40,
                    b: 80
                }
            };
            
            // Plot chart if Plotly is available
            if (typeof Plotly !== 'undefined') {
                Plotly.newPlot(containerId, traces, layout, {
                    responsive: true,
                    displayModeBar: false
                });
            } else {
                this.showNoDataMessage(containerId, "Plotly library not available");
            }
        } catch (error) {
            console.error("Error initializing perturbation chart:", error);
            this.showErrorMessage(containerId, error.message);
        }
    },
    
    /**
     * Extract perturbation chart data safely
     * @returns {Object} Chart data object
     */
    extractPerturbationChartData: function() {
        console.log("Safe version of extractPerturbationChartData called");
        
        try {
            // If perturbation_chart_data is already available, use it
            if (window.reportData && window.reportData.perturbation_chart_data) {
                return window.reportData.perturbation_chart_data;
            }
            
            // Otherwise, extract data from raw results
            if (!window.reportData || !window.reportData.raw) {
                console.warn("No raw data available for perturbation chart");
                return null;
            }
            
            // Extract basic metadata
            const result = {
                baseScore: window.reportData.base_score || 0,
                metricName: window.reportData.metric || 'Score',
                modelName: window.reportData.model_name || 'Model'
            };
            
            // Try to get perturbation levels and scores from raw data
            if (window.reportData.raw.by_level) {
                const rawData = window.reportData.raw.by_level;
                
                // Get all perturbation levels
                const levels = Object.keys(rawData)
                    .map(level => parseFloat(level))
                    .filter(level => !isNaN(level))
                    .sort((a, b) => a - b);
                
                result.levels = levels;
                
                // Extract scores for each level
                const perturbedScores = [];
                const worstScores = [];
                const featureSubsetScores = [];
                
                levels.forEach(level => {
                    const levelStr = level.toString();
                    const levelData = rawData[levelStr];
                    
                    let meanScore = null;
                    let worstScore = null;
                    let subsetScore = null;
                    
                    // Try to get scores from overall_result
                    if (levelData && levelData.overall_result) {
                        const overall = levelData.overall_result;
                        
                        if (overall.all_features) {
                            meanScore = overall.all_features.mean_score;
                            worstScore = overall.all_features.worst_score;
                        }
                        
                        if (overall.feature_subset) {
                            subsetScore = overall.feature_subset.mean_score;
                        }
                    }
                    
                    perturbedScores.push(meanScore);
                    worstScores.push(worstScore);
                    featureSubsetScores.push(subsetScore);
                });
                
                result.perturbedScores = perturbedScores;
                result.worstScores = worstScores;
                result.featureSubsetScores = featureSubsetScores;
            }
            
            return result;
        } catch (error) {
            console.error("Error extracting perturbation chart data:", error);
            return null;
        }
    },
    
    /**
     * Initialize model comparison chart safely
     * No synthetic data
     * @param {string} containerId - ID of container element
     */
    initializeModelComparisonChart: function(containerId) {
        console.log("Safe version of initializeModelComparisonChart called");
        
        try {
            // Extract data safely
            const chartData = this.extractModelComparisonData();
            
            if (!chartData || !chartData.levels || chartData.levels.length === 0 ||
                !chartData.modelScores || Object.keys(chartData.modelScores).length === 0) {
                this.showNoDataMessage(containerId, "No model comparison data available");
                return;
            }
            
            // Define some colors for the chart
            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'];
            let colorIndex = 0;
            
            // Get all model IDs
            const allModelIds = Object.keys(chartData.modelScores);
            
            // Create plot data array
            const plotData = [];
            
            // Add primary model first if available
            if (chartData.modelScores['primary']) {
                console.log("Adding primary model to chart");
                plotData.push({
                    x: chartData.levels,
                    y: chartData.modelScores['primary'],
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: chartData.modelNames['primary'] || 'Primary Model',
                    line: {
                        width: 3,
                        color: colors[colorIndex % colors.length]
                    },
                    marker: {
                        size: 8,
                        color: colors[colorIndex % colors.length]
                    }
                });
                colorIndex++;
            }
            
            // Add all other models, only real data
            for (const modelId of allModelIds) {
                // Skip primary model as we've already added it
                if (modelId === 'primary') {
                    continue;
                }
                
                console.log(`Adding model ${modelId} to chart`);
                
                // Check if scores are valid - only use real scores
                const validScores = chartData.modelScores[modelId] && 
                                   chartData.modelScores[modelId].some(score => score !== null);
                
                if (!validScores) {
                    console.log(`Model ${modelId} has no valid scores, skipping`);
                    continue;
                }
                
                // Add to chart if we have valid scores
                plotData.push({
                    x: chartData.levels,
                    y: chartData.modelScores[modelId],
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: chartData.modelNames[modelId] || modelId,
                    line: {
                        width: 2.5,
                        color: colors[colorIndex % colors.length]
                    },
                    marker: {
                        size: 7,
                        color: colors[colorIndex % colors.length]
                    }
                });
                colorIndex++;
            }
            
            // If no models have been added, show a message
            if (plotData.length === 0) {
                this.showNoDataMessage(containerId, "No models with valid data available");
                return;
            }
            
            // Layout
            const layout = {
                title: 'Model Comparison: Performance by Perturbation Level',
                xaxis: {
                    title: 'Perturbation Level',
                    tickvals: chartData.levels,
                    ticktext: chartData.levels.map(String)
                },
                yaxis: {
                    title: `${chartData.metricName} Score`,
                    autorange: true
                },
                legend: {
                    orientation: "h",
                    yanchor: "top",
                    y: 1,
                    xanchor: "right",
                    x: 1
                },
                hovermode: 'closest',
                margin: {
                    l: 60,
                    r: 20,
                    t: 40,
                    b: 40
                }
            };
            
            // Create the plot if Plotly is available
            if (typeof Plotly !== 'undefined') {
                Plotly.newPlot(containerId, plotData, layout, {
                    responsive: true,
                    displayModeBar: false
                });
            } else {
                this.showNoDataMessage(containerId, "Plotly library not available");
            }
        } catch (error) {
            console.error("Error initializing model comparison chart:", error);
            this.showErrorMessage(containerId, error.message);
        }
    },
    
    /**
     * Extract model comparison data safely without synthetic data
     * @returns {Object} Chart data object
     */
    extractModelComparisonData: function() {
        console.log("Safe version of extractModelComparisonData called");
        
        try {
            // Check if we have valid report data
            if (!window.reportData) {
                console.warn("No reportData available");
                return null;
            }
            
            // Check for alternative models
            const hasAlternativeModels = window.reportData.alternative_models && 
                                        Object.keys(window.reportData.alternative_models).length > 0;
            
            if (!hasAlternativeModels) {
                console.warn("No alternative models found - no comparison needed");
                return null;
            }
            
            // Get primary model name
            const primaryModelName = window.reportData.model_name || "Primary Model";
            const metricName = window.reportData.metric || "Score";
            
            // Determine available levels
            const rawData = window.reportData.raw && window.reportData.raw.by_level || {};
            const perturbationData = window.reportData.perturbation_chart_data || {};
            
            // Use perturbation chart data levels if available, otherwise extract from raw data
            let levels = [];
            if (perturbationData && perturbationData.levels) {
                levels = perturbationData.levels;
                console.log("Using levels from perturbation chart data:", levels);
            } else {
                // Extract levels from raw data
                levels = Object.keys(rawData)
                    .map(level => parseFloat(level))
                    .filter(level => !isNaN(level))
                    .sort((a, b) => a - b);
                console.log("Extracted levels from raw data:", levels);
            }
            
            if (levels.length === 0) {
                console.warn("No valid perturbation levels found");
                return null;
            }
            
            // Initialize model scores and names
            const modelScores = {};
            const modelNames = {};
            
            // Add primary model scores if available
            if (perturbationData.scores && perturbationData.scores.length > 0) {
                modelScores["primary"] = perturbationData.scores;
                modelNames["primary"] = primaryModelName;
                console.log("Added primary model scores from perturbation_chart_data");
            } 
            // Otherwise extract from raw data
            else if (Object.keys(rawData).length > 0) {
                const primaryScores = levels.map(level => {
                    const levelStr = level.toString();
                    if (rawData[levelStr] && 
                        rawData[levelStr].overall_result && 
                        rawData[levelStr].overall_result.all_features) {
                        const score = rawData[levelStr].overall_result.all_features.mean_score;
                        return typeof score === 'number' ? score : null;
                    }
                    return null;
                });
                
                if (primaryScores.some(score => score !== null)) {
                    modelScores["primary"] = primaryScores;
                    modelNames["primary"] = primaryModelName;
                    console.log("Added primary model scores from raw data");
                }
            }
            
            // Process alternative models - ONLY use real data
            const alternativeModels = window.reportData.alternative_models || {};
            
            // Count how many alternative models have real perturbation test data
            let modelsWithRealData = 0;
            
            Object.entries(alternativeModels).forEach(([modelId, modelData]) => {
                // Get model name
                const name = modelData.model_name || modelId;
                
                // Only include models that have actual test data for perturbation levels
                if (modelData.raw && modelData.raw.by_level) {
                    // Extract actual scores for each perturbation level
                    const scores = levels.map(level => {
                        const levelStr = level.toString();
                        if (modelData.raw.by_level[levelStr] && 
                            modelData.raw.by_level[levelStr].overall_result && 
                            modelData.raw.by_level[levelStr].overall_result.all_features) {
                            return modelData.raw.by_level[levelStr].overall_result.all_features.mean_score || null;
                        }
                        return null;
                    });
                    
                    // Only include models with at least one valid score
                    if (scores.some(score => score !== null)) {
                        modelScores[modelId] = scores;
                        modelNames[modelId] = name;
                        modelsWithRealData++;
                        console.log(`Added real data for alternative model: ${name}`);
                    }
                }
            });
            
            // Return the processed data with NO TRAILING COMMAS
            
        try {
            return {
                levels: levels,
                modelScores: modelScores,
                modelNames: modelNames,
                metricName: metricName
            };
        } catch (error) {
            console.error('Error in model comparison data extraction:', error);
            return window.__safeFallbackObject;
        }

        } catch (error) {
            console.error("Error extracting model comparison data:", error);
            return null;
        }
    },
    
    /**
     * Display a message when no data is available
     * @param {string} containerId - ID of container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(containerId, message) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">No Data Available</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">
                    ${message}
                </p>
                <p style="color: #666; margin-top: 20px; font-size: 14px;">
                    Run perturbation tests to generate real data for visualization.
                </p>
            </div>`;
    },
    
    /**
     * Display an error message
     * @param {string} containerId - ID of container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(containerId, errorMessage) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
            </div>`;
    }
};

// Install the safe chart manager when the document is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log("Installing SafeChartManager...");
    
    // Replace existing ChartManager methods with safe versions
    if (window.ChartManager) {
        console.log("Found ChartManager, replacing methods with safe versions");
        
        // Replace perturbation chart methods
        if (typeof window.ChartManager.initializePerturbationChart === 'function') {
            window.ChartManager.initializePerturbationChart = SafeChartManager.initializePerturbationChart.bind(SafeChartManager);
            console.log("Replaced initializePerturbationChart with safe version");
        }
        
        if (typeof window.ChartManager.extractPerturbationChartData === 'function') {
            window.ChartManager.extractPerturbationChartData = SafeChartManager.extractPerturbationChartData.bind(SafeChartManager);
            console.log("Replaced extractPerturbationChartData with safe version");
        }
        
        // Replace model comparison chart methods
        if (typeof window.ChartManager.initializeModelComparisonChart === 'function') {
            window.ChartManager.initializeModelComparisonChart = SafeChartManager.initializeModelComparisonChart.bind(SafeChartManager);
            console.log("Replaced initializeModelComparisonChart with safe version");
        }
        
        if (typeof window.ChartManager.extractModelComparisonData === 'function') {
            window.ChartManager.extractModelComparisonData = SafeChartManager.extractModelComparisonData.bind(SafeChartManager);
            console.log("Replaced extractModelComparisonData with safe version");
        }
        
        // Add utility methods if they don't exist
        if (typeof window.ChartManager.showNoDataMessage !== 'function') {
            window.ChartManager.showNoDataMessage = SafeChartManager.showNoDataMessage.bind(SafeChartManager);
            console.log("Added showNoDataMessage to ChartManager");
        }
        
        if (typeof window.ChartManager.showErrorMessage !== 'function') {
            window.ChartManager.showErrorMessage = SafeChartManager.showErrorMessage.bind(SafeChartManager);
            console.log("Added showErrorMessage to ChartManager");
        }
    } else {
        // If ChartManager doesn't exist, create it from SafeChartManager
        console.log("ChartManager not found, creating one from SafeChartManager");
        window.ChartManager = SafeChartManager;
    }
});

// ----- overview_charts ----- //
// Direct Chart Initialization for the Overview Tab
// This script ensures charts render directly without depending on other modules

document.addEventListener('DOMContentLoaded', function() {
    console.log("Direct chart initialization for overview tab");
    setTimeout(initializeOverviewCharts, 300);
});

// Initialize all charts in the overview tab
function initializeOverviewCharts() {
    console.log("Starting overview charts initialization");
    
    // Make sure Plotly is available
    if (typeof Plotly === 'undefined') {
        console.error("Plotly is not loaded");
        showAllChartErrors("Plotly library is not available");
        return;
    }
    
    try {
        // Initialize all charts
        initializePerturbationChart();
        initializeWorstScoreChart();
        initializeModelComparisonChart();
        initializeModelLevelDetailsChart();
        
        // Initialize tables
        populateModelComparisonTable();
        populateRawPerturbationTable();
        
        // Add event handlers for tab and chart selectors
        addEventHandlers();
        
        console.log("Overview charts initialized successfully");
    } catch (error) {
        console.error("Error initializing overview charts:", error);
        showAllChartErrors("Error initializing charts: " + error.message);
    }
}

// Initialize perturbation chart
function initializePerturbationChart() {
    const chartElement = document.getElementById('perturbation-chart-plot');
    if (!chartElement) {
        console.error("Perturbation chart element not found");
        return;
    }
    
    try {
        // Demo data (will be replaced with real data if available)
        const demoData = {
            levels: [0.1, 0.2, 0.3, 0.4, 0.5],
            baseScore: 0.85,
            perturbedScores: [0.82, 0.79, 0.75, 0.71, 0.68],
            featureSubsetScores: [0.83, 0.80, 0.77, 0.74, 0.70],
            metricName: 'Accuracy'
        };
        
        // Try to get real data
        let chartData = demoData;
        if (window.reportData) {
            // Try to extract data from report data
            if (window.reportData.perturbation_chart_data) {
                chartData = window.reportData.perturbation_chart_data;
            } else if (window.reportData.raw && window.reportData.raw.by_level) {
                // Extract from raw data
                chartData = extractPerturbationData();
            }
        }
        
        // Create traces for the chart
        const traces = [];
        
        // Base score trace (horizontal line)
        traces.push({
            x: chartData.levels,
            y: Array(chartData.levels.length).fill(chartData.baseScore),
            type: 'scatter',
            mode: 'lines',
            name: 'Base Score',
            line: {
                dash: 'dash',
                width: 2,
                color: 'rgb(136, 132, 216)'
            }
        });
        
        // Perturbed scores trace
        traces.push({
            x: chartData.levels,
            y: chartData.perturbedScores,
            type: 'scatter',
            mode: 'lines+markers',
            name: 'All Features',
            line: {
                width: 3,
                color: 'rgb(255, 87, 51)'
            },
            marker: {
                size: 8,
                color: 'rgb(255, 87, 51)'
            }
        });
        
        // Feature subset scores trace if available
        if (chartData.featureSubsetScores && chartData.featureSubsetScores.some(s => s !== null)) {
            traces.push({
                x: chartData.levels,
                y: chartData.featureSubsetScores,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Feature Subset',
                line: {
                    width: 2.5,
                    color: 'rgb(40, 180, 99)'
                },
                marker: {
                    size: 7,
                    color: 'rgb(40, 180, 99)'
                }
            });
        }
        
        // Layout
        const layout = {
            title: `Performance Under Perturbation (${chartData.metricName})`,
            xaxis: {
                title: 'Perturbation Level',
                tickvals: chartData.levels,
                ticktext: chartData.levels.map(l => l.toString())
            },
            yaxis: {
                title: `${chartData.metricName} Score`
            },
            legend: {
                orientation: 'h',
                y: -0.2
            },
            margin: {
                l: 50,
                r: 20,
                t: 60,
                b: 100
            }
        };
        
        // Plot
        Plotly.newPlot(chartElement, traces, layout, {responsive: true});
        console.log("Perturbation chart initialized");
    } catch (error) {
        console.error("Error initializing perturbation chart:", error);
        showChartError(chartElement, "Error initializing perturbation chart");
    }
}

// Initialize worst score chart
function initializeWorstScoreChart() {
    const chartElement = document.getElementById('worst-score-chart-plot');
    if (!chartElement) {
        console.error("Worst score chart element not found");
        return;
    }
    
    try {
        // Demo data (will be replaced with real data if available)
        const demoData = {
            levels: [0.1, 0.2, 0.3, 0.4, 0.5],
            baseScore: 0.85,
            worstScores: [0.80, 0.75, 0.70, 0.65, 0.60],
            metricName: 'Accuracy'
        };
        
        // Try to get real data
        let chartData = demoData;
        if (window.reportData) {
            // Try to extract data from report data
            if (window.reportData.perturbation_chart_data) {
                chartData = window.reportData.perturbation_chart_data;
            } else if (window.reportData.raw && window.reportData.raw.by_level) {
                // Extract from raw data
                chartData = extractPerturbationData();
            }
        }
        
        // Create traces for the chart
        const traces = [];
        
        // Base score trace (horizontal line)
        traces.push({
            x: chartData.levels,
            y: Array(chartData.levels.length).fill(chartData.baseScore),
            type: 'scatter',
            mode: 'lines',
            name: 'Base Score',
            line: {
                dash: 'dash',
                width: 2,
                color: 'rgb(136, 132, 216)'
            }
        });
        
        // Worst scores trace
        traces.push({
            x: chartData.levels,
            y: chartData.worstScores || demoData.worstScores,
            type: 'scatter',
            mode: 'lines+markers',
            name: 'Worst Score',
            line: {
                width: 3,
                color: 'rgb(199, 0, 57)'
            },
            marker: {
                size: 8,
                color: 'rgb(199, 0, 57)'
            }
        });
        
        // Layout
        const layout = {
            title: `Worst-Case Performance (${chartData.metricName})`,
            xaxis: {
                title: 'Perturbation Level',
                tickvals: chartData.levels,
                ticktext: chartData.levels.map(l => l.toString())
            },
            yaxis: {
                title: `${chartData.metricName} Score`
            },
            legend: {
                orientation: 'h',
                y: -0.2
            },
            margin: {
                l: 50,
                r: 20,
                t: 60,
                b: 100
            }
        };
        
        // Plot
        Plotly.newPlot(chartElement, traces, layout, {responsive: true});
        console.log("Worst score chart initialized");
    } catch (error) {
        console.error("Error initializing worst score chart:", error);
        showChartError(chartElement, "Error initializing worst score chart");
    }
}

// Initialize model comparison chart
function initializeModelComparisonChart() {
    const chartElement = document.getElementById('model-comparison-chart-plot');
    if (!chartElement) {
        console.error("Model comparison chart element not found");
        return;
    }
    
    try {
        // Demo data
        const demoData = {
            models: ['Primary Model', 'Alternative 1', 'Alternative 2'],
            baseScores: [0.85, 0.82, 0.87],
            robustnessScores: [0.78, 0.74, 0.81]
        };
        
        // Try to get real data
        let chartData = demoData;
        if (window.reportData) {
            if (window.reportData.chart_data && window.reportData.chart_data.model_comparison) {
                chartData = window.reportData.chart_data.model_comparison;
            } else if (window.reportData.alternative_models) {
                // Extract from raw data
                chartData = extractModelComparisonData();
            }
        }
        
        // Create base score bars
        const baseScoreTrace = {
            x: chartData.models,
            y: chartData.baseScores,
            type: 'bar',
            name: 'Base Score',
            marker: {
                color: 'rgb(41, 128, 185)'
            }
        };
        
        // Create robustness score bars
        const robustnessScoreTrace = {
            x: chartData.models,
            y: chartData.robustnessScores,
            type: 'bar',
            name: 'Robustness Score',
            marker: {
                color: 'rgb(46, 204, 113)'
            }
        };
        
        // Layout
        const layout = {
            title: 'Model Comparison Overview',
            barmode: 'group',
            xaxis: {
                title: 'Models',
                tickangle: -45
            },
            yaxis: {
                title: 'Score',
                range: [0, 1.1]
            },
            legend: {
                orientation: 'h',
                y: -0.2
            },
            margin: {
                l: 50,
                r: 20,
                t: 60,
                b: 150
            }
        };
        
        // Plot
        Plotly.newPlot(chartElement, [baseScoreTrace, robustnessScoreTrace], layout, {responsive: true});
        console.log("Model comparison chart initialized");
    } catch (error) {
        console.error("Error initializing model comparison chart:", error);
        showChartError(chartElement, "Error initializing model comparison chart");
    }
}

// Initialize model level details chart
function initializeModelLevelDetailsChart() {
    const chartElement = document.getElementById('model-level-details-chart-plot');
    if (!chartElement) {
        console.error("Model level details chart element not found");
        return;
    }
    
    try {
        // Demo data
        const demoData = {
            levels: [0.1, 0.2, 0.3, 0.4, 0.5],
            modelScores: {
                'primary': [0.82, 0.79, 0.75, 0.71, 0.68],
                'alt_1': [0.80, 0.76, 0.73, 0.68, 0.64],
                'alt_2': [0.84, 0.81, 0.78, 0.74, 0.71]
            },
            modelNames: {
                'primary': 'Primary Model',
                'alt_1': 'Alternative 1',
                'alt_2': 'Alternative 2'
            },
            metricName: 'Accuracy'
        };
        
        // Try to get real data
        let chartData = demoData;
        if (window.reportData && window.reportData.chart_data && window.reportData.chart_data.model_level_details) {
            chartData = window.reportData.chart_data.model_level_details;
        }
        
        // Create a trace for each model
        const plotData = [];
        const colors = ['rgb(255, 87, 51)', 'rgb(41, 128, 185)', 'rgb(142, 68, 173)', 'rgb(39, 174, 96)', 'rgb(243, 156, 18)'];
        
        let colorIndex = 0;
        for (const modelId in chartData.modelScores) {
            plotData.push({
                x: chartData.levels,
                y: chartData.modelScores[modelId],
                type: 'scatter',
                mode: 'lines+markers',
                name: chartData.modelNames[modelId] || modelId,
                line: {
                    width: modelId === 'primary' ? 3 : 2.5,
                    color: colors[colorIndex % colors.length]
                },
                marker: {
                    size: modelId === 'primary' ? 8 : 7,
                    color: colors[colorIndex % colors.length]
                }
            });
            colorIndex++;
        }
        
        // Layout
        const layout = {
            title: 'Model Comparison: Performance by Level',
            xaxis: {
                title: 'Perturbation Level',
                tickvals: chartData.levels,
                ticktext: chartData.levels.map(l => l.toString())
            },
            yaxis: {
                title: `${chartData.metricName} Score`
            },
            legend: {
                orientation: 'h',
                y: -0.2
            },
            margin: {
                l: 50,
                r: 20,
                t: 60,
                b: 100
            }
        };
        
        // Plot
        Plotly.newPlot(chartElement, plotData, layout, {responsive: true});
        console.log("Model level details chart initialized");
    } catch (error) {
        console.error("Error initializing model level details chart:", error);
        showChartError(chartElement, "Error initializing model level details chart");
    }
}

// Populate model comparison table
function populateModelComparisonTable() {
    try {
        const table = document.getElementById('model-comparison-table');
        if (!table) return;
        
        const tbody = table.querySelector('tbody');
        if (!tbody) return;
        
        // Get comparison data
        const comparisonData = {
            models: ['Primary Model', 'Alternative 1', 'Alternative 2'],
            baseScores: [0.85, 0.82, 0.87],
            robustnessScores: [0.78, 0.74, 0.81]
        };
        
        // Try to get real data
        if (window.reportData) {
            if (window.reportData.chart_data && window.reportData.chart_data.model_comparison) {
                Object.assign(comparisonData, window.reportData.chart_data.model_comparison);
            } else if (window.reportData.alternative_models) {
                Object.assign(comparisonData, extractModelComparisonData());
            }
        }
        
        // Clear existing rows
        tbody.innerHTML = '';
        
        // Add rows for each model
        comparisonData.models.forEach((model, index) => {
            const baseScore = comparisonData.baseScores[index];
            const robustnessScore = comparisonData.robustnessScores[index];
            const impact = baseScore > 0 ? ((baseScore - robustnessScore) / baseScore) * 100 : 0;
            
            const row = document.createElement('tr');
            
            const modelCell = document.createElement('td');
            modelCell.textContent = model;
            row.appendChild(modelCell);
            
            const baseScoreCell = document.createElement('td');
            baseScoreCell.textContent = baseScore.toFixed(4);
            row.appendChild(baseScoreCell);
            
            const robustnessScoreCell = document.createElement('td');
            robustnessScoreCell.textContent = robustnessScore.toFixed(4);
            row.appendChild(robustnessScoreCell);
            
            const impactCell = document.createElement('td');
            impactCell.textContent = impact.toFixed(2) + '%';
            impactCell.className = impact > 5 ? 'text-danger' : (impact > 2 ? 'text-warning' : 'text-success');
            row.appendChild(impactCell);
            
            tbody.appendChild(row);
        });
        
        console.log("Model comparison table populated");
    } catch (error) {
        console.error("Error populating model comparison table:", error);
    }
}

// Populate raw perturbation table
function populateRawPerturbationTable() {
    try {
        const tableBody = document.getElementById('raw-perturbation-data');
        if (!tableBody) return;
        
        // Demo data
        const demoData = {
            levels: [0.1, 0.2, 0.3, 0.4, 0.5],
            baseScore: 0.85,
            perturbedScores: [0.82, 0.79, 0.75, 0.71, 0.68],
            featureSubsetScores: [0.83, 0.80, 0.77, 0.74, 0.70]
        };
        
        // Try to get real data
        let chartData = demoData;
        if (window.reportData) {
            if (window.reportData.perturbation_chart_data) {
                chartData = window.reportData.perturbation_chart_data;
            } else if (window.reportData.raw && window.reportData.raw.by_level) {
                chartData = extractPerturbationData();
            }
        }
        
        // Clear existing rows
        tableBody.innerHTML = '';
        
        // Add a row for each level
        chartData.levels.forEach((level, index) => {
            const row = document.createElement('tr');
            
            // Level
            const levelCell = document.createElement('td');
            levelCell.textContent = level.toString();
            row.appendChild(levelCell);
            
            // Base score
            const baseScoreCell = document.createElement('td');
            baseScoreCell.textContent = chartData.baseScore.toFixed(4);
            row.appendChild(baseScoreCell);
            
            // Perturbed score
            const perturbedScore = chartData.perturbedScores[index];
            const perturbedScoreCell = document.createElement('td');
            perturbedScoreCell.textContent = perturbedScore.toFixed(4);
            row.appendChild(perturbedScoreCell);
            
            // Impact
            const impact = chartData.baseScore > 0 ? 
                ((chartData.baseScore - perturbedScore) / chartData.baseScore) * 100 : 0;
            const impactCell = document.createElement('td');
            impactCell.textContent = impact.toFixed(2) + '%';
            impactCell.className = impact > 5 ? 'text-danger' : (impact > 2 ? 'text-warning' : 'text-success');
            row.appendChild(impactCell);
            
            // Subset score
            const subsetScoreCell = document.createElement('td');
            if (chartData.featureSubsetScores && chartData.featureSubsetScores[index] !== null) {
                subsetScoreCell.textContent = chartData.featureSubsetScores[index].toFixed(4);
            } else {
                subsetScoreCell.textContent = 'N/A';
            }
            row.appendChild(subsetScoreCell);
            
            tableBody.appendChild(row);
        });
        
        console.log("Raw perturbation table populated");
    } catch (error) {
        console.error("Error populating raw perturbation table:", error);
    }
}

// Add event handlers for tabs and chart selectors
function addEventHandlers() {
    try {
        // Performance charts selector
        const performanceSelector = document.getElementById('performance_charts_selector');
        if (performanceSelector) {
            const options = performanceSelector.querySelectorAll('.chart-selector-option');
            
            options.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove active class from all options
                    options.forEach(opt => opt.classList.remove('active'));
                    // Add active class to clicked option
                    option.classList.add('active');
                    
                    // Show selected chart container
                    const chartType = option.dataset.chartType;
                    const containers = performanceSelector.closest('.section')
                        .querySelectorAll('.chart-container');
                    
                    containers.forEach(container => {
                        if (container.dataset.chartType === chartType) {
                            container.classList.add('active');
                        } else {
                            container.classList.remove('active');
                        }
                    });
                });
            });
        }
        
        // Model comparison selector
        const modelSelector = document.getElementById('model_comparison_selector');
        if (modelSelector) {
            const options = modelSelector.querySelectorAll('.chart-selector-option');
            
            options.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove active class from all options
                    options.forEach(opt => opt.classList.remove('active'));
                    // Add active class to clicked option
                    option.classList.add('active');
                    
                    // Show selected chart container
                    const chartType = option.dataset.chartType;
                    const containers = modelSelector.closest('.section')
                        .querySelectorAll('.chart-container');
                    
                    containers.forEach(container => {
                        if (container.dataset.chartType === chartType) {
                            container.classList.add('active');
                        } else {
                            container.classList.remove('active');
                        }
                    });
                });
            });
        }
        
        // Results tabs
        const resultsTabs = document.getElementById('result_tables_tabs');
        if (resultsTabs) {
            const tabs = resultsTabs.querySelectorAll('.tab');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs
                    tabs.forEach(t => t.classList.remove('active'));
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    
                    // Show selected content
                    const tabId = tab.dataset.tab;
                    const contents = resultsTabs.closest('.section')
                        .querySelectorAll('.tab-content');
                    
                    contents.forEach(content => {
                        if (content.id === tabId) {
                            content.classList.add('active');
                        } else {
                            content.classList.remove('active');
                        }
                    });
                });
            });
        }
        
        console.log("Event handlers added");
    } catch (error) {
        console.error("Error adding event handlers:", error);
    }
}

// Helper function to extract perturbation data from report data
function extractPerturbationData() {
    try {
        // Default data
        const defaultData = {
            levels: [0.1, 0.2, 0.3, 0.4, 0.5],
            baseScore: 0.85,
            perturbedScores: [0.82, 0.79, 0.75, 0.71, 0.68],
            worstScores: [0.80, 0.75, 0.70, 0.65, 0.60],
            featureSubsetScores: [0.83, 0.80, 0.77, 0.74, 0.70],
            metricName: 'Accuracy'
        };
        
        // If no report data, return defaults
        if (!window.reportData || !window.reportData.raw || !window.reportData.raw.by_level) {
            return defaultData;
        }
        
        const rawData = window.reportData.raw.by_level;
        
        // Get levels
        const levels = Object.keys(rawData).map(parseFloat).sort((a, b) => a - b);
        if (levels.length === 0) return defaultData;
        
        // Get base score
        let baseScore = 0.85; // Default
        if (window.reportData.base_score !== undefined) {
            baseScore = window.reportData.base_score;
        }
        
        // Get metric name
        let metricName = 'Score'; // Default
        if (window.reportData.metric) {
            metricName = window.reportData.metric;
        } else if (window.reportConfig && window.reportConfig.metric) {
            metricName = window.reportConfig.metric;
        }
        
        // Extract perturbed scores
        const perturbedScores = levels.map(level => {
            const levelStr = level.toString();
            if (rawData[levelStr] && 
                rawData[levelStr].overall_result && 
                rawData[levelStr].overall_result.all_features) {
                return rawData[levelStr].overall_result.all_features.mean_score;
            }
            // Default value if not found
            return baseScore * (1 - level * 0.2);
        });
        
        // Extract worst scores
        const worstScores = levels.map(level => {
            const levelStr = level.toString();
            if (rawData[levelStr] && 
                rawData[levelStr].overall_result && 
                rawData[levelStr].overall_result.all_features) {
                return rawData[levelStr].overall_result.all_features.worst_score;
            }
            // Default value if not found
            return baseScore * (1 - level * 0.3);
        });
        
        // Extract feature subset scores if available
        const featureSubsetScores = levels.map(level => {
            const levelStr = level.toString();
            if (rawData[levelStr] && 
                rawData[levelStr].overall_result && 
                rawData[levelStr].overall_result.feature_subset) {
                return rawData[levelStr].overall_result.feature_subset.mean_score;
            }
            // Try alternative naming
            if (rawData[levelStr] && 
                rawData[levelStr].overall_result && 
                rawData[levelStr].overall_result.subset_features) {
                return rawData[levelStr].overall_result.subset_features.mean_score;
            }
            return null;
        });
        
        return {
            levels,
            baseScore,
            perturbedScores,
            worstScores,
            featureSubsetScores: featureSubsetScores.some(s => s !== null) ? featureSubsetScores : null,
            metricName
        };
    } catch (error) {
        console.error("Error extracting perturbation data:", error);
        return {
            levels: [0.1, 0.2, 0.3, 0.4, 0.5],
            baseScore: 0.85,
            perturbedScores: [0.82, 0.79, 0.75, 0.71, 0.68],
            worstScores: [0.80, 0.75, 0.70, 0.65, 0.60],
            featureSubsetScores: [0.83, 0.80, 0.77, 0.74, 0.70],
            metricName: 'Accuracy'
        };
    }
}

// Helper function to extract model comparison data
function extractModelComparisonData() {
    try {
        // Default data
        const defaultData = {
            models: ['Primary Model', 'Alternative 1', 'Alternative 2'],
            baseScores: [0.85, 0.82, 0.87],
            robustnessScores: [0.78, 0.74, 0.81]
        };
        
        // If no report data, return defaults
        if (!window.reportData) {
            return defaultData;
        }
        
        const models = [];
        const baseScores = [];
        const robustnessScores = [];
        
        // Add primary model
        let primaryModelName = 'Primary Model';
        if (window.reportData.model_name) {
            primaryModelName = window.reportData.model_name;
        }
        
        let primaryBaseScore = 0.85; // Default
        if (window.reportData.base_score !== undefined) {
            primaryBaseScore = window.reportData.base_score;
        }
        
        let primaryRobustnessScore = 0.78; // Default
        if (window.reportData.robustness_score !== undefined) {
            primaryRobustnessScore = window.reportData.robustness_score;
        } else if (window.reportData.score !== undefined) {
            primaryRobustnessScore = window.reportData.score;
        }
        
        models.push(primaryModelName);
        baseScores.push(primaryBaseScore);
        robustnessScores.push(primaryRobustnessScore);
        
        // Add alternative models if available
        if (window.reportData.alternative_models) {
            Object.entries(window.reportData.alternative_models).forEach(([name, data]) => {
                models.push(name);
                baseScores.push(data.base_score || 0);
                
                let altScore = 0;
                if (data.robustness_score !== undefined) {
                    altScore = data.robustness_score;
                } else if (data.score !== undefined) {
                    altScore = data.score;
                }
                robustnessScores.push(altScore);
            });
        }
        
        // If no alternative models, add demo ones
        if (models.length === 1) {
            models.push('Alternative 1', 'Alternative 2');
            baseScores.push(primaryBaseScore * 0.96, primaryBaseScore * 1.02);
            robustnessScores.push(primaryRobustnessScore * 0.95, primaryRobustnessScore * 1.04);
        }
        
        return {
            models,
            baseScores,
            robustnessScores
        };
    } catch (error) {
        console.error("Error extracting model comparison data:", error);
        return {
            models: ['Primary Model', 'Alternative 1', 'Alternative 2'],
            baseScores: [0.85, 0.82, 0.87],
            robustnessScores: [0.78, 0.74, 0.81]
        };
    }
}

// Show error message in chart container
function showChartError(container, message) {
    container.innerHTML = `
        <div style="padding: 20px; text-align: center; color: #d63031; background-color: #ffeded; border-radius: 4px; margin: 10px;">
            <div style="font-size: 24px; margin-bottom: 10px;"></div>
            <div style="font-weight: bold; margin-bottom: 5px;">Chart Error</div>
            <div>${message}</div>
        </div>
    `;
}

// Show error message in all chart containers
function showAllChartErrors(message) {
    const chartElements = [
        'perturbation-chart-plot',
        'worst-score-chart-plot',
        'model-comparison-chart-plot',
        'model-level-details-chart-plot'
    ];
    
    chartElements.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            showChartError(element, message);
        }
    });
}

// Add CSS to ensure chart containers are visible
document.addEventListener('DOMContentLoaded', function() {
    const style = document.createElement('style');
    style.textContent = `
        .chart-plot {
            min-height: 400px;
            width: 100%;
            display: block !important;
            position: relative;
        }
        
        .chart-container {
            display: none;
        }
        
        .chart-container.active {
            display: block;
        }
        
        .section {
            margin-bottom: 30px;
        }
        
        .chart-selector {
            display: flex;
            margin-bottom: 15px;
            gap: 10px;
        }
        
        .chart-selector-option {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            background-color: #f8f9fa;
        }
        
        .chart-selector-option.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        
        .results-tabs {
            display: flex;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 15px;
        }
        
        .results-tabs .tab {
            padding: 8px 16px;
            cursor: pointer;
            border: 1px solid transparent;
            margin-bottom: -1px;
        }
        
        .results-tabs .tab.active {
            border-color: #dee2e6 #dee2e6 #fff;
            border-radius: 4px 4px 0 0;
            background-color: #fff;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
    `;
    document.head.appendChild(style);
});

// ----- feature_importance_chart ----- //
/**
 * Standalone feature importance chart handler
 * This is a self-contained version that doesn't depend on other code
 */

// Define a standalone handler that works regardless of other code
window.StandaloneFeatureImportanceChart = {
    /**
     * Initialize the feature importance chart
     * @param {string} containerId - ID of container element for the chart
     */
    initialize: function(containerId) {
        console.log("Initializing standalone feature importance chart:", containerId);
        
        const container = document.getElementById(containerId);
        if (!container) {
            console.error("Chart container not found:", containerId);
            return;
        }
        
        // Extract data separately from other code
        const chartData = this.extractChartData();
        if (!chartData || !chartData.features || chartData.features.length === 0) {
            this.showNoDataMessage(container, "No feature importance data available");
            return;
        }
        
        // Create and render chart
        this.renderChart(container, chartData);
    },
    
    /**
     * Extract data for the feature importance chart
     * @returns {Object} Chart data object
     */
    extractChartData: function() {
        try {
            // Try to get feature importance data from various sources
            let featureImportance = {};
            let modelFeatureImportance = {};
            
            if (window.reportConfig && window.reportConfig.feature_importance) {
                featureImportance = window.reportConfig.feature_importance || {};
                modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                console.log("Using feature importance from reportConfig");
            } 
            else if (window.reportData) {
                if (window.reportData.feature_importance) {
                    featureImportance = window.reportData.feature_importance;
                    modelFeatureImportance = window.reportData.model_feature_importance || {};
                    console.log("Using feature importance from reportData");
                }
            }
            
            if (Object.keys(featureImportance).length === 0) {
                console.warn("No feature importance data found");
                return null;
            }
            
            // Convert to arrays for plotting
            const featureArray = Object.keys(featureImportance).map(feature => {
                return {
                    name: feature,
                    importance: featureImportance[feature],
                    modelImportance: modelFeatureImportance[feature] || 0
                };
            });
            
            // Sort by absolute importance
            featureArray.sort((a, b) => Math.abs(b.importance) - Math.abs(a.importance));
            
            // Get top 15 features
            const topFeatures = featureArray.slice(0, 15);
            
            return {
                features: topFeatures.map(f => f.name),
                robustnessValues: topFeatures.map(f => f.importance),
                modelValues: topFeatures.map(f => f.modelImportance)
            };
        } catch (error) {
            console.error("Error extracting feature importance chart data:", error);
            return null;
        }
    },
    
    /**
     * Render the feature importance chart
     * @param {HTMLElement} container - Chart container element
     * @param {Object} chartData - Chart data object
     */
    renderChart: function(container, chartData) {
        try {
            // Verify Plotly is available
            if (typeof Plotly === 'undefined') {
                this.showErrorMessage(container, "Plotly library not available");
                return;
            }
            
            // Clear container
            container.innerHTML = '';
            
            // Create traces for the chart
            const traces = [
                {
                    x: chartData.robustnessValues,
                    y: chartData.features,
                    name: 'Robustness Impact',
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: '#8884d8'
                    }
                }
            ];
            
            // Add model importance if available
            if (chartData.modelValues && chartData.modelValues.length > 0) {
                traces.push({
                    x: chartData.modelValues,
                    y: chartData.features,
                    name: 'Model Importance',
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: '#82ca9d'
                    }
                });
            }
            
            // Chart layout
            const layout = {
                title: 'Feature Importance Comparison',
                xaxis: {
                    title: 'Importance Score'
                },
                yaxis: {
                    title: 'Feature',
                    automargin: true
                },
                barmode: 'group',
                margin: {
                    l: 150,
                    r: 20,
                    t: 40,
                    b: 40
                }
            };
            
            // Create the plot
            Plotly.newPlot(container, traces, layout, {
                responsive: true,
                displayModeBar: false
            });
            
            console.log("Feature importance chart rendered successfully");
        } catch (error) {
            console.error("Error rendering feature importance chart:", error);
            this.showErrorMessage(container, error.message);
        }
    },
    
    /**
     * Show no data message in chart container
     * @param {HTMLElement} container - Chart container element
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(container, message) {
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">No Data Available</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">
                    ${message}
                </p>
            </div>`;
    },
    
    /**
     * Show error message in chart container
     * @param {HTMLElement} container - Chart container element
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(container, errorMessage) {
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                <div style="margin-top: 20px; padding: 15px; background-color: #f8f8f8; border-radius: 5px; text-align: left;">
                    <p style="font-weight: bold; margin-bottom: 10px;">Troubleshooting:</p>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-bottom: 0;">
                        <li>Check if the Plotly library is loaded correctly</li>
                        <li>Verify that feature importance data is available in the report</li>
                        <li>Try reloading the page</li>
                    </ul>
                </div>
            </div>`;
    }
};

// Initialize charts when document is ready
document.addEventListener('DOMContentLoaded', function() {
    // NOTA: No inicializamos mais o grfico de comparao aqui, apenas o de feature_impact
    // para evitar a sobreposio com ImportanceComparisonHandler.js
    
    // Initialize feature importance chart if the container exists
    const featureContainer = document.getElementById('feature-importance-chart');
    if (featureContainer) {
        console.log("Found feature importance chart container - initializing");
        setTimeout(function() {
            window.StandaloneFeatureImportanceChart.initialize('feature-importance-chart');
        }, 500);
    }
    
    // Listen for tab changes to initialize charts when tabs become visible
    document.querySelectorAll('.tab-btn').forEach(button => {
        button.addEventListener('click', function() {
            const tabId = this.getAttribute('data-tab');
            if (tabId === 'feature_impact') {
                console.log("Feature impact tab activated - initializing chart");
                setTimeout(function() {
                    if (document.getElementById('feature-importance-chart')) {
                        window.StandaloneFeatureImportanceChart.initialize('feature-importance-chart');
                    }
                }, 100);
            }
            // Removido o inicializador para importance_comparison para evitar conflito
        });
    });
});

// ----- controllers_boxplot ----- //
// BoxplotController.js
// Updated version that handles all boxplot functionality
// Last updated: 2024-05-07

const BoxplotController = {
    // Track initialization state
    hasInitialized: false,
    
    /**
     * Initialize the boxplot section
     */
    init: function() {
        console.log("Boxplot section initialized");
        
        if (this.hasInitialized) {
            console.log("BoxplotController already initialized, skipping");
            return;
        }
        
        this.hasInitialized = true;
        
        // Verify if boxplot section is visible
        const boxplotSection = document.getElementById('boxplot');
        if (boxplotSection) {
            console.log("Boxplot section found:", {
                isVisible: boxplotSection.classList.contains('active'),
                display: window.getComputedStyle(boxplotSection).display
            });
            
            // Add listener for tab click to handle lazy loading
            const boxplotTabButton = document.querySelector('[data-tab="boxplot"]');
            if (boxplotTabButton) {
                boxplotTabButton.addEventListener('click', () => {
                    console.log("Boxplot tab clicked, initializing charts");
                    this.initializeCharts();
                    this.populateStatsTable();
                });
            }
            
            // Listen for tab change events
            document.addEventListener('tabchange', (event) => {
                if (event.detail && event.detail.tabId === 'boxplot') {
                    console.log("Tab changed to boxplot");
                    this.initializeCharts();
                    this.populateStatsTable();
                }
            });
        }
        
        // Initialize immediately if tab is active
        if (boxplotSection && boxplotSection.classList.contains('active')) {
            this.initializeCharts();
            this.populateStatsTable();
        }
    },
    
    /**
     * Initialize boxplot chart
     */
    initializeCharts: function() {
        const container = document.getElementById('boxplot-chart-container');
        if (!container) {
            console.error("Boxplot chart container not found");
            return;
        }
        
        // Check if Plotly is loaded
        if (typeof Plotly === 'undefined') {
            console.log("Plotly not available, loading from CDN");
            
            const script = document.createElement('script');
            script.src = 'https://cdn.plot.ly/plotly-2.29.1.min.js';
            script.onload = () => {
                console.log("Plotly loaded successfully, rendering chart");
                this.renderBoxplotChart(container);
            };
            script.onerror = () => {
                console.error("Failed to load Plotly");
                this.showErrorMessage(container, "Biblioteca de visualizao Plotly no pde ser carregada");
            };
            
            document.head.appendChild(script);
        } else {
            // Plotly is already available
            this.renderBoxplotChart(container);
        }
    },
    
    /**
     * Render boxplot chart
     * @param {HTMLElement} container - Chart container element
     */
    renderBoxplotChart: function(container) {
        // Extract data from reportData or chartData
        const boxplotData = this.extractBoxplotData();
        
        if (!boxplotData || !boxplotData.models || boxplotData.models.length === 0) {
            console.error("No data available for boxplot visualization");
            this.showNoDataMessage(container, "No h dados disponveis para visualizao do boxplot");
            return;
        }
        
        const models = boxplotData.models;
        const traces = [];
        
        // Define consistent colors for models
        const modelColors = {
            'Primary Model': 'rgba(31, 119, 180, 0.7)',
            'primary_model': 'rgba(31, 119, 180, 0.7)',
            'GLM_CLASSIFIER': 'rgba(255, 127, 14, 0.7)',
            'GAM_CLASSIFIER': 'rgba(44, 160, 44, 0.7)',
            'GBM': 'rgba(214, 39, 40, 0.7)',
            'XGB': 'rgba(148, 103, 189, 0.7)',
            'RANDOM_FOREST': 'rgba(140, 86, 75, 0.7)',
            'SVM': 'rgba(227, 119, 194, 0.7)',
            'NEURAL_NETWORK': 'rgba(127, 127, 127, 0.7)'
        };
        
        // Track valid models
        let validModelCount = 0;
        
        // Create traces for each model
        models.forEach(model => {
            // Skip models without real data
            if (!model.scores || model.scores.length === 0) {
                console.error(`Model ${model.name} has no scores, skipping`);
                return;
            }
            
            validModelCount++;
            
            // Clean up model name for display
            const displayName = model.name.replace(/_/g, ' ').trim();
            
            // Get color or generate a deterministic color based on model name
            let color;
            if (modelColors[model.name]) {
                color = modelColors[model.name];
            } else {
                // Generate a deterministic color based on the model name
                const hash = Array.from(model.name).reduce((hash, char) => {
                    return ((hash << 5) - hash) + char.charCodeAt(0);
                }, 0);
                const r = Math.abs(hash) % 200 + 55; // 55-255 range to avoid too dark or light
                const g = Math.abs(hash * 31) % 200 + 55;
                const b = Math.abs(hash * 17) % 200 + 55;
                color = `rgba(${r}, ${g}, ${b}, 0.7)`;
            }
            
            // Create violin plot for model
            traces.push({
                type: 'violin',
                y: model.scores,
                x: Array(model.scores.length).fill(displayName),
                name: displayName,
                box: {
                    visible: true,
                    width: 0.6
                },
                meanline: {
                    visible: true
                },
                line: {
                    color: 'black',
                    width: 1
                },
                fillcolor: color,
                opacity: 0.7,
                points: 'all',
                jitter: 0.3,
                pointpos: 0,
                hoverinfo: 'y+x',
                spanmode: 'soft',
                width: 0.5,
                bandwidth: 0.2
            });
        });
        
        // Add base scores as separate markers
        const baseScoreTrace = {
            type: 'scatter',
            mode: 'markers',
            y: models.map(m => m.baseScore),
            x: models.map(m => m.name.replace(/_/g, ' ').trim()),
            name: 'Base Score',
            marker: {
                size: 12,
                symbol: 'diamond',
                color: models.map(m => modelColors[m.name] || 'rgba(31, 119, 180, 0.7)'),
                line: {
                    color: 'white',
                    width: 1
                }
            },
            text: models.map(m => `Base Score: ${m.baseScore.toFixed(4)}`),
            hoverinfo: 'text+y'
        };
        
        traces.push(baseScoreTrace);
        
        // If no valid models, show error
        if (validModelCount === 0) {
            console.error("No models with valid scores found");
            this.showNoDataMessage(container, "Nenhum modelo possui dados reais para visualizao");
            return;
        }
        
        // Get metric name
        const metricName = boxplotData.metricName || 
                           window.reportData?.metric ||
                           'Score';
        
        // Create layout
        const layout = {
            title: {
                text: `Model Performance Distribution - ${metricName}`,
                font: { size: 20 }
            },
            xaxis: {
                title: 'Models',
                tickangle: 0,
                automargin: true
            },
            yaxis: {
                title: metricName,
                zeroline: false,
                autorange: true,
                automargin: true
            },
            autosize: true,
            violinmode: 'group',
            hoverlabel: {
                bgcolor: "#FFF",
                font: { size: 12 },
                bordercolor: "#333"
            },
            showlegend: true,
            legend: {
                orientation: "h",
                yanchor: "top",
                y: 1.1,
                xanchor: "right",
                x: 1
            },
            hovermode: 'closest',
            margin: {
                l: 50,
                r: 20,
                t: 60,
                b: 80
            },
            annotations: [{
                xref: 'paper',
                yref: 'paper',
                x: 0,
                y: -0.15,
                text: 'The boxplots show model performance distribution under perturbation tests. Diamond markers indicate base scores.',
                showarrow: false,
                font: { size: 12 }
            }]
        };
        
        try {
            // Render the visualization
            Plotly.newPlot(container, traces, layout, {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                displaylogo: false,
                staticPlot: false,
                toImageButtonOptions: {
                    format: 'png',
                    filename: 'model_comparison_boxplot',
                    height: 700,
                    width: 1000,
                    scale: 2
                }
            }).then(() => {
                console.log("Boxplot chart successfully rendered");
                
                // Force a resize event to ensure proper layout
                window.dispatchEvent(new Event('resize'));
            }).catch(error => {
                console.error("Plotly.newPlot failed:", error);
                this.showErrorMessage(container, `Error rendering boxplot: ${error.message}`);
            });
        } catch (error) {
            console.error("Exception during Plotly.newPlot:", error);
            this.showErrorMessage(container, `Error rendering boxplot: ${error.message}`);
        }
    },
    
    /**
     * Extract boxplot data from report data
     * @returns {Object} Data for boxplot chart
     */
    extractBoxplotData: function() {
        try {
            // First check if we have processed boxplot data
            if (window.reportData && window.reportData.boxplot_data && window.reportData.boxplot_data.models) {
                console.log("Using server-prepared boxplot data");
                
                // Filter models to only include those with real data
                const validModels = window.reportData.boxplot_data.models.filter(model => 
                    model.scores && model.scores.length > 0
                );
                
                // Return null if no valid models
                if (validModels.length === 0) {
                    console.error("No models with valid scores found in boxplot_data");
                    return null;
                }
                
                return {
                    models: validModels,
                    metricName: window.reportData.metric || 'Score'
                };
            }
            
            // If no boxplot_data, try to extract from raw results
            console.log("No pre-processed boxplot data found, extracting from raw results");
            
            if (!window.reportData || !window.reportData.raw || !window.reportData.raw.by_level) {
                console.warn("No raw data available for boxplot extraction");
                return null;
            }
            
            // Get metric name
            const metricName = window.reportData.metric || 'Score';
            console.log(`Using metric: ${metricName}`);
            
            // Extract primary model data
            const primaryModelData = {
                name: window.reportData.model_name || 'Primary Model',
                modelType: window.reportData.model_type || 'Unknown',
                baseScore: window.reportData.base_score || 0,
                scores: []
            };
            
            // Extract iteration scores from each perturbation level
            const rawData = window.reportData.raw.by_level;
            Object.keys(rawData).forEach(level => {
                const levelData = rawData[level];
                
                if (!levelData.runs || !levelData.runs.all_features) {
                    console.log(`Level ${level}: No runs data found`);
                    return;
                }
                
                // Extract scores from all runs at this level
                levelData.runs.all_features.forEach(run => {
                    if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                        console.log(`Level ${level}: Found ${run.iterations.scores.length} iteration scores`);
                        primaryModelData.scores.push(...run.iterations.scores);
                    }
                });
            });
            
            console.log(`Primary model: extracted ${primaryModelData.scores.length} total scores`);
            
            // Se no temos scores reais para o modelo primrio, no gerar dados sintticos
            if (primaryModelData.scores.length === 0) {
                console.error("Nenhum score real encontrado para o modelo primrio. No sero gerados dados sintticos.");
                // We keep the array empty - no synthetic data
            }
            
            const models = [];
            models.push(primaryModelData);
            
            // Extract alternative models data
            if (window.reportData.alternative_models) {
                console.log("Processing alternative models:", Object.keys(window.reportData.alternative_models));
                
                Object.keys(window.reportData.alternative_models).forEach(modelName => {
                    const modelData = window.reportData.alternative_models[modelName];
                    console.log(`Processing alternative model ${modelName}, data keys:`, Object.keys(modelData));
                    
                    const altModelData = {
                        name: modelName,
                        modelType: modelData.model_type || 'Unknown',
                        baseScore: modelData.base_score || 0,
                        scores: []
                    };
                    
                    // Extract scores from alternative model's raw data
                    if (modelData.raw && modelData.raw.by_level) {
                        Object.keys(modelData.raw.by_level).forEach(level => {
                            const levelData = modelData.raw.by_level[level];
                            
                            if (levelData.runs && levelData.runs.all_features) {
                                levelData.runs.all_features.forEach(run => {
                                    if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                                        console.log(`Found ${run.iterations.scores.length} scores for model ${modelName} at level ${level}`);
                                        altModelData.scores.push(...run.iterations.scores);
                                    }
                                });
                            } else if (levelData.overall_result && levelData.overall_result.all_features) {
                                const score = levelData.overall_result.all_features.mean_score;
                                if (score !== undefined) {
                                    console.log(`Using mean_score ${score} from overall_result for level ${level}`);
                                    altModelData.scores.push(score);
                                }
                            }
                        });
                    }
                    
                    console.log(`Alternative model ${modelName}: extracted ${altModelData.scores.length} scores`);
                    
                    // Se no h scores para o modelo alternativo, mostrar erro e no gerar dados sintticos
                    if (altModelData.scores.length === 0) {
                        console.error(`Nenhum score encontrado para o modelo alternativo ${modelName}. No sero gerados dados sintticos.`);
                        // We keep the array empty - no synthetic data
                    }
                    
                    models.push(altModelData);
                });
            }
            
            // Se no houver modelos com scores, no gerar dados sintticos
            if (models.length === 0 || !models.some(m => m.scores && m.scores.length > 0)) {
                console.error("Nenhum modelo com scores foi encontrado. No sero criados dados sintticos.");
                return null;
            }
            
            console.log(`Extracted data for ${models.length} models`);
            return { models, metricName };
        } catch (error) {
            console.error("Error extracting boxplot data:", error);
            return null; // No gerar dados sintticos em caso de erro
        }
    },
    
    /**
     * Populate the statistics table with model data
     */
    populateStatsTable: function() {
        const tableBody = document.getElementById('boxplot-table-body');
        if (!tableBody) return;
        
        try {
            // Clear existing content
            tableBody.innerHTML = '';
            
            // Get boxplot data
            const boxplotData = this.extractBoxplotData();
            if (!boxplotData || !boxplotData.models || boxplotData.models.length === 0) {
                this.showNoTableData(tableBody);
                return;
            }
            
            // Add rows for each model
            boxplotData.models.forEach(model => {
                // Skip models without real data
                if (!model.scores || model.scores.length === 0) return;
                
                // Sort scores for statistics
                const sortedScores = model.scores.slice().sort((a, b) => a - b);
                
                // Calculate basic stats
                const mean = sortedScores.reduce((a, b) => a + b, 0) / sortedScores.length;
                
                // Calculate median
                const mid = Math.floor(sortedScores.length / 2);
                const median = sortedScores.length % 2 === 0 ? 
                    (sortedScores[mid - 1] + sortedScores[mid]) / 2 : 
                    sortedScores[mid];
                
                // Calculate quartiles for IQR
                const q1Index = Math.floor(sortedScores.length * 0.25);
                const q3Index = Math.floor(sortedScores.length * 0.75);
                const q1 = sortedScores[q1Index] || 0;
                const q3 = sortedScores[q3Index] || 0;
                const iqr = q3 - q1;
                
                // Calculate min, max
                const min = sortedScores[0] || 0;
                const max = sortedScores[sortedScores.length - 1] || 0;
                
                // Calculate standard deviation
                let stdDev = 0;
                if (sortedScores.length > 1) {
                    const squaredDiffs = sortedScores.map(val => Math.pow(val - mean, 2));
                    const variance = squaredDiffs.reduce((a, b) => a + b, 0) / sortedScores.length;
                    stdDev = Math.sqrt(variance);
                }
                
                // Create row
                const row = document.createElement('tr');
                
                // Model name - replace all underscores with spaces
                const nameCell = document.createElement('td');
                const displayName = model.name.replace(/_/g, ' ');
                nameCell.textContent = displayName || "Unknown Model";
                nameCell.style.fontWeight = 'bold';
                
                // Highlight primary model
                if (model.name === window.reportData?.model_name || model.name === 'Primary Model') {
                    nameCell.style.color = '#1b78de';
                }
                
                row.appendChild(nameCell);
                
                // Base score
                const baseScoreCell = document.createElement('td');
                baseScoreCell.textContent = model.baseScore ? model.baseScore.toFixed(4) : "N/A";
                row.appendChild(baseScoreCell);
                
                // Median
                const medianCell = document.createElement('td');
                medianCell.textContent = median.toFixed(4);
                row.appendChild(medianCell);
                
                // Mean
                const meanCell = document.createElement('td');
                meanCell.textContent = mean.toFixed(4);
                row.appendChild(meanCell);
                
                // IQR
                const iqrCell = document.createElement('td');
                iqrCell.textContent = iqr.toFixed(4);
                row.appendChild(iqrCell);
                
                // Min
                const minCell = document.createElement('td');
                minCell.textContent = min.toFixed(4);
                row.appendChild(minCell);
                
                // Max
                const maxCell = document.createElement('td');
                maxCell.textContent = max.toFixed(4);
                row.appendChild(maxCell);
                
                // Std Dev
                const stdDevCell = document.createElement('td');
                stdDevCell.textContent = stdDev.toFixed(4);
                row.appendChild(stdDevCell);
                
                // Score drop
                const dropCell = document.createElement('td');
                const baseScore = model.baseScore || 0;
                const dropPercent = (baseScore > 0) ? ((baseScore - median) / baseScore) * 100 : 0;
                dropCell.textContent = dropPercent.toFixed(2) + '%';
                dropCell.className = dropPercent > 5 ? 'text-danger' : (dropPercent > 2 ? 'text-warning' : 'text-success');
                row.appendChild(dropCell);
                
                tableBody.appendChild(row);
            });
        } catch (error) {
            console.error("Error populating stats table:", error);
            this.showTableError(tableBody);
        }
    },
    
    /**
     * Show no data message in container
     * @param {HTMLElement} container - Chart container
     * @param {string} message - Message to display
     */
    showNoDataMessage: function(container, message) {
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados no disponveis</h3>
                <p style="color: #333; font-size: 16px; line-height: 1.4;">${message}</p>
                <p style="color: #333; margin-top: 20px; font-size: 14px;">
                    Execute testes de robustez com iteraes (n_iterations > 1) para visualizar dados reais.
                </p>
            </div>`;
    },
    
    /**
     * Show error message in container
     * @param {HTMLElement} container - Chart container
     * @param {string} errorMessage - Error message to display
     */
    showErrorMessage: function(container, errorMessage) {
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
            </div>`;
    },
    
    /**
     * Show no data message in table
     * @param {HTMLElement} tableBody - Table body element
     */
    showNoTableData: function(tableBody) {
        tableBody.innerHTML = `
            <tr>
                <td colspan="9" class="text-center">
                    <div class="loading-info">
                        <div class="loading-icon"></div>
                        <p>Dados de distribuio no disponveis para modelos.</p>
                        <p>Execute testes com iteraes (n_iterations > 1) para visualizar estatsticas.</p>
                    </div>
                </td>
            </tr>`;
    },
    
    /**
     * Show error message in table
     * @param {HTMLElement} tableBody - Table body element
     */
    showTableError: function(tableBody) {
        tableBody.innerHTML = `
            <tr>
                <td colspan="9" class="text-center">
                    <div class="loading-info">
                        <div class="loading-icon"></div>
                        <p>Erro ao carregar estatsticas dos modelos.</p>
                    </div>
                </td>
            </tr>`;
    }
};

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    BoxplotController.init();
});

// ----- controllers_featuresTable ----- //
// Feature Importance Table Controller
window.FeatureImportanceTableController = {
    // State management
    state: {
        sortConfig: { key: 'impact', direction: 'desc' },
        searchTerm: '',
        showOnlySubset: false,
        hoveredRow: null,
        allData: [],
        filteredData: []
    },
    
    /**
     * Initialize the feature importance table
     */
    init: function() {
        console.log("Feature Importance Table initialized");
        
        // Get table elements
        this.tableElement = document.querySelector('.feature-importance-table');
        this.tableBody = document.getElementById('feature-impact-data');
        this.tableFooter = document.querySelector('.feature-importance-footer');
        this.searchInput = document.getElementById('feature-search');
        this.subsetToggle = document.getElementById('show-subset-only');
        this.totalCountEl = document.getElementById('total-features-count');
        this.subsetCountEl = document.getElementById('subset-features-count');
        
        // Check if required elements exist
        if (!this.tableBody) {
            console.error("Required table elements not found");
            return;
        }
        
        // Load initial data
        this.loadData();
        
        // Initialize event listeners
        this.initEventListeners();
        
        // Render the table
        this.renderTable();
    },
    
    /**
     * Load feature data from the report
     */
    loadData: function() {
        try {
            // Extract data using the manager
            this.state.allData = FeatureImportanceTableManager.extractFeatureData();
            
            // Apply initial sorting and filtering
            this.updateFilteredData();
            
            console.log(`Loaded ${this.state.allData.length} features in controller`);
        } catch (error) {
            console.error("Error loading feature data:", error);
            this.state.allData = [];
            this.state.filteredData = [];
        }
    },
    
    /**
     * Set up event listeners for the table
     */
    initEventListeners: function() {
        // Set up column header sorting
        if (this.tableElement) {
            const headers = this.tableElement.querySelectorAll('th.sortable');
            headers.forEach(header => {
                const key = header.getAttribute('data-sort');
                if (key) {
                    header.addEventListener('click', () => this.handleSort(key));
                }
            });
        }
        
        // Set up search input
        if (this.searchInput) {
            this.searchInput.addEventListener('input', (e) => {
                this.state.searchTerm = e.target.value;
                this.updateFilteredData();
                this.renderTable();
            });
        }
        
        // Set up subset toggle
        if (this.subsetToggle) {
            this.subsetToggle.addEventListener('change', (e) => {
                this.state.showOnlySubset = e.target.checked;
                this.updateFilteredData();
                this.renderTable();
            });
        }
        
        // Set up row hover effects (using event delegation)
        if (this.tableBody) {
            this.tableBody.addEventListener('mouseover', (e) => {
                const row = e.target.closest('tr[data-feature]');
                if (row) {
                    const feature = row.getAttribute('data-feature');
                    this.state.hoveredRow = feature;
                    this.highlightRow(feature);
                }
            });
            
            this.tableBody.addEventListener('mouseout', () => {
                this.state.hoveredRow = null;
                this.clearRowHighlights();
            });
        }
    },
    
    /**
     * Handle column sorting
     * @param {string} key - Key to sort by
     */
    handleSort: function(key) {
        const { sortConfig } = this.state;
        const direction = 
            sortConfig.key === key && sortConfig.direction === 'desc' ? 'asc' : 'desc';
        
        this.state.sortConfig = { key, direction };
        this.updateFilteredData();
        this.renderTable();
        
        // Update sort indicators
        this.updateSortIndicators(key, direction);
    },
    
    /**
     * Update filtered and sorted data based on current state
     */
    updateFilteredData: function() {
        const { allData, sortConfig, searchTerm, showOnlySubset } = this.state;
        
        // First filter the data
        const filtered = FeatureImportanceTableManager.filterData(
            allData, 
            searchTerm, 
            showOnlySubset
        );
        
        // Then sort the filtered data
        this.state.filteredData = FeatureImportanceTableManager.sortData(
            filtered,
            sortConfig.key,
            sortConfig.direction
        );
    },
    
    /**
     * Render the table with current data
     */
    renderTable: function() {
        if (!this.tableBody) return;
        
        try {
            const { filteredData, allData, hoveredRow } = this.state;
            
            // Generate and insert rows
            this.tableBody.innerHTML = FeatureImportanceTableManager.generateTableRows(filteredData, hoveredRow);
            
            // Update feature counts
            this.updateFeatureCounts();
            
        } catch (error) {
            console.error("Error rendering feature table:", error);
            this.tableBody.innerHTML = FeatureImportanceTableManager.generateErrorMessage(error.message);
        }
    },
    
    /**
     * Update feature count displays
     */
    updateFeatureCounts: function() {
        if (this.totalCountEl && this.subsetCountEl) {
            const counts = FeatureImportanceTableManager.getFeatureCounts(this.state.allData);
            this.totalCountEl.textContent = counts.total;
            this.subsetCountEl.textContent = counts.inSubset;
        }
    },
    
    /**
     * Update sort indicators in column headers
     * @param {string} activeKey - Currently active sort key
     * @param {string} direction - Sort direction
     */
    updateSortIndicators: function(activeKey, direction) {
        if (!this.tableElement) return;
        
        const headers = this.tableElement.querySelectorAll('th.sortable');
        
        headers.forEach(header => {
            const indicator = header.querySelector('.sort-indicator');
            if (!indicator) return;
            
            // Clear all indicators
            indicator.textContent = '';
            
            const key = header.getAttribute('data-sort');
            if (key === activeKey) {
                // Set the active indicator
                indicator.textContent = direction === 'asc' ? '' : '';
            }
        });
    },
    
    /**
     * Highlight a specific row
     * @param {string} featureName - Name of feature to highlight
     */
    highlightRow: function(featureName) {
        if (!this.tableBody) return;
        
        // Remove current highlights
        this.clearRowHighlights();
        
        // Add highlight to matching row
        const row = this.tableBody.querySelector(`tr[data-feature="${featureName}"]`);
        if (row) {
            row.classList.add('hovered-row');
        }
    },
    
    /**
     * Clear all row highlights
     */
    clearRowHighlights: function() {
        if (!this.tableBody) return;
        
        const rows = this.tableBody.querySelectorAll('tr.hovered-row');
        rows.forEach(row => row.classList.remove('hovered-row'));
    }
};

// Add auto-initialization on DOM load
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the controller if we're on the feature impact tab
    const featureTab = document.getElementById('feature_impact');
    if (featureTab && featureTab.classList.contains('active')) {
        console.log("Feature tab is active on load, initializing table controller");
        FeatureImportanceTableController.init();
    }
    
    // Also initialize when the feature tab is clicked
    const featureTabBtn = document.querySelector('[data-tab="feature_impact"]');
    if (featureTabBtn) {
        featureTabBtn.addEventListener('click', function() {
            console.log("Feature tab clicked, initializing table controller");
            setTimeout(function() {
                FeatureImportanceTableController.init();
            }, 100);
        });
    }
});

// ----- controllers_modelComparison ----- //
// Model Comparison Controller
const ModelComparisonController = {
    init: function() {
        console.log("Model Comparison section initialized");
        
        // Initialize tab navigation
        this.initTabNavigation();
        
        // Initialize metric selector if it exists
        this.initMetricSelector();
        
        // Initialize highlight toggle
        this.initHighlightToggle();
        
        // Initialize row expansion functionality
        this.initRowExpansion();
        
        // Initialize charts for robustness visualization
        this.initRobustnessCharts();
    },
    
    initTabNavigation: function() {
        const tabButtons = document.querySelectorAll('.model-comparison-tab');
        if (!tabButtons.length) return;
        
        tabButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                // Remove active from all tabs
                tabButtons.forEach(tab => tab.classList.remove('active'));
                
                // Add active to clicked tab
                e.currentTarget.classList.add('active');
                
                // Show corresponding content
                const tabId = e.currentTarget.getAttribute('data-tab');
                this.showTabContent(tabId);
            });
        });
        
        // Show first tab by default
        tabButtons[0].click();
    },
    
    showTabContent: function(tabId) {
        // Hide all tab content
        const tabContents = document.querySelectorAll('.model-comparison-content');
        tabContents.forEach(content => content.classList.remove('active'));
        
        // Show selected tab content
        const selectedContent = document.getElementById(tabId);
        if (selectedContent) {
            selectedContent.classList.add('active');
        }
        
        // Re-render charts if it's the robustness tab
        if (tabId === 'robustness-tab') {
            this.initRobustnessCharts();
        }
    },
    
    initMetricSelector: function() {
        const metricSelector = document.getElementById('metric-selector');
        if (!metricSelector) return;
        
        metricSelector.addEventListener('change', (e) => {
            const metric = e.target.value;
            ModelComparisonManager.updateMetricsDisplay(metric);
        });
    },
    
    initHighlightToggle: function() {
        const highlightToggle = document.getElementById('highlight-best-toggle');
        if (!highlightToggle) return;
        
        highlightToggle.addEventListener('change', (e) => {
            const highlightBest = e.target.checked;
            ModelComparisonManager.setHighlightBest(highlightBest);
            
            // Re-render active table
            const activeTab = document.querySelector('.model-comparison-tab.active');
            if (activeTab) {
                const tabId = activeTab.getAttribute('data-tab');
                ModelComparisonManager.renderTable(tabId);
            }
        });
    },
    
    initRowExpansion: function() {
        // Use event delegation for row expansion since rows might be re-rendered
        const tableContainer = document.querySelector('.model-comparison-container');
        if (!tableContainer) return;
        
        tableContainer.addEventListener('click', (e) => {
            // Check if the click is on a model row (not on expanded content)
            const modelRow = e.target.closest('tr[data-model-key]');
            if (!modelRow) return;
            
            const modelKey = modelRow.getAttribute('data-model-key');
            ModelComparisonManager.toggleRowExpansion(modelKey);
        });
    },
    
    initRobustnessCharts: function() {
        console.log("Initializing robustness comparison charts");
        
        setTimeout(() => {
            if (typeof Plotly !== 'undefined') {
                ModelComparisonManager.renderPerturbationChart('perturbation-comparison-chart');
            } else {
                this.showChartError();
            }
        }, 500);
    },
    
    showChartError: function() {
        const chartContainers = document.querySelectorAll('.chart-container');
        chartContainers.forEach(container => {
            container.innerHTML = "<div style='padding: 20px; text-align: center; color: red;'>Plotly library not loaded. Charts cannot be displayed.</div>";
        });
    },
    
    refreshAllTables: function() {
        // Get currently active tab
        const activeTab = document.querySelector('.model-comparison-tab.active');
        if (activeTab) {
            const tabId = activeTab.getAttribute('data-tab');
            ModelComparisonManager.renderTable(tabId);
        }
    }
};

// ----- controllers_details ----- //
/**
 * Overview Controller
 * Handles data and UI interactions for the model overview page
 */
window.OverviewController = {
    /**
     * Initialize the controller
     */
    init: function() {
        console.log("OverviewController initialized");
        
        // Load model data
        this.loadModelData();
        
        // Initialize the model selector
        this.initializeModelSelector();
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Initialize charts
        this.initializeCharts();
        
        // Update the dataset info
        this.updateDatasetInfo();
        
        // Fill the models table
        this.fillModelsTable();
        
        console.log("Overview page initialization complete");
    },
    
    /**
     * Load model data from global variables
     */
    loadModelData: function() {
        console.log("Loading model data");
        this.modelData = {};
        this.configData = {};
        
        // Try multiple sources for model data
        if (window.reportData) {
            this.modelData = window.reportData.models || {};
            this.configData = window.reportData.config || {};
            console.log("Using data from reportData");
        } else if (window.chartData) {
            this.modelData = window.chartData.models || {};
            this.configData = window.chartData.config || {};
            console.log("Using data from chartData");
        } else if (window.config) {
            this.modelData = window.config.models || {};
            this.configData = window.config;
            console.log("Using data from config");
        } else {
            console.warn("No model data found in any data source");
        }
        
        // Check if we have model data
        if (Object.keys(this.modelData).length === 0) {
            console.warn("Empty model data");
            this.showDataError("No foi possvel carregar dados de modelos.");
        } else {
            console.log("Loaded data for", Object.keys(this.modelData).length, "models");
        }
    },
    
    /**
     * Initialize the model selector dropdown
     */
    initializeModelSelector: function() {
        console.log("Initializing model selector");
        const selector = document.getElementById('model-selector');
        if (!selector) {
            console.error("Model selector element not found");
            return;
        }
        
        // Keep the 'all' option as first choice
        let options = ['<option value="all">Todos os Modelos</option>'];
        
        // Add options for each model
        Object.entries(this.modelData).forEach(([key, model]) => {
            options.push(`<option value="${key}">${model.name} (${model.type})</option>`);
        });
        
        // Update selector options
        selector.innerHTML = options.join('');
        
        console.log("Model selector initialized with", Object.keys(this.modelData).length, "models");
    },
    
    /**
     * Set up event listeners for UI interactions
     */
    setupEventListeners: function() {
        console.log("Setting up event listeners");
        
        // Model selector change event
        const selector = document.getElementById('model-selector');
        if (selector) {
            selector.addEventListener('change', (e) => {
                const modelId = e.target.value;
                this.handleModelSelection(modelId);
            });
        }
        
        // Table header sort event
        const headers = document.querySelectorAll('.data-table th.sortable');
        if (headers.length > 0) {
            headers.forEach(header => {
                header.addEventListener('click', (e) => {
                    const sortBy = e.currentTarget.getAttribute('data-sort');
                    this.sortModelsTable(sortBy);
                });
            });
        }
        
        // Tab navigation
        const tabLinks = document.querySelectorAll('.main-nav a');
        if (tabLinks.length > 0) {
            tabLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const tabId = e.currentTarget.getAttribute('data-tab');
                    this.switchTab(tabId);
                });
            });
        }
        
        console.log("Event listeners setup complete");
    },
    
    /**
     * Initialize charts on the overview page
     */
    initializeCharts: function() {
        console.log("Initializing overview charts");
        
        // Use the chart manager to initialize charts
        if (typeof window.OverviewChartsManager !== 'undefined' && 
            typeof window.OverviewChartsManager.initializeOverviewCharts === 'function') {
            window.OverviewChartsManager.initializeOverviewCharts();
        } else {
            console.error("OverviewChartsManager not available");
        }
    },
    
    /**
     * Update dataset info in the UI
     */
    updateDatasetInfo: function() {
        console.log("Updating dataset info");
        
        // Get dataset info elements
        const samplesElement = document.getElementById('n-samples');
        const featuresElement = document.getElementById('n-features');
        const testSizeElement = document.getElementById('test-size');
        
        // Get test info elements
        const testsListElement = document.getElementById('tests-list');
        const verboseElement = document.getElementById('verbose-status');
        
        // Check if we have dataset info
        if (this.configData && this.configData.dataset_info) {
            const datasetInfo = this.configData.dataset_info;
            
            // Update dataset info
            if (samplesElement) {
                samplesElement.textContent = datasetInfo.n_samples || 'N/A';
            }
            
            if (featuresElement) {
                featuresElement.textContent = datasetInfo.n_features || 'N/A';
            }
            
            if (testSizeElement && datasetInfo.test_size !== undefined) {
                testSizeElement.textContent = (datasetInfo.test_size * 100) + '%';
            }
        } else {
            console.warn("No dataset info available");
            
            // Set placeholders
            if (samplesElement) samplesElement.textContent = 'N/A';
            if (featuresElement) featuresElement.textContent = 'N/A';
            if (testSizeElement) testSizeElement.textContent = 'N/A';
        }
        
        // Check if we have test config info
        if (this.configData && this.configData.tests) {
            // Update test info
            if (testsListElement) {
                testsListElement.textContent = this.configData.tests.join(', ');
            }
            
            if (verboseElement) {
                verboseElement.textContent = this.configData.verbose ? 'Sim' : 'No';
            }
        } else {
            console.warn("No test config info available");
            
            // Set placeholders
            if (testsListElement) testsListElement.textContent = 'N/A';
            if (verboseElement) verboseElement.textContent = 'N/A';
        }
        
        console.log("Dataset info updated");
    },
    
    /**
     * Fill the models comparison table
     */
    fillModelsTable: function() {
        console.log("Filling models table");
        
        const tableBody = document.getElementById('models-table-body');
        if (!tableBody) {
            console.error("Models table body element not found");
            return;
        }
        
        // Check if we have model data
        if (Object.keys(this.modelData).length === 0) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="7" class="empty-table-message">
                        No foram encontrados dados de modelos para exibir.
                    </td>
                </tr>`;
            return;
        }
        
        // Convert model data to array for sorting
        const modelsArray = Object.entries(this.modelData).map(([key, model]) => ({
            id: key,
            name: model.name || key,
            type: model.type || 'Desconhecido',
            metrics: model.metrics || {}
        }));
        
        // Sort by model name by default
        modelsArray.sort((a, b) => a.name.localeCompare(b.name));
        
        // Generate table rows HTML
        const rows = modelsArray.map(model => {
            const metrics = model.metrics || {};
            
            return `
                <tr data-model-id="${model.id}">
                    <td>${model.name}</td>
                    <td>${model.type}</td>
                    <td class="numeric">${this.formatMetric(metrics.accuracy)}</td>
                    <td class="numeric">${this.formatMetric(metrics.roc_auc)}</td>
                    <td class="numeric">${this.formatMetric(metrics.f1)}</td>
                    <td class="numeric">${this.formatMetric(metrics.precision)}</td>
                    <td class="numeric">${this.formatMetric(metrics.recall)}</td>
                </tr>`;
        }).join('');
        
        // Update table body
        tableBody.innerHTML = rows;
        
        console.log("Models table filled with", modelsArray.length, "models");
    },
    
    /**
     * Format metric value for display
     * @param {number} value - Metric value
     * @returns {string} - Formatted value
     */
    formatMetric: function(value) {
        if (value === undefined || value === null) {
            return 'N/A';
        }
        return value.toFixed(4);
    },
    
    /**
     * Handle model selection change
     * @param {string} modelId - Selected model ID
     */
    handleModelSelection: function(modelId) {
        console.log("Model selection changed to:", modelId);
        
        // Highlight selected model in the table
        const tableRows = document.querySelectorAll('#models-table-body tr');
        tableRows.forEach(row => {
            if (modelId === 'all' || row.getAttribute('data-model-id') === modelId) {
                row.classList.remove('inactive-row');
            } else {
                row.classList.add('inactive-row');
            }
        });
        
        // You could refresh charts here based on selection
        // For example:
        // this.refreshMetricsChart(modelId);
    },
    
    /**
     * Sort the models table by the specified column
     * @param {string} sortBy - Column to sort by
     */
    sortModelsTable: function(sortBy) {
        console.log("Sorting table by:", sortBy);
        
        // Reset sort indicators on all header cells
        document.querySelectorAll('#models-table th.sortable').forEach(header => {
            header.classList.remove('sort-asc', 'sort-desc');
        });
        
        // Get the header element for the sorted column
        const header = document.querySelector(`#models-table th[data-sort="${sortBy}"]`);
        
        // Determine sort direction
        let sortDirection = 'asc';
        if (header.classList.contains('sort-asc')) {
            sortDirection = 'desc';
        }
        
        // Set sort indicator on active column
        header.classList.add(`sort-${sortDirection}`);
        
        // Convert model data to array for sorting
        const modelsArray = Object.entries(this.modelData).map(([key, model]) => ({
            id: key,
            name: model.name || key,
            type: model.type || 'Desconhecido',
            metrics: model.metrics || {}
        }));
        
        // Sort the array
        modelsArray.sort((a, b) => {
            let valueA, valueB;
            
            if (sortBy === 'name') {
                valueA = a.name;
                valueB = b.name;
                return sortDirection === 'asc' ? 
                    valueA.localeCompare(valueB) : 
                    valueB.localeCompare(valueA);
            } else if (sortBy === 'type') {
                valueA = a.type;
                valueB = b.type;
                return sortDirection === 'asc' ? 
                    valueA.localeCompare(valueB) : 
                    valueB.localeCompare(valueA);
            } else {
                // Assume it's a metric
                valueA = a.metrics[sortBy] || 0;
                valueB = b.metrics[sortBy] || 0;
                return sortDirection === 'asc' ? 
                    valueA - valueB : 
                    valueB - valueA;
            }
        });
        
        // Generate table rows HTML
        const rows = modelsArray.map(model => {
            const metrics = model.metrics || {};
            
            return `
                <tr data-model-id="${model.id}">
                    <td>${model.name}</td>
                    <td>${model.type}</td>
                    <td class="numeric">${this.formatMetric(metrics.accuracy)}</td>
                    <td class="numeric">${this.formatMetric(metrics.roc_auc)}</td>
                    <td class="numeric">${this.formatMetric(metrics.f1)}</td>
                    <td class="numeric">${this.formatMetric(metrics.precision)}</td>
                    <td class="numeric">${this.formatMetric(metrics.recall)}</td>
                </tr>`;
        }).join('');
        
        // Update table body
        const tableBody = document.getElementById('models-table-body');
        if (tableBody) {
            tableBody.innerHTML = rows;
        }
        
        // Reapply model filter if needed
        const selectedModel = document.getElementById('model-selector').value;
        if (selectedModel !== 'all') {
            this.handleModelSelection(selectedModel);
        }
    },
    
    /**
     * Switch between tabs
     * @param {string} tabId - ID of the tab to switch to
     */
    switchTab: function(tabId) {
        console.log("Switching to tab:", tabId);
        
        // Update tab links
        document.querySelectorAll('.main-nav li').forEach(tab => {
            if (tab.querySelector(`a[data-tab="${tabId}"]`)) {
                tab.classList.add('active');
            } else {
                tab.classList.remove('active');
            }
        });
        
        // Update tab contents
        document.querySelectorAll('.tab-content').forEach(content => {
            if (content.id === tabId) {
                content.classList.add('active');
            } else {
                content.classList.remove('active');
            }
        });
        
        // Dispatch custom event for tab change
        const event = new CustomEvent('tabchange', {
            detail: { tabId: tabId }
        });
        document.dispatchEvent(event);
    },
    
    /**
     * Show error message when data cannot be loaded
     * @param {string} message - Error message
     */
    showDataError: function(message) {
        console.error("Data error:", message);
        
        // Find container elements to show the error
        const chartContainer = document.getElementById('metrics-radar-chart');
        const tableBody = document.getElementById('models-table-body');
        
        // Show error in chart container
        if (chartContainer) {
            chartContainer.innerHTML = `
                <div class="error-container">
                    <div class="error-icon"></div>
                    <h3 class="error-title">Erro ao Carregar Dados</h3>
                    <p class="error-message">${message}</p>
                </div>`;
        }
        
        // Show error in table
        if (tableBody) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="7" class="empty-table-message">
                        ${message}
                    </td>
                </tr>`;
        }
    }
};

// Initialize controller when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Small delay to ensure other scripts are loaded
    setTimeout(function() {
        if (typeof OverviewController !== 'undefined' && 
            typeof OverviewController.init === 'function') {
            OverviewController.init();
        } else {
            console.error("OverviewController not available");
        }
    }, 100);
});

// ----- controllers_SafePerturbationResultsController ----- //
// Safe implementation of the PerturbationResultsController
// This version fixes syntax errors and adds error handling
(function() {
    // Create the controller if it doesn't exist
    window.SafePerturbationResultsController = {
        // Store the extracted data
        data: null,
        
        // Store UI state
        state: {
            selectedLevel: null,
            activeTab: 'summary',
            expandedSection: 'allFeatures'
        },
        
        /**
         * Initialize the controller safely
         */
        init: function() {
            console.log("Initializing Safe Perturbation Results Controller");
            
            try {
                // Extract perturbation data if the manager exists
                if (typeof PerturbationResultsManager !== 'undefined') {
                    this.data = PerturbationResultsManager.extractPerturbationData();
                    
                    // Set initial selected level to middle value if available, otherwise first value
                    if (this.data && this.data.results && this.data.results.length > 0) {
                        const middleIndex = Math.floor(this.data.results.length / 2);
                        this.state.selectedLevel = this.data.results[middleIndex].level;
                    }
                    
                    // Render the component
                    this.render();
                    
                    // Initialize event listeners
                    this.initEventListeners();
                } else {
                    console.error("PerturbationResultsManager not found");
                    this.renderError("Unable to extract perturbation data. PerturbationResultsManager not available.");
                }
            } catch (error) {
                console.error("Error initializing PerturbationResultsController:", error);
                this.renderError("An error occurred while initializing: " + error.message);
            }
        },
        
        /**
         * Format a number safely
         * @param {number} value - Number to format
         * @param {number} decimals - Decimal places
         * @returns {string} Formatted number
         */
        formatNumber: function(value, decimals) {
            try {
                if (typeof value !== 'number') return 'N/A';
                const dec = decimals || 4;
                return value.toFixed(dec);
            } catch (error) {
                return 'Error';
            }
        },
        
        /**
         * Get color class for impact value safely
         * @param {number} impact - Impact value
         * @returns {string} CSS class
         */
        getImpactColorClass: function(impact) {
            try {
                if (impact < 0) return 'text-green-600';
                if (impact < 0.05) return 'text-yellow-600';
                if (impact < 0.1) return 'text-orange-600';
                return 'text-red-600';
            } catch (error) {
                return 'text-gray-600';
            }
        },
        
        /**
         * Get background color class for score comparison
         * @param {number} score - Score to compare
         * @param {number} baseScore - Base score
         * @returns {string} CSS class
         */
        getScoreBgColorClass: function(score, baseScore) {
            try {
                if (!score || !baseScore) return '';
                const diff = score - baseScore;
                if (diff > 0) return 'bg-green-50';
                if (diff < -0.1) return 'bg-red-50';
                if (diff < -0.05) return 'bg-orange-50';
                if (diff < 0) return 'bg-yellow-50';
                return '';
            } catch (error) {
                return '';
            }
        },
        
        /**
         * Create error message element
         * @param {string} message - Error message to display
         * @returns {HTMLElement} Error message element
         */
        createErrorMessage: function(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'p-8 text-center text-red-500';
            errorDiv.textContent = message || 'An error occurred loading perturbation data';
            return errorDiv;
        },
        
        /**
         * Render error message
         * @param {string} message - Error message to display
         */
        renderError: function(message) {
            const container = document.getElementById('perturbation-results-container');
            if (!container) {
                console.error("Perturbation results container not found");
                return;
            }
            
            // Clear container
            container.innerHTML = '';
            
            // Create error message
            const errorDiv = document.createElement('div');
            errorDiv.className = 'p-6 text-center text-red-500 bg-red-50 rounded-lg border border-red-200';
            
            const errorIcon = document.createElement('div');
            errorIcon.className = 'text-4xl mb-3';
            errorIcon.innerHTML = '';
            errorDiv.appendChild(errorIcon);
            
            const errorTitle = document.createElement('h3');
            errorTitle.className = 'text-lg font-medium text-red-800 mb-2';
            errorTitle.textContent = 'Error Loading Perturbation Results';
            errorDiv.appendChild(errorTitle);
            
            const errorMessage = document.createElement('p');
            errorMessage.className = 'text-red-600';
            errorMessage.textContent = message || 'An unknown error occurred while loading perturbation data.';
            errorDiv.appendChild(errorMessage);
            
            container.appendChild(errorDiv);
        },
        
        /**
         * Initialize event listeners
         */
        initEventListeners: function() {
            document.addEventListener('click', (event) => {
                try {
                    // Handle level selection
                    if (event.target.classList.contains('level-btn')) {
                        const level = parseFloat(event.target.dataset.level);
                        this.state.selectedLevel = level;
                        this.render();
                    }
                    
                    // Handle tab selection
                    if (event.target.classList.contains('tab-btn')) {
                        const tab = event.target.dataset.tab;
                        this.state.activeTab = tab;
                        this.render();
                    }
                    
                    // Handle section toggle
                    if (event.target.closest('.section-toggle')) {
                        const section = event.target.closest('.section-toggle').dataset.section;
                        this.state.expandedSection = this.state.expandedSection === section ? null : section;
                        this.render();
                    }
                } catch (error) {
                    console.error("Error in event listener:", error);
                }
            });
        },
        
        /**
         * Render the perturbation results UI
         */
        render: function() {
            try {
                const container = document.getElementById('perturbation-results-container');
                if (!container) {
                    console.error("Perturbation results container not found");
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                // Create main container
                const mainDiv = document.createElement('div');
                mainDiv.className = 'bg-white rounded-lg shadow-md overflow-hidden';
                
                // Create header
                mainDiv.appendChild(this.createHeader());
                
                // Create content based on active tab
                if (this.state.activeTab === 'summary') {
                    mainDiv.appendChild(this.createSummaryTab());
                } else {
                    mainDiv.appendChild(this.createIterationsTab());
                }
                
                // Create footer
                mainDiv.appendChild(this.createFooter());
                
                // Add to container
                container.appendChild(mainDiv);
            } catch (error) {
                console.error("Error rendering perturbation results:", error);
                this.renderError(error.message);
            }
        },
        
        // Create header section (same implementation with added try-catch)
        createHeader: function() {
            try {
                const header = document.createElement('div');
                header.className = 'p-4 border-b border-gray-200';
                
                // Title
                const title = document.createElement('h2');
                title.className = 'text-xl font-bold text-gray-800';
                title.textContent = 'Perturbation Test Results';
                header.appendChild(title);
                
                // Perturbation level selector (only if we have data)
                if (this.data && this.data.results && this.data.results.length > 0) {
                    const levelSelectorContainer = document.createElement('div');
                    levelSelectorContainer.className = 'mt-3';
                    
                    const levelLabel = document.createElement('label');
                    levelLabel.className = 'block text-sm font-medium text-gray-700 mb-1';
                    levelLabel.textContent = 'Perturbation Level:';
                    levelSelectorContainer.appendChild(levelLabel);
                    
                    const buttonGroup = document.createElement('div');
                    buttonGroup.className = 'flex space-x-1';
                    
                    this.data.results.forEach(result => {
                        const levelBtn = document.createElement('button');
                        levelBtn.className = `level-btn px-3 py-1 rounded text-sm ${
                            this.state.selectedLevel === result.level
                                ? 'bg-blue-600 text-white'
                                : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                        }`;
                        levelBtn.textContent = `${result.level * 100}%`;
                        levelBtn.dataset.level = result.level;
                        buttonGroup.appendChild(levelBtn);
                    });
                    
                    levelSelectorContainer.appendChild(buttonGroup);
                    header.appendChild(levelSelectorContainer);
                }
                
                // Tabs
                const tabsContainer = document.createElement('div');
                tabsContainer.className = 'mt-3 border-b border-gray-200';
                
                const tabsNav = document.createElement('nav');
                tabsNav.className = '-mb-px flex space-x-8';
                
                const summaryTab = document.createElement('button');
                summaryTab.className = `tab-btn whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
                    this.state.activeTab === 'summary'
                        ? 'border-blue-500 text-blue-600'
                        : 'border-transparent text-gray-500 hover:text-gray-700'
                }`;
                summaryTab.textContent = 'Summary';
                summaryTab.dataset.tab = 'summary';
                tabsNav.appendChild(summaryTab);
                
                const iterationsTab = document.createElement('button');
                iterationsTab.className = `tab-btn whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
                    this.state.activeTab === 'iterations'
                        ? 'border-blue-500 text-blue-600'
                        : 'border-transparent text-gray-500 hover:text-gray-700'
                }`;
                iterationsTab.textContent = 'Iterations';
                iterationsTab.dataset.tab = 'iterations';
                tabsNav.appendChild(iterationsTab);
                
                tabsContainer.appendChild(tabsNav);
                header.appendChild(tabsContainer);
                
                return header;
            } catch (error) {
                console.error("Error creating header:", error);
                return this.createErrorMessage("Error creating header");
            }
        },
        
        // Create summary tab content (wrapper with try-catch)
        createSummaryTab: function() {
            try {
                // Find selected data
                const selectedData = this.data && this.data.results ? 
                    this.data.results.find(r => r.level === this.state.selectedLevel) : null;
                
                if (!selectedData) {
                    return this.createErrorMessage("No data available for selected level");
                }
                
                const summaryTab = document.createElement('div');
                summaryTab.className = 'p-4';
                
                // Feature summaries grid
                const summaryGrid = document.createElement('div');
                summaryGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';
                
                // All Features Summary
                if (selectedData.allFeatures) {
                    summaryGrid.appendChild(this.createFeatureSummary(
                        selectedData.allFeatures, 
                        'allFeatures', 
                        'All Features'
                    ));
                }
                
                // Feature Subset Summary
                if (selectedData.featureSubset) {
                    summaryGrid.appendChild(this.createFeatureSummary(
                        selectedData.featureSubset, 
                        'featureSubset', 
                        'Feature Subset'
                    ));
                }
                
                summaryTab.appendChild(summaryGrid);
                
                // Analysis box
                if (selectedData.allFeatures) {
                    const analysisBox = document.createElement('div');
                    analysisBox.className = 'mt-4 p-4 bg-blue-50 rounded-lg';
                    
                    const analysisTitle = document.createElement('h3');
                    analysisTitle.className = 'font-medium text-blue-800 mb-2';
                    analysisTitle.textContent = 'Analysis';
                    analysisBox.appendChild(analysisTitle);
                    
                    const analysisParagraph = document.createElement('p');
                    analysisParagraph.className = 'text-sm text-blue-700';
                    
                    // Generate analysis text safely
                    let analysisText = `At ${this.state.selectedLevel * 100}% perturbation, the model shows `;
                    if (selectedData.allFeatures.impact < 0) {
                        analysisText += 'improvement ';
                    } else {
                        analysisText += `degradation of ${this.formatNumber(selectedData.allFeatures.impact * 100, 2)}% `;
                    }
                    analysisText += 'when all features are perturbed. ';
                    
                    if (selectedData.featureSubset && selectedData.featureSubset.impact < selectedData.allFeatures.impact) {
                        analysisText += `The feature subset shows better robustness with only ${this.formatNumber(selectedData.featureSubset.impact * 100, 2)}% impact.`;
                    }
                    
                    analysisParagraph.textContent = analysisText;
                    analysisBox.appendChild(analysisParagraph);
                    
                    summaryTab.appendChild(analysisBox);
                }
                
                return summaryTab;
                
            } catch (error) {
                console.error("Error creating summary tab:", error);
                return this.createErrorMessage("Error creating summary tab: " + error.message);
            }
        },
        
        // Create feature summary panel (with added try-catch)
        createFeatureSummary: function(featureData, sectionId, title) {
            try {
                if (!featureData) {
                    return this.createErrorMessage(`No data available for ${title}`);
                }
                
                const summaryPanel = document.createElement('div');
                summaryPanel.className = `border rounded-lg overflow-hidden ${
                    this.state.expandedSection === sectionId ? 'shadow-md' : ''
                }`;
                
                // Header
                const panelHeader = document.createElement('div');
                panelHeader.className = 'section-toggle bg-gray-50 p-3 flex justify-between items-center cursor-pointer';
                panelHeader.dataset.section = sectionId;
                
                const panelTitle = document.createElement('h3');
                panelTitle.className = 'font-medium';
                panelTitle.textContent = title;
                panelHeader.appendChild(panelTitle);
                
                const impactSpan = document.createElement('span');
                impactSpan.className = `text-sm font-semibold ${this.getImpactColorClass(featureData.impact)}`;
                impactSpan.textContent = `Impact: ${this.formatNumber(featureData.impact * 100)}%`;
                panelHeader.appendChild(impactSpan);
                
                summaryPanel.appendChild(panelHeader);
                
                // Content (only if expanded)
                if (this.state.expandedSection === sectionId) {
                    const panelContent = document.createElement('div');
                    panelContent.className = 'p-4';
                    
                    // Stats table
                    const statsTable = document.createElement('table');
                    statsTable.className = 'min-w-full divide-y divide-gray-200';
                    
                    const tbody = document.createElement('tbody');
                    tbody.className = 'divide-y divide-gray-200';
                    
                    // Add rows to the table
                    const rows = [
                        { label: 'Base Score', value: this.formatNumber(featureData.baseScore) },
                        { 
                            label: 'Mean Score',
                            value: this.formatNumber(featureData.meanScore),
                            diff: featureData.meanScore - featureData.baseScore
                        },
                        { 
                            label: 'Worst Score',
                            value: this.formatNumber(featureData.worstScore),
                            diff: featureData.worstScore - featureData.baseScore
                        }
                    ];
                    
                    // Create rows
                    rows.forEach(rowData => {
                        const row = document.createElement('tr');
                        
                        const labelCell = document.createElement('td');
                        labelCell.className = 'px-3 py-2 text-sm font-medium text-gray-900';
                        labelCell.textContent = rowData.label;
                        row.appendChild(labelCell);
                        
                        const valueCell = document.createElement('td');
                        valueCell.className = 'px-3 py-2 text-sm text-gray-700';
                        
                        if (rowData.diff !== undefined) {
                            const valueText = document.createTextNode(rowData.value);
                            valueCell.appendChild(valueText);
                            
                            const diffSpan = document.createElement('span');
                            diffSpan.className = `ml-2 ${rowData.diff >= 0 ? 'text-green-600' : 'text-red-600'}`;
                            diffSpan.textContent = `(${rowData.diff >= 0 ? '+' : ''}${this.formatNumber(rowData.diff * 100, 2)}%)`;
                            valueCell.appendChild(diffSpan);
                        } else {
                            valueCell.textContent = rowData.value;
                        }
                        
                        row.appendChild(valueCell);
                        tbody.appendChild(row);
                    });
                    
                    statsTable.appendChild(tbody);
                    panelContent.appendChild(statsTable);
                    
                    // Impact bar
                    const barContainer = document.createElement('div');
                    barContainer.className = 'mt-3';
                    
                    const barLabels = document.createElement('div');
                    barLabels.className = 'flex justify-between text-xs text-gray-500 mb-1';
                    
                    const startLabel = document.createElement('span');
                    startLabel.textContent = '0% (Base)';
                    barLabels.appendChild(startLabel);
                    
                    const middleLabel = document.createElement('span');
                    middleLabel.textContent = 'Impact';
                    barLabels.appendChild(middleLabel);
                    
                    const endLabel = document.createElement('span');
                    endLabel.textContent = '25%';
                    barLabels.appendChild(endLabel);
                    
                    barContainer.appendChild(barLabels);
                    
                    const barBg = document.createElement('div');
                    barBg.className = 'w-full bg-gray-200 rounded-full h-2.5';
                    
                    const barFill = document.createElement('div');
                    barFill.className = `h-2.5 rounded-full ${featureData.impact < 0 ? 'bg-green-500' : 'bg-red-500'}`;
                    barFill.style.width = `${Math.min(Math.abs(featureData.impact) * 100 * 4, 100)}%`;
                    
                    barBg.appendChild(barFill);
                    barContainer.appendChild(barBg);
                    
                    panelContent.appendChild(barContainer);
                    summaryPanel.appendChild(panelContent);
                }
                
                return summaryPanel;
                
            } catch (error) {
                console.error(`Error creating feature summary for ${title}:`, error);
                return this.createErrorMessage(`Error creating ${title} summary`);
            }
        },
        
        // Create iterations tab with try-catch
        createIterationsTab: function() {
            try {
                // Find selected data
                const selectedData = this.data && this.data.results ? 
                    this.data.results.find(r => r.level === this.state.selectedLevel) : null;
                
                if (!selectedData) {
                    return this.createErrorMessage("No data available for selected level");
                }
                
                const iterationsTab = document.createElement('div');
                iterationsTab.className = 'p-4';
                
                // Simple message if no iterations
                if (!selectedData.allFeatures || !selectedData.allFeatures.iterations || 
                    selectedData.allFeatures.iterations.length === 0) {
                    const noDataMessage = document.createElement('p');
                    noDataMessage.className = 'text-center text-gray-500 my-8';
                    noDataMessage.textContent = 'No iteration data available for this perturbation level.';
                    iterationsTab.appendChild(noDataMessage);
                    return iterationsTab;
                }
                
                // Table container
                const tableContainer = document.createElement('div');
                tableContainer.className = 'overflow-x-auto';
                
                const table = document.createElement('table');
                table.className = 'min-w-full divide-y divide-gray-200';
                
                // Table header
                const thead = document.createElement('thead');
                thead.className = 'bg-gray-50';
                
                const headerRow = document.createElement('tr');
                
                const headers = [
                    { text: 'Iteration', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
                    { text: 'All Features', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
                    { text: 'Feature Subset', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
                    { text: 'Difference', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' }
                ];
                
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.className = header.className;
                    th.textContent = header.text;
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Table body
                const tbody = document.createElement('tbody');
                tbody.className = 'bg-white divide-y divide-gray-200';
                
                // Simple function to handle all output of scores
                const createScoreCell = (score, baseScore, className) => {
                    const cell = document.createElement('td');
                    cell.className = className || 'px-6 py-3 whitespace-nowrap text-sm text-gray-700';
                    
                    if (score === null || score === undefined) {
                        cell.textContent = 'N/A';
                        return cell;
                    }
                    
                    const scoreText = document.createTextNode(this.formatNumber(score));
                    cell.appendChild(scoreText);
                    
                    // Add difference if base score provided
                    if (baseScore !== undefined && baseScore !== null) {
                        const diff = score - baseScore;
                        const diffSpan = document.createElement('span');
                        diffSpan.className = `ml-2 text-xs ${diff >= 0 ? 'text-green-600' : 'text-red-600'}`;
                        diffSpan.textContent = `(${diff >= 0 ? '+' : ''}${this.formatNumber(diff * 100, 2)}%)`;
                        cell.appendChild(diffSpan);
                    }
                    
                    return cell;
                };
                
                // Base score row
                const baseRow = document.createElement('tr');
                baseRow.className = 'bg-gray-100';
                
                const baseIterationCell = document.createElement('td');
                baseIterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
                baseIterationCell.textContent = 'Base';
                baseRow.appendChild(baseIterationCell);
                
                baseRow.appendChild(createScoreCell(
                    selectedData.allFeatures.baseScore, 
                    null,
                    'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900'
                ));
                
                baseRow.appendChild(createScoreCell(
                    selectedData.featureSubset ? selectedData.featureSubset.baseScore : null,
                    null,
                    'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900'
                ));
                
                const baseDifferenceCell = document.createElement('td');
                baseDifferenceCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
                baseDifferenceCell.textContent = '0.0000';
                baseRow.appendChild(baseDifferenceCell);
                
                tbody.appendChild(baseRow);
                
                // Get iteration data
                const allFeaturesIterations = selectedData.allFeatures.iterations || [];
                const featureSubsetIterations = selectedData.featureSubset ? 
                    (selectedData.featureSubset.iterations || []) : [];
                
                const maxIterations = Math.max(allFeaturesIterations.length, featureSubsetIterations.length);
                
                // Create a row for each iteration
                for (let i = 0; i < maxIterations; i++) {
                    const iterationRow = document.createElement('tr');
                    
                    // Iteration number
                    const iterationCell = document.createElement('td');
                    iterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-900';
                    iterationCell.textContent = `#${i + 1}`;
                    iterationRow.appendChild(iterationCell);
                    
                    // All features score
                    const allFeaturesScore = allFeaturesIterations[i] || null;
                    const allFeaturesBaseScore = selectedData.allFeatures.baseScore;
                    iterationRow.appendChild(createScoreCell(
                        allFeaturesScore, 
                        allFeaturesBaseScore,
                        `px-6 py-3 whitespace-nowrap text-sm text-gray-700 ${
                            this.getScoreBgColorClass(allFeaturesScore, allFeaturesBaseScore)
                        }`
                    ));
                    
                    // Feature subset score
                    const featureSubsetScore = featureSubsetIterations[i] || null;
                    const featureSubsetBaseScore = selectedData.featureSubset ? 
                        selectedData.featureSubset.baseScore : null;
                    iterationRow.appendChild(createScoreCell(
                        featureSubsetScore,
                        featureSubsetBaseScore,
                        `px-6 py-3 whitespace-nowrap text-sm text-gray-700 ${
                            this.getScoreBgColorClass(featureSubsetScore, featureSubsetBaseScore)
                        }`
                    ));
                    
                    // Difference between scores
                    if (allFeaturesScore !== null && featureSubsetScore !== null) {
                        const scoreDiff = featureSubsetScore - allFeaturesScore;
                        const differenceCell = document.createElement('td');
                        differenceCell.className = `px-6 py-3 whitespace-nowrap text-sm ${scoreDiff > 0 ? 'text-green-600' : 'text-red-600'}`;
                        differenceCell.textContent = `${scoreDiff > 0 ? '+' : ''}${this.formatNumber(scoreDiff)}`;
                        iterationRow.appendChild(differenceCell);
                    } else {
                        const differenceCell = document.createElement('td');
                        differenceCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-500';
                        differenceCell.textContent = 'N/A';
                        iterationRow.appendChild(differenceCell);
                    }
                    
                    tbody.appendChild(iterationRow);
                }
                
                // Mean row
                if (selectedData.allFeatures.meanScore !== undefined) {
                    const meanRow = document.createElement('tr');
                    meanRow.className = 'bg-gray-100';
                    
                    const meanLabelCell = document.createElement('td');
                    meanLabelCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
                    meanLabelCell.textContent = 'Mean';
                    meanRow.appendChild(meanLabelCell);
                    
                    meanRow.appendChild(createScoreCell(
                        selectedData.allFeatures.meanScore, 
                        null,
                        'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900'
                    ));
                    
                    meanRow.appendChild(createScoreCell(
                        selectedData.featureSubset ? selectedData.featureSubset.meanScore : null,
                        null,
                        'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900'
                    ));
                    
                    if (selectedData.featureSubset && 
                        selectedData.featureSubset.meanScore !== undefined &&
                        selectedData.allFeatures.meanScore !== undefined) {
                        const meanDiff = selectedData.featureSubset.meanScore - selectedData.allFeatures.meanScore;
                        const meanDiffCell = document.createElement('td');
                        meanDiffCell.className = `px-6 py-3 whitespace-nowrap text-sm font-medium ${
                            meanDiff > 0 ? 'text-green-600' : 'text-red-600'
                        }`;
                        meanDiffCell.textContent = `${meanDiff > 0 ? '+' : ''}${this.formatNumber(meanDiff)}`;
                        meanRow.appendChild(meanDiffCell);
                    } else {
                        const meanDiffCell = document.createElement('td');
                        meanDiffCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-500';
                        meanDiffCell.textContent = 'N/A';
                        meanRow.appendChild(meanDiffCell);
                    }
                    
                    tbody.appendChild(meanRow);
                }
                
                table.appendChild(tbody);
                tableContainer.appendChild(table);
                iterationsTab.appendChild(tableContainer);
                
                return iterationsTab;
                
            } catch (error) {
                console.error("Error creating iterations tab:", error);
                return this.createErrorMessage("Error creating iterations tab: " + error.message);
            }
        },
        
        // Create footer with try-catch
        createFooter: function() {
            try {
                const footer = document.createElement('div');
                footer.className = 'p-3 border-t border-gray-200 text-xs text-gray-500';
                
                const footerFlex = document.createElement('div');
                footerFlex.className = 'flex justify-between';
                
                // Left section
                const leftSpan = document.createElement('span');
                if (this.data) {
                    leftSpan.textContent = `Perturbation Test  ${this.data.modelType || 'Model'}  ${this.data.metric || 'Score'} Metric`;
                } else {
                    leftSpan.textContent = 'Perturbation Test';
                }
                footerFlex.appendChild(leftSpan);
                
                // Right section
                const rightSpan = document.createElement('span');
                if (this.data) {
                    rightSpan.textContent = `Base Score: ${this.data.baseScore ? this.formatNumber(this.data.baseScore) : 'N/A'}  Date: ${new Date().toLocaleDateString()}`;
                } else {
                    rightSpan.textContent = `Date: ${new Date().toLocaleDateString()}`;
                }
                footerFlex.appendChild(rightSpan);
                
                footer.appendChild(footerFlex);
                
                return footer;
                
            } catch (error) {
                console.error("Error creating footer:", error);
                const footer = document.createElement('div');
                footer.className = 'p-3 border-t border-gray-200 text-xs text-gray-500';
                footer.textContent = 'Error creating footer';
                return footer;
            }
        }
    };
    
    // Initialize when document is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Check if the container exists
        if (document.getElementById('perturbation-results-container')) {
            // Try to initialize with the safe controller
            try {
                window.SafePerturbationResultsController.init();
                console.log("Safe Perturbation Results Controller initialized");
            } catch (error) {
                console.error("Error initializing SafePerturbationResultsController:", error);
                
                // Create an error message in the container
                const container = document.getElementById('perturbation-results-container');
                if (container) {
                    container.innerHTML = `
                        <div class="p-4 text-center text-red-500 bg-red-50 rounded-lg">
                            <div class="text-2xl mb-2"></div>
                            <h3 class="font-bold">Error Loading Perturbation Results</h3>
                            <p class="mt-2">${error.message || 'An unknown error occurred'}</p>
                        </div>
                    `;
                }
            }
        }
    });
})();

// ----- controllers_PerturbationResultsController ----- //
// PerturbationResultsController.js
const PerturbationResultsController = {
    // Store the extracted data
    data: null,
    
    // Store UI state
    state: {
        selectedLevel: null,
        activeTab: 'summary',
        expandedSection: 'allFeatures'
    },
    
    /**
     * Initialize the controller
     */
    init: function() {
        console.log("Initializing Perturbation Results Controller");
        
        // Extract perturbation data if the manager exists
        if (typeof PerturbationResultsManager !== 'undefined') {
            this.data = PerturbationResultsManager.extractPerturbationData();
            
            // Set initial selected level to middle value if available, otherwise first value
            if (this.data.results.length > 0) {
                const middleIndex = Math.floor(this.data.results.length / 2);
                this.state.selectedLevel = this.data.results[middleIndex].level;
            }
            
            // Render the component
            this.render();
            
            // Initialize event listeners
            this.initEventListeners();
        } else {
            console.error("PerturbationResultsManager not found");
            this.renderError("Unable to extract perturbation data. PerturbationResultsManager not available.");
        }
    },
    
    /**
     * Render the perturbation results UI
     */
    render: function() {
        const container = document.getElementById('perturbation-results-container');
        if (!container) {
            console.error("Perturbation results container not found");
            return;
        }
        
        // Clear container
        container.innerHTML = '';
        
        // Create main container
        const mainDiv = document.createElement('div');
        mainDiv.className = 'bg-white rounded-lg shadow-md overflow-hidden';
        
        // Create header
        mainDiv.appendChild(this.createHeader());
        
        // Create content based on active tab
        if (this.state.activeTab === 'summary') {
            mainDiv.appendChild(this.createSummaryTab());
        } else {
            mainDiv.appendChild(this.createIterationsTab());
        }
        
        // Create footer
        mainDiv.appendChild(this.createFooter());
        
        // Add to container
        container.appendChild(mainDiv);
    },
    
    /**
     * Render an error message
     */
    renderError: function(message) {
        const container = document.getElementById('perturbation-results-container');
        if (!container) {
            console.error("Perturbation results container not found");
            return;
        }
        
        // Clear container
        container.innerHTML = '';
        
        // Create error message
        const errorDiv = document.createElement('div');
        errorDiv.className = 'p-6 text-center text-red-500 bg-red-50 rounded-lg border border-red-200';
        
        const errorIcon = document.createElement('div');
        errorIcon.className = 'text-4xl mb-3';
        errorIcon.innerHTML = '';
        errorDiv.appendChild(errorIcon);
        
        const errorTitle = document.createElement('h3');
        errorTitle.className = 'text-lg font-medium text-red-800 mb-2';
        errorTitle.textContent = 'Error Loading Perturbation Results';
        errorDiv.appendChild(errorTitle);
        
        const errorMessage = document.createElement('p');
        errorMessage.className = 'text-red-600';
        errorMessage.textContent = message || 'An unknown error occurred while loading perturbation data.';
        errorDiv.appendChild(errorMessage);
        
        container.appendChild(errorDiv);
    },
    
    /**
     * Initialize event listeners
     */
    initEventListeners: function() {
        document.addEventListener('click', (event) => {
            // Handle level selection
            if (event.target.classList.contains('level-btn')) {
                const level = parseFloat(event.target.dataset.level);
                this.state.selectedLevel = level;
                this.render();
            }
            
            // Handle tab selection
            if (event.target.classList.contains('tab-btn')) {
                const tab = event.target.dataset.tab;
                this.state.activeTab = tab;
                this.render();
            }
            
            // Handle section toggle
            if (event.target.closest('.section-toggle')) {
                const section = event.target.closest('.section-toggle').dataset.section;
                this.state.expandedSection = this.state.expandedSection === section ? null : section;
                this.render();
            }
        });
    },
    
    /**
     * Create header section
     * @returns {HTMLElement} Header element
     */
    createHeader: function() {
        const header = document.createElement('div');
        header.className = 'p-4 border-b border-gray-200';
        
        // Title
        const title = document.createElement('h2');
        title.className = 'text-xl font-bold text-gray-800';
        title.textContent = 'Perturbation Test Results';
        header.appendChild(title);
        
        // Perturbation level selector
        const levelSelectorContainer = document.createElement('div');
        levelSelectorContainer.className = 'mt-3';
        
        const levelLabel = document.createElement('label');
        levelLabel.className = 'block text-sm font-medium text-gray-700 mb-1';
        levelLabel.textContent = 'Perturbation Level:';
        levelSelectorContainer.appendChild(levelLabel);
        
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'flex space-x-1';
        
        this.data.results.forEach(result => {
            const levelBtn = document.createElement('button');
            levelBtn.className = `level-btn px-3 py-1 rounded text-sm ${
                this.state.selectedLevel === result.level
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-200 hover:bg-gray-300 text-gray-700'
            }`;
            levelBtn.textContent = `${result.level * 100}%`;
            levelBtn.dataset.level = result.level;
            buttonGroup.appendChild(levelBtn);
        });
        
        levelSelectorContainer.appendChild(buttonGroup);
        header.appendChild(levelSelectorContainer);
        
        // Tabs
        const tabsContainer = document.createElement('div');
        tabsContainer.className = 'mt-3 border-b border-gray-200';
        
        const tabsNav = document.createElement('nav');
        tabsNav.className = '-mb-px flex space-x-8';
        
        const summaryTab = document.createElement('button');
        summaryTab.className = `tab-btn whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
            this.state.activeTab === 'summary'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700'
        }`;
        summaryTab.textContent = 'Summary';
        summaryTab.dataset.tab = 'summary';
        tabsNav.appendChild(summaryTab);
        
        const iterationsTab = document.createElement('button');
        iterationsTab.className = `tab-btn whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
            this.state.activeTab === 'iterations'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700'
        }`;
        iterationsTab.textContent = 'Iterations';
        iterationsTab.dataset.tab = 'iterations';
        tabsNav.appendChild(iterationsTab);
        
        tabsContainer.appendChild(tabsNav);
        header.appendChild(tabsContainer);
        
        return header;
    },
    
    /**
     * Create summary tab content
     * @returns {HTMLElement} Summary tab element
     */
    createSummaryTab: function() {
        const selectedData = this.data.results.find(r => r.level === this.state.selectedLevel);
        if (!selectedData) {
            return this.createErrorMessage("No data available for selected level");
        }
        
        const summaryTab = document.createElement('div');
        summaryTab.className = 'p-4';
        
        // Feature summaries grid
        const summaryGrid = document.createElement('div');
        summaryGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';
        
        // All Features Summary
        summaryGrid.appendChild(this.createFeatureSummary(
            selectedData.allFeatures, 
            'allFeatures', 
            'All Features'
        ));
        
        // Feature Subset Summary
        summaryGrid.appendChild(this.createFeatureSummary(
            selectedData.featureSubset, 
            'featureSubset', 
            'Feature Subset'
        ));
        
        summaryTab.appendChild(summaryGrid);
        
        // Analysis box
        const analysisBox = document.createElement('div');
        analysisBox.className = 'mt-4 p-4 bg-blue-50 rounded-lg';
        
        const analysisTitle = document.createElement('h3');
        analysisTitle.className = 'font-medium text-blue-800 mb-2';
        analysisTitle.textContent = 'Analysis';
        analysisBox.appendChild(analysisTitle);
        
        const analysisParagraph = document.createElement('p');
        analysisParagraph.className = 'text-sm text-blue-700';
        
        // Generate analysis text
        let analysisText = `At ${this.state.selectedLevel * 100}% perturbation, the model shows `;
        if (selectedData.allFeatures.impact < 0) {
            analysisText += 'improvement ';
        } else {
            analysisText += `degradation of ${PerturbationResultsManager.formatNumber(selectedData.allFeatures.impact * 100, 2)}% `;
        }
        analysisText += 'when all features are perturbed. ';
        
        if (selectedData.featureSubset.impact < selectedData.allFeatures.impact) {
            analysisText += `The feature subset shows better robustness with only ${PerturbationResultsManager.formatNumber(selectedData.featureSubset.impact * 100, 2)}% impact.`;
        }
        
        analysisParagraph.textContent = analysisText;
        analysisBox.appendChild(analysisParagraph);
        
        summaryTab.appendChild(analysisBox);
        
        return summaryTab;
    },
    
    /**
     * Create feature summary panel
     * @param {Object} featureData - Data for feature type
     * @param {string} sectionId - Section identifier
     * @param {string} title - Section title
     * @returns {HTMLElement} Feature summary element
     */
    createFeatureSummary: function(featureData, sectionId, title) {
        const summaryPanel = document.createElement('div');
        summaryPanel.className = `border rounded-lg overflow-hidden ${
            this.state.expandedSection === sectionId ? 'shadow-md' : ''
        }`;
        
        // Header
        const panelHeader = document.createElement('div');
        panelHeader.className = 'section-toggle bg-gray-50 p-3 flex justify-between items-center cursor-pointer';
        panelHeader.dataset.section = sectionId;
        
        const panelTitle = document.createElement('h3');
        panelTitle.className = 'font-medium';
        panelTitle.textContent = title;
        panelHeader.appendChild(panelTitle);
        
        const impactSpan = document.createElement('span');
        impactSpan.className = `text-sm font-semibold ${PerturbationResultsManager.getImpactColorClass(featureData.impact)}`;
        impactSpan.textContent = `Impact: ${PerturbationResultsManager.formatNumber(featureData.impact * 100)}%`;
        panelHeader.appendChild(impactSpan);
        
        summaryPanel.appendChild(panelHeader);
        
        // Content
        const panelContent = document.createElement('div');
        panelContent.className = `p-4 ${this.state.expandedSection === sectionId ? 'block' : 'hidden'}`;
        
        // Stats table
        const statsTable = document.createElement('table');
        statsTable.className = 'min-w-full divide-y divide-gray-200';
        
        const tbody = document.createElement('tbody');
        tbody.className = 'divide-y divide-gray-200';
        
        // Base Score
        const baseScoreRow = document.createElement('tr');
        
        const baseScoreLabel = document.createElement('td');
        baseScoreLabel.className = 'px-3 py-2 text-sm font-medium text-gray-900';
        baseScoreLabel.textContent = 'Base Score';
        baseScoreRow.appendChild(baseScoreLabel);
        
        const baseScoreValue = document.createElement('td');
        baseScoreValue.className = 'px-3 py-2 text-sm text-gray-700';
        baseScoreValue.textContent = PerturbationResultsManager.formatNumber(featureData.baseScore);
        baseScoreRow.appendChild(baseScoreValue);
        
        tbody.appendChild(baseScoreRow);
        
        // Mean Score
        const meanScoreRow = document.createElement('tr');
        
        const meanScoreLabel = document.createElement('td');
        meanScoreLabel.className = 'px-3 py-2 text-sm font-medium text-gray-900';
        meanScoreLabel.textContent = 'Mean Score';
        meanScoreRow.appendChild(meanScoreLabel);
        
        const meanScoreValue = document.createElement('td');
        meanScoreValue.className = 'px-3 py-2 text-sm text-gray-700';
        
        const meanScoreText = document.createTextNode(
            PerturbationResultsManager.formatNumber(featureData.meanScore)
        );
        meanScoreValue.appendChild(meanScoreText);
        
        const meanScoreDiff = document.createElement('span');
        const diffValue = featureData.meanScore - featureData.baseScore;
        meanScoreDiff.className = `ml-2 ${diffValue >= 0 ? 'text-green-600' : 'text-red-600'}`;
        meanScoreDiff.textContent = `(${diffValue >= 0 ? '+' : ''}${PerturbationResultsManager.formatNumber(diffValue * 100, 2)}%)`;
        meanScoreValue.appendChild(meanScoreDiff);
        
        meanScoreRow.appendChild(meanScoreValue);
        tbody.appendChild(meanScoreRow);
        
        // Worst Score
        const worstScoreRow = document.createElement('tr');
        
        const worstScoreLabel = document.createElement('td');
        worstScoreLabel.className = 'px-3 py-2 text-sm font-medium text-gray-900';
        worstScoreLabel.textContent = 'Worst Score';
        worstScoreRow.appendChild(worstScoreLabel);
        
        const worstScoreValue = document.createElement('td');
        worstScoreValue.className = 'px-3 py-2 text-sm text-red-600';
        
        const worstScoreText = document.createTextNode(
            PerturbationResultsManager.formatNumber(featureData.worstScore)
        );
        worstScoreValue.appendChild(worstScoreText);
        
        const worstScoreDiff = document.createElement('span');
        worstScoreDiff.className = 'ml-2';
        worstScoreDiff.textContent = `(${PerturbationResultsManager.formatNumber((featureData.worstScore - featureData.baseScore) * 100, 2)}%)`;
        worstScoreValue.appendChild(worstScoreDiff);
        
        worstScoreRow.appendChild(worstScoreValue);
        tbody.appendChild(worstScoreRow);
        
        statsTable.appendChild(tbody);
        panelContent.appendChild(statsTable);
        
        // Impact bar
        const barContainer = document.createElement('div');
        barContainer.className = 'mt-3';
        
        const barLabels = document.createElement('div');
        barLabels.className = 'flex justify-between text-xs text-gray-500 mb-1';
        
        const startLabel = document.createElement('span');
        startLabel.textContent = '0% (Base)';
        barLabels.appendChild(startLabel);
        
        const middleLabel = document.createElement('span');
        middleLabel.textContent = 'Impact';
        barLabels.appendChild(middleLabel);
        
        const endLabel = document.createElement('span');
        endLabel.textContent = '25%';
        barLabels.appendChild(endLabel);
        
        barContainer.appendChild(barLabels);
        
        const barBg = document.createElement('div');
        barBg.className = 'w-full bg-gray-200 rounded-full h-2.5';
        
        const barFill = document.createElement('div');
        barFill.className = `h-2.5 rounded-full ${featureData.impact < 0 ? 'bg-green-500' : 'bg-red-500'}`;
        barFill.style.width = `${Math.min(Math.abs(featureData.impact) * 100 * 4, 100)}%`;
        
        barBg.appendChild(barFill);
        barContainer.appendChild(barBg);
        
        panelContent.appendChild(barContainer);
        summaryPanel.appendChild(panelContent);
        
        return summaryPanel;
    },
    
    /**
     * Create iterations tab content
     * @returns {HTMLElement} Iterations tab element
     */
    createIterationsTab: function() {
        const selectedData = this.data.results.find(r => r.level === this.state.selectedLevel);
        if (!selectedData) {
            return this.createErrorMessage("No data available for selected level");
        }
        
        const iterationsTab = document.createElement('div');
        iterationsTab.className = 'p-4';
        
        // Table container
        const tableContainer = document.createElement('div');
        tableContainer.className = 'overflow-x-auto';
        
        const table = document.createElement('table');
        table.className = 'min-w-full divide-y divide-gray-200';
        
        // Table header
        const thead = document.createElement('thead');
        thead.className = 'bg-gray-50';
        
        const headerRow = document.createElement('tr');
        
        const headers = [
            { text: 'Iteration', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
            { text: 'All Features', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
            { text: 'Feature Subset', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' },
            { text: 'Difference', className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' }
        ];
        
        headers.forEach(header => {
            const th = document.createElement('th');
            th.className = header.className;
            th.textContent = header.text;
            headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Table body
        const tbody = document.createElement('tbody');
        tbody.className = 'bg-white divide-y divide-gray-200';
        
        // Base score row
        const baseRow = document.createElement('tr');
        baseRow.className = 'bg-gray-100';
        
        const baseIterationCell = document.createElement('td');
        baseIterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
        baseIterationCell.textContent = 'Base';
        baseRow.appendChild(baseIterationCell);
        
        const baseAllFeaturesCell = document.createElement('td');
        baseAllFeaturesCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        baseAllFeaturesCell.textContent = PerturbationResultsManager.formatNumber(selectedData.allFeatures.baseScore);
        baseRow.appendChild(baseAllFeaturesCell);
        
        const baseFeatureSubsetCell = document.createElement('td');
        baseFeatureSubsetCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        baseFeatureSubsetCell.textContent = PerturbationResultsManager.formatNumber(selectedData.featureSubset.baseScore);
        baseRow.appendChild(baseFeatureSubsetCell);
        
        const baseDifferenceCell = document.createElement('td');
        baseDifferenceCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        baseDifferenceCell.textContent = '0.0000';
        baseRow.appendChild(baseDifferenceCell);
        
        tbody.appendChild(baseRow);
        
        // Iteration rows
        const allFeaturesIterations = selectedData.allFeatures.iterations || [];
        const featureSubsetIterations = selectedData.featureSubset.iterations || [];
        
        const maxIterations = Math.max(allFeaturesIterations.length, featureSubsetIterations.length);
        
        for (let i = 0; i < maxIterations; i++) {
            const iterationRow = document.createElement('tr');
            
            // Iteration number
            const iterationCell = document.createElement('td');
            iterationCell.className = 'px-6 py-3 whitespace-nowrap text-sm text-gray-900';
            iterationCell.textContent = `#${i + 1}`;
            iterationRow.appendChild(iterationCell);
            
            // All features score
            const allFeaturesScore = allFeaturesIterations[i] || selectedData.allFeatures.meanScore;
            const allFeaturesCell = document.createElement('td');
            allFeaturesCell.className = `px-6 py-3 whitespace-nowrap text-sm text-gray-700 ${
                PerturbationResultsManager.getScoreBgColorClass(allFeaturesScore, selectedData.allFeatures.baseScore)
            }`;
            
            const allFeaturesScoreText = document.createTextNode(
                PerturbationResultsManager.formatNumber(allFeaturesScore)
            );
            allFeaturesCell.appendChild(allFeaturesScoreText);
            
            const allFeaturesDiff = allFeaturesScore - selectedData.allFeatures.baseScore;
            const allFeaturesDiffSpan = document.createElement('span');
            allFeaturesDiffSpan.className = `ml-2 text-xs ${allFeaturesDiff >= 0 ? 'text-green-600' : 'text-red-600'}`;
            allFeaturesDiffSpan.textContent = `(${allFeaturesDiff >= 0 ? '+' : ''}${PerturbationResultsManager.formatNumber(allFeaturesDiff * 100, 2)}%)`;
            allFeaturesCell.appendChild(allFeaturesDiffSpan);
            
            iterationRow.appendChild(allFeaturesCell);
            
            // Feature subset score
            const featureSubsetScore = featureSubsetIterations[i] || selectedData.featureSubset.meanScore;
            const featureSubsetCell = document.createElement('td');
            featureSubsetCell.className = `px-6 py-3 whitespace-nowrap text-sm text-gray-700 ${
                PerturbationResultsManager.getScoreBgColorClass(featureSubsetScore, selectedData.featureSubset.baseScore)
            }`;
            
            const featureSubsetScoreText = document.createTextNode(
                PerturbationResultsManager.formatNumber(featureSubsetScore)
            );
            featureSubsetCell.appendChild(featureSubsetScoreText);
            
            const featureSubsetDiff = featureSubsetScore - selectedData.featureSubset.baseScore;
            const featureSubsetDiffSpan = document.createElement('span');
            featureSubsetDiffSpan.className = `ml-2 text-xs ${featureSubsetDiff >= 0 ? 'text-green-600' : 'text-red-600'}`;
            featureSubsetDiffSpan.textContent = `(${featureSubsetDiff >= 0 ? '+' : ''}${PerturbationResultsManager.formatNumber(featureSubsetDiff * 100, 2)}%)`;
            featureSubsetCell.appendChild(featureSubsetDiffSpan);
            
            iterationRow.appendChild(featureSubsetCell);
            
            // Difference between scores
            const scoreDiff = featureSubsetScore - allFeaturesScore;
            const differenceCell = document.createElement('td');
            differenceCell.className = `px-6 py-3 whitespace-nowrap text-sm ${scoreDiff > 0 ? 'text-green-600' : 'text-red-600'}`;
            differenceCell.textContent = `${scoreDiff > 0 ? '+' : ''}${PerturbationResultsManager.formatNumber(scoreDiff)}`;
            
            iterationRow.appendChild(differenceCell);
            
            tbody.appendChild(iterationRow);
        }
        
        // Mean row
        const meanRow = document.createElement('tr');
        meanRow.className = 'bg-gray-100';
        
        const meanLabelCell = document.createElement('td');
        meanLabelCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900';
        meanLabelCell.textContent = 'Mean';
        meanRow.appendChild(meanLabelCell);
        
        const allFeaturesMeanCell = document.createElement('td');
        allFeaturesMeanCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        allFeaturesMeanCell.textContent = PerturbationResultsManager.formatNumber(selectedData.allFeatures.meanScore);
        meanRow.appendChild(allFeaturesMeanCell);
        
        const featureSubsetMeanCell = document.createElement('td');
        featureSubsetMeanCell.className = 'px-6 py-3 whitespace-nowrap text-sm font-medium text-gray-900';
        featureSubsetMeanCell.textContent = PerturbationResultsManager.formatNumber(selectedData.featureSubset.meanScore);
        meanRow.appendChild(featureSubsetMeanCell);
        
        const meanDiffCell = document.createElement('td');
        const meanDiff = selectedData.featureSubset.meanScore - selectedData.allFeatures.meanScore;
        meanDiffCell.className = `px-6 py-3 whitespace-nowrap text-sm font-medium ${
            meanDiff > 0 ? 'text-green-600' : 'text-red-600'
        }`;
        meanDiffCell.textContent = `${meanDiff > 0 ? '+' : ''}${PerturbationResultsManager.formatNumber(meanDiff)}`;
        meanRow.appendChild(meanDiffCell);
        
        tbody.appendChild(meanRow);
        table.appendChild(tbody);
        tableContainer.appendChild(table);
        iterationsTab.appendChild(tableContainer);
        
        // Additional stats
        const statsGrid = document.createElement('div');
        statsGrid.className = 'mt-4 grid grid-cols-1 md:grid-cols-2 gap-4';
        
        // Worst performance
        const worstPerformanceDiv = document.createElement('div');
        worstPerformanceDiv.className = 'p-3 bg-yellow-50 rounded-lg';
        
        const worstPerfTitle = document.createElement('h3');
        worstPerfTitle.className = 'font-medium text-yellow-800 mb-1';
        worstPerfTitle.textContent = 'Worst Performance';
        worstPerformanceDiv.appendChild(worstPerfTitle);
        
        const allFeaturesWorst = document.createElement('p');
        allFeaturesWorst.className = 'text-sm text-yellow-700';
        allFeaturesWorst.innerHTML = `All Features: ${PerturbationResultsManager.formatNumber(selectedData.allFeatures.worstScore)} 
            <span class="ml-1">
                (${PerturbationResultsManager.formatNumber((selectedData.allFeatures.worstScore - selectedData.allFeatures.baseScore) * 100, 2)}%)
            </span>`;
        worstPerformanceDiv.appendChild(allFeaturesWorst);
        
        const featureSubsetWorst = document.createElement('p');
        featureSubsetWorst.className = 'text-sm text-yellow-700';
        featureSubsetWorst.innerHTML = `Feature Subset: ${PerturbationResultsManager.formatNumber(selectedData.featureSubset.worstScore)}
            <span class="ml-1">
                (${PerturbationResultsManager.formatNumber((selectedData.featureSubset.worstScore - selectedData.featureSubset.baseScore) * 100, 2)}%)
            </span>`;
        worstPerformanceDiv.appendChild(featureSubsetWorst);
        
        statsGrid.appendChild(worstPerformanceDiv);
        
        // Standard deviation
        const stdDevDiv = document.createElement('div');
        stdDevDiv.className = 'p-3 bg-blue-50 rounded-lg';
        
        const stdDevTitle = document.createElement('h3');
        stdDevTitle.className = 'font-medium text-blue-800 mb-1';
        stdDevTitle.textContent = 'Standard Deviation';
        stdDevDiv.appendChild(stdDevTitle);
        
        // Calculate standard deviations
        const calculateStdDev = (scores, mean) => {
            if (!scores || scores.length === 0) return 0;
            const squaredDiffs = scores.map(score => Math.pow(score - mean, 2));
            const variance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / scores.length;
            return Math.sqrt(variance);
        };
        
        const allFeaturesStdDev = calculateStdDev(
            selectedData.allFeatures.iterations,
            selectedData.allFeatures.meanScore
        );
        
        const featureSubsetStdDev = calculateStdDev(
            selectedData.featureSubset.iterations,
            selectedData.featureSubset.meanScore
        );
        
        const allFeaturesStdDevP = document.createElement('p');
        allFeaturesStdDevP.className = 'text-sm text-blue-700';
        allFeaturesStdDevP.textContent = `All Features: ${PerturbationResultsManager.formatNumber(allFeaturesStdDev)}`;
        stdDevDiv.appendChild(allFeaturesStdDevP);
        
        const featureSubsetStdDevP = document.createElement('p');
        featureSubsetStdDevP.className = 'text-sm text-blue-700';
        featureSubsetStdDevP.textContent = `Feature Subset: ${PerturbationResultsManager.formatNumber(featureSubsetStdDev)}`;
        stdDevDiv.appendChild(featureSubsetStdDevP);
        
        statsGrid.appendChild(stdDevDiv);
        iterationsTab.appendChild(statsGrid);
        
        return iterationsTab;
    },
    
    /**
     * Create footer section
     * @returns {HTMLElement} Footer element
     */
    createFooter: function() {
        const footer = document.createElement('div');
        footer.className = 'p-3 border-t border-gray-200 text-xs text-gray-500';
        
        const footerFlex = document.createElement('div');
        footerFlex.className = 'flex justify-between';
        
        const leftSpan = document.createElement('span');
        leftSpan.textContent = `Perturbation Test  ${this.data.modelType}  ${this.data.metric} Metric`;
        footerFlex.appendChild(leftSpan);
        
        const rightSpan = document.createElement('span');
        rightSpan.textContent = `Base Score: ${PerturbationResultsManager.formatNumber(this.data.baseScore)}  Date: ${new Date().toLocaleDateString()}`;
        footerFlex.appendChild(rightSpan);
        
        footer.appendChild(footerFlex);
        
        return footer;
    },
    
    /**
     * Create error message
     * @param {string} message - Error message to display
     * @returns {HTMLElement} Error message element
     */
    createErrorMessage: function(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'p-8 text-center text-red-500';
        errorDiv.textContent = message || 'An error occurred loading perturbation data';
        return errorDiv;
    }
};

// ----- controllers_features ----- //
/**
 * Feature Importance Controller
 * Handles feature importance visualization and data management
 */
window.FeatureImportanceController = {
    /**
     * Initialize the controller
     */
    init: function() {
        console.log("FeatureImportanceController initialized");
        
        // Initialize the feature importance table
        this.initializeFeatureTable();
        
        // Set up event listeners for feature table interactions
        this.setupTableEvents();
        
        // Initialize feature charts when tab is active
        document.addEventListener('tabchange', (event) => {
            if (event.detail && event.detail.tabId === 'feature_impact') {
                console.log("Feature impact tab activated");
                this.refreshFeatureData();
            }
        });
    },
    
    /**
     * Initialize the feature importance table
     */
    initializeFeatureTable: function() {
        console.log("Initializing feature importance table");
        this.fillFeatureImportanceTable();
        
        // Update feature counts
        this.updateFeatureCounts();
    },
    
    /**
     * Set up event listeners for table interactions
     */
    setupTableEvents: function() {
        // Sort table when headers are clicked
        const headers = document.querySelectorAll('.feature-importance-table th.sortable');
        if (headers.length > 0) {
            headers.forEach(header => {
                header.addEventListener('click', (e) => {
                    const sortBy = e.currentTarget.getAttribute('data-sort');
                    this.sortTable(sortBy);
                });
            });
        }
        
        // Search feature table
        const searchInput = document.getElementById('feature-search');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                this.filterTable();
            });
        }
        
        // Toggle feature subset display
        const subsetToggle = document.getElementById('show-subset-only');
        if (subsetToggle) {
            subsetToggle.addEventListener('change', (e) => {
                this.filterTable();
            });
        }
    },
    
    /**
     * Fill the feature importance table with data
     */
    fillFeatureImportanceTable: function() {
        console.log("Filling feature importance table");
        
        // Get feature data from the table manager
        const featureData = FeatureImportanceTableManager.extractFeatureData();
        
        if (featureData.length === 0) {
            console.warn("No feature importance data available");
            this.showNoDataMessage();
            return;
        }
        
        // Sort by default column (impact/robustness)
        const sortedData = FeatureImportanceTableManager.sortData(featureData, 'impact', 'desc');
        
        // Generate table HTML
        const tableHTML = FeatureImportanceTableManager.generateTableRows(sortedData);
        
        // Update table content
        const tableBody = document.getElementById('feature-impact-data');
        if (tableBody) {
            tableBody.innerHTML = tableHTML;
        }
        
        // Log success
        console.log(`Feature table populated with ${featureData.length} features`);
    },
    
    /**
     * Show a message when no data is available
     */
    showNoDataMessage: function() {
        const tableBody = document.getElementById('feature-impact-data');
        if (tableBody) {
            tableBody.innerHTML = FeatureImportanceTableManager.generateNoDataMessage();
        }
    },
    
    /**
     * Sort the feature table by the specified column
     * @param {string} sortBy - Column to sort by
     */
    sortTable: function(sortBy) {
        // Reset sort indicators on all header cells
        document.querySelectorAll('.feature-importance-table th.sortable .sort-indicator')
            .forEach(indicator => indicator.textContent = '');
        
        // Set sort indicator on active column
        const activeHeader = document.querySelector(`.feature-importance-table th[data-sort="${sortBy}"]`);
        if (activeHeader) {
            activeHeader.querySelector('.sort-indicator').textContent = '';
        }
        
        // Get and sort feature data
        const featureData = FeatureImportanceTableManager.extractFeatureData();
        const sortedData = FeatureImportanceTableManager.sortData(featureData, sortBy, 'desc');
        
        // Generate and update table HTML
        const tableBody = document.getElementById('feature-impact-data');
        if (tableBody) {
            tableBody.innerHTML = FeatureImportanceTableManager.generateTableRows(sortedData);
        }
        
        console.log(`Table sorted by ${sortBy}`);
    },
    
    /**
     * Filter the feature table by search term and subset option
     */
    filterTable: function() {
        const searchTerm = document.getElementById('feature-search').value;
        const showOnlySubset = document.getElementById('show-subset-only').checked;
        
        // Get feature data
        const featureData = FeatureImportanceTableManager.extractFeatureData();
        
        // Filter data
        const filteredData = FeatureImportanceTableManager.filterData(featureData, searchTerm, showOnlySubset);
        
        // Get current sort column
        const activeHeader = document.querySelector('.feature-importance-table th.sortable .sort-indicator');
        const sortBy = activeHeader && activeHeader.parentElement.getAttribute('data-sort') || 'impact';
        
        // Sort filtered data
        const sortedData = FeatureImportanceTableManager.sortData(filteredData, sortBy, 'desc');
        
        // Update table
        const tableBody = document.getElementById('feature-impact-data');
        if (tableBody) {
            tableBody.innerHTML = FeatureImportanceTableManager.generateTableRows(sortedData);
        }
        
        console.log(`Table filtered with ${filteredData.length} of ${featureData.length} features visible`);
        
        // Update feature counts to reflect filtered data
        this.updateFeatureCountsWithData(filteredData, featureData);
    },
    
    /**
     * Update feature count displays in the UI
     */
    updateFeatureCounts: function() {
        const featureData = FeatureImportanceTableManager.extractFeatureData();
        this.updateFeatureCountsWithData(featureData, featureData);
    },
    
    /**
     * Update feature count displays with specific data
     * @param {Array} visibleData - Currently visible feature data
     * @param {Array} totalData - All feature data
     */
    updateFeatureCountsWithData: function(visibleData, totalData) {
        const totalFeaturesElement = document.getElementById('total-features-count');
        const subsetFeaturesElement = document.getElementById('subset-features-count');
        
        if (totalFeaturesElement) {
            totalFeaturesElement.textContent = visibleData.length;
        }
        
        if (subsetFeaturesElement) {
            const subsetCount = visibleData.filter(item => item.inSubset).length;
            subsetFeaturesElement.textContent = subsetCount;
        }
    },
    
    /**
     * Refresh feature data and update visualizations
     */
    refreshFeatureData: function() {
        // Reinitialize table with fresh data
        this.fillFeatureImportanceTable();
        
        // Also refresh charts if needed
        if (typeof window.ChartInitializer !== 'undefined' && 
            typeof window.ChartInitializer.initializeFeatureCharts === 'function') {
            window.ChartInitializer.initializeFeatureCharts();
        }
    }
};

// Manual initialization to ensure it runs
document.addEventListener('DOMContentLoaded', function() {
    // Delay initialization slightly to ensure other dependencies are loaded
    setTimeout(function() {
        if (typeof FeatureImportanceController !== 'undefined' && 
            typeof FeatureImportanceController.init === 'function') {
            FeatureImportanceController.init();
        }
    }, 100);
});

// ----- controllers_overview ----- //
// Overview Controller
const OverviewController = {
    init: function() {
        console.log("Overview section initialized");
        
        // Initialize chart selector
        this.initChartSelector('performance_charts_selector', '.performance-charts-container .chart-container');
        
        // Initialize model comparison selector if it exists
        this.initChartSelector('model_comparison_selector', '.model-comparison-section .chart-container');
        
        // Initialize tabs in overview
        this.initResultTabs();
        
        // Initialize charts immediately
        this.initCharts();
    },
    
    initChartSelector: function(selectorId, containerSelector) {
        const chartSelector = document.getElementById(selectorId);
        if (!chartSelector) return;
        
        const options = chartSelector.querySelectorAll('.chart-selector-option');
        options.forEach(option => {
            option.addEventListener('click', function() {
                // Remove active from all options
                options.forEach(opt => opt.classList.remove('active'));
                
                // Add active to clicked option
                this.classList.add('active');
                
                // Show corresponding chart
                const chartType = this.getAttribute('data-chart-type');
                const containers = document.querySelectorAll(containerSelector);
                
                containers.forEach(chart => {
                    chart.classList.remove('active');
                });
                
                const targetChart = document.querySelector(`${containerSelector}[data-chart-type="${chartType}"]`);
                if (targetChart) {
                    targetChart.classList.add('active');
                }
            });
        });
    },
    
    initResultTabs: function() {
        const resultTabsContainer = document.getElementById('result_tables_tabs');
        if (!resultTabsContainer) return;
        
        const tabButtons = resultTabsContainer.querySelectorAll('.tab');
        tabButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Remove active class from all buttons
                tabButtons.forEach(btn => btn.classList.remove('active'));
                
                // Add active class to clicked button
                this.classList.add('active');
                
                // Hide all tab contents
                const tabContents = document.querySelectorAll('.results-tables-section .tab-content');
                tabContents.forEach(content => content.classList.remove('active'));
                
                // Show target tab content
                const targetId = this.getAttribute('data-tab');
                const targetContent = document.getElementById(targetId);
                if (targetContent) {
                    targetContent.classList.add('active');
                }
            });
        });
    },
    
    initCharts: function() {
        console.log("Initializing overview charts");
        
        // Try to initialize all charts
        setTimeout(() => {
            if (typeof Plotly !== 'undefined') {
                this.initializePerturbationChart();
                this.initializeWorstScoreChart();
                // Mean Performance chart removed
                
                // Initialize model comparison charts if available
                // Verificar se temos modelos alternativos de qualquer forma
                const hasAlternativeModels = (window.reportConfig && window.reportConfig.hasAlternativeModels) || 
                                          (window.reportData && window.reportData.alternative_models && 
                                           Object.keys(window.reportData.alternative_models).length > 0);
                
                console.log("Verificao de modelos alternativos:", {
                    "reportConfig.hasAlternativeModels": window.reportConfig?.hasAlternativeModels,
                    "Has alternative_models in data": !!(window.reportData?.alternative_models),
                    "alternative_models keys": window.reportData?.alternative_models ? Object.keys(window.reportData.alternative_models) : [],
                    "Final hasAlternativeModels": hasAlternativeModels
                });
                
                if (hasAlternativeModels) {
                    console.log("Inicializando grficos de comparao de modelos");
                    // Forar a configurao para indicar que temos modelos alternativos
                    if (window.reportConfig) {
                        window.reportConfig.hasAlternativeModels = true;
                    } else {
                        window.reportConfig = { hasAlternativeModels: true };
                    }
                    
                    this.initializeModelComparisonChart();
                    this.initializeModelLevelDetailsChart();
                    this.populateModelComparisonTable();
                } else {
                    console.log("No h modelos alternativos para comparao");
                }
                
                // Fill the perturbation tables
                this.fillPerturbationTables();
            } else {
                this.showChartError();
            }
        }, 500);
    },
    
    showChartError: function() {
        const chartContainers = document.querySelectorAll('.chart-plot');
        chartContainers.forEach(container => {
            container.innerHTML = "<div style='padding: 20px; text-align: center; color: red;'>Plotly library not loaded. Charts cannot be displayed.</div>";
        });
    },
    
    fillPerturbationTables: function() {
        // Fill the raw perturbation table
        try {
            const rawTableBody = document.getElementById('raw-perturbation-data');
            if (!rawTableBody) return;
            
            // Clear existing content
            rawTableBody.innerHTML = '';
            
            if (window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
                const rawData = window.reportData.raw.by_level;
                const levels = Object.keys(rawData).sort((a, b) => parseFloat(a) - parseFloat(b));
                
                let baseScore = window.reportData.base_score || 0;
                
                // Criar um mapeamento de todos os scores de feature_subset disponveis para referncia rpida
                const featureSubsetScoresByLevel = {};
                Object.keys(rawData).forEach(levelStr => {
                    if (rawData[levelStr]?.overall_result?.feature_subset?.mean_score !== undefined) {
                        featureSubsetScoresByLevel[levelStr] = rawData[levelStr].overall_result.feature_subset.mean_score;
                    }
                });
                
                console.log("Tabela - Scores de feature subset coletados:", featureSubsetScoresByLevel);
                
                levels.forEach(level => {
                    if (rawData[level] && rawData[level].overall_result) {
                        const result = rawData[level].overall_result;
                        let levelData;
                        
                        if (result.all_features) {
                            levelData = result.all_features;
                        } else if (result.feature_subset) {
                            levelData = result.feature_subset;
                        } else {
                            return; // Skip if no data
                        }
                        
                        const row = document.createElement('tr');
                        
                        // Level
                        const levelCell = document.createElement('td');
                        levelCell.textContent = level;
                        row.appendChild(levelCell);
                        
                        // Base score
                        const baseScoreCell = document.createElement('td');
                        baseScoreCell.textContent = baseScore.toFixed(3);
                        row.appendChild(baseScoreCell);
                        
                        // Perturbed score
                        const perturbedScoreCell = document.createElement('td');
                        perturbedScoreCell.textContent = levelData.mean_score ? levelData.mean_score.toFixed(3) : 'N/A';
                        row.appendChild(perturbedScoreCell);
                        
                        // Impact
                        const impactCell = document.createElement('td');
                        impactCell.textContent = levelData.impact ? (levelData.impact * 100).toFixed(2) + '%' : 'N/A';
                        row.appendChild(impactCell);
                        
                        // Subset score instead of worst score
                        const subsetScoreCell = document.createElement('td');
                        // Get feature subset score if available
                        let subsetScore = 'N/A';
                        
                        // Usar o mapeamento que criamos para ter acesso rpido e consistente aos scores
                        if (featureSubsetScoresByLevel[level] !== undefined) {
                            console.log(`Tabela: Usando score mapeado para nvel ${level}:`, featureSubsetScoresByLevel[level]);
                            subsetScore = featureSubsetScoresByLevel[level].toFixed(3);
                        } else {
                            // Tenta encontrar o score de feature subset em diferentes lugares possveis
                            if (result.feature_subset && result.feature_subset.mean_score !== undefined) {
                                console.log(`Tabela: Encontrado feature_subset.mean_score para nvel ${level}:`, result.feature_subset.mean_score);
                                subsetScore = result.feature_subset.mean_score.toFixed(3);
                            } else if (result.subset_features && result.subset_features.mean_score !== undefined) {
                                console.log(`Tabela: Encontrado subset_features.mean_score para nvel ${level}:`, result.subset_features.mean_score);
                                subsetScore = result.subset_features.mean_score.toFixed(3);
                            } else if (result.all_features && result.all_features.subset_score !== undefined) {
                                console.log(`Tabela: Encontrado all_features.subset_score para nvel ${level}:`, result.all_features.subset_score);
                                subsetScore = result.all_features.subset_score.toFixed(3);
                            } else if (levelData.mean_subset_score !== undefined) {
                                console.log(`Tabela: Encontrado mean_subset_score para nvel ${level}:`, levelData.mean_subset_score);
                                subsetScore = levelData.mean_subset_score.toFixed(3);
                            } else if (levelData.subset_score !== undefined) {
                                console.log(`Tabela: Encontrado subset_score para nvel ${level}:`, levelData.subset_score);
                                subsetScore = levelData.subset_score.toFixed(3);
                            } else {
                                console.log(`Tabela: Sem score de feature subset vlido para nvel ${level}`);
                                // No usaremos scores sintticos, mostramos N/A em vez disso
                            }
                        }
                        
                        subsetScoreCell.textContent = subsetScore;
                        row.appendChild(subsetScoreCell);
                        
                        rawTableBody.appendChild(row);
                    }
                });
            }
        } catch (error) {
            console.error("Error filling perturbation tables:", error);
        }
    },
    
    // Chart initialization methods would be here (moved to charts/overview.js)
    initializePerturbationChart: function() {
        // Verificar a estrutura dos dados antes de inicializar o grfico
        if (window.reportData && window.reportData.raw && window.reportData.raw.by_level) {
            console.log("Estrutura dos dados raw.by_level:", Object.keys(window.reportData.raw.by_level));
            
            // Verificar a estrutura para o primeiro nvel
            const firstLevel = Object.keys(window.reportData.raw.by_level)[0];
            if (firstLevel) {
                console.log(`Estrutura para nvel ${firstLevel}:`, 
                            window.reportData.raw.by_level[firstLevel].overall_result);
                
                // Verificar se temos feature_subset
                if (window.reportData.raw.by_level[firstLevel].overall_result.feature_subset) {
                    console.log(`feature_subset para nvel ${firstLevel}:`, 
                                window.reportData.raw.by_level[firstLevel].overall_result.feature_subset);
                }
            }
        }
        
        // Inicializar o grfico
        ChartManager.initializePerturbationChart('perturbation-chart-plot');
    },
    
    initializeWorstScoreChart: function() {
        ChartManager.initializeWorstScoreChart('worst-score-chart-plot');
    },
    
    // Mean Score chart function removed
    
    initializeModelComparisonChart: function() {
        ChartManager.initializeModelComparisonChart('model-comparison-chart-plot');
    },
    
    initializeModelLevelDetailsChart: function() {
        ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
    },
    
    populateModelComparisonTable: function() {
        const tableBody = document.getElementById('model-comparison-table')?.querySelector('tbody');
        if (!tableBody) return;
        
        try {
            // Clear existing content
            tableBody.innerHTML = '';
            
            // Check if we have alternative models data
            if (!window.reportData || !window.reportConfig || !window.reportConfig.hasAlternativeModels) {
                this.showNoModelComparisonDataMessage(tableBody);
                return;
            }
            
            // Get model data
            const models = this.extractModelComparisonData();
            
            if (models.length === 0) {
                this.showNoModelComparisonDataMessage(tableBody);
                return;
            }
            
            // Sort models by robustness score
            models.sort((a, b) => b.robustnessScore - a.robustnessScore);
            
            // Add a row for each model
            models.forEach(model => {
                const row = document.createElement('tr');
                
                // Model name
                const nameCell = document.createElement('td');
                nameCell.textContent = model.name;
                
                // Base score
                const baseScoreCell = document.createElement('td');
                baseScoreCell.textContent = model.baseScore.toFixed(3);
                
                // Robustness score - calculate correctly as 1.0 - rawImpact
                const robustnessScoreCell = document.createElement('td');
                let robustnessScoreValue;
                
                // First try to use the actual robustness_score if available
                if (typeof model.robustnessScore === 'number' && model.robustnessScore >= 0 && model.robustnessScore <= 1) {
                    robustnessScoreValue = model.robustnessScore;
                } else {
                    // If not available or invalid, calculate it from rawImpact
                    robustnessScoreValue = Math.max(0, Math.min(1, 1.0 - model.rawImpact));
                }
                
                robustnessScoreCell.textContent = robustnessScoreValue.toFixed(3);
                
                // Raw impact - ensure it's a percentage 
                const rawImpactCell = document.createElement('td');
                // Ensure rawImpact is between 0 and 1 for percentage calculation
                const rawImpactValue = typeof model.rawImpact === 'number' ? 
                    Math.max(0, Math.min(1, model.rawImpact)) : 0;
                
                rawImpactCell.textContent = (rawImpactValue * 100).toFixed(2) + '%';
                
                row.appendChild(nameCell);
                row.appendChild(baseScoreCell);
                row.appendChild(robustnessScoreCell);
                row.appendChild(rawImpactCell);
                
                tableBody.appendChild(row);
            });
            
        } catch (error) {
            console.error("Error populating model comparison table:", error);
            this.showErrorMessage(tableBody);
        }
    },
    
    showNoModelComparisonDataMessage: function(tableBody) {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 4;
        cell.innerHTML = `
            <div class="no-data-message">
                <p><strong>No model comparison data available</strong></p>
                <p>Run robustness test with compare() method to see model comparison data.</p>
            </div>
        `;
        cell.style.textAlign = 'center';
        row.appendChild(cell);
        tableBody.appendChild(row);
    },
    
    showErrorMessage: function(tableBody) {
        tableBody.innerHTML = '';
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 4;
        cell.textContent = 'Error loading model comparison data';
        cell.style.textAlign = 'center';
        cell.style.color = 'red';
        row.appendChild(cell);
        tableBody.appendChild(row);
    },
    
    extractModelComparisonData: function() {
        const models = [];
        
        // Add primary model
        let primaryModelName = 'Primary Model';
        let primaryModelData = null;
        
        if (window.reportData.primary_model) {
            primaryModelData = window.reportData.primary_model;
            primaryModelName = primaryModelData.model_name || window.reportConfig.modelName || 'Primary Model';
        } else {
            // Primary model data is at the top level
            primaryModelData = window.reportData;
            primaryModelName = window.reportConfig.modelName || 'Primary Model';
        }
        
        if (primaryModelData) {
            // CORREO: Garantir que usamos os valores corretos do robustness_score
            // Se o valor estiver presente diretamente em primaryModelData, use-o
            let robustnessScore = 0;
            if (typeof primaryModelData.robustness_score === 'number') {
                robustnessScore = primaryModelData.robustness_score;
                console.log("Usando robustness_score do modelo primrio:", robustnessScore);
            } else if (window.reportConfig && typeof window.reportConfig.robustnessScore === 'number') {
                robustnessScore = window.reportConfig.robustnessScore;
                console.log("Usando robustnessScore do reportConfig:", robustnessScore);
            }
            
            models.push({
                name: primaryModelName,
                baseScore: primaryModelData.base_score || 0,
                robustnessScore: robustnessScore,
                rawImpact: primaryModelData.avg_raw_impact || window.reportConfig.rawImpact || 0,
                quantileImpact: primaryModelData.avg_quantile_impact || window.reportConfig.quantileImpact || 0
            });
        }
        
        // Add alternative models
        if (window.reportData.alternative_models) {
            Object.entries(window.reportData.alternative_models).forEach(([name, data]) => {
                // CORREO: Garantir que usamos os valores corretos do robustness_score para modelos alternativos
                const altScore = typeof data.robustness_score === 'number' ? data.robustness_score : 0;
                console.log(`Modelo alternativo ${name} robustness_score:`, altScore);
                
                models.push({
                    name: name,
                    baseScore: data.base_score || 0,
                    robustnessScore: altScore,
                    rawImpact: data.avg_raw_impact || 0,
                    quantileImpact: data.avg_quantile_impact || 0
                });
            });
        }
        
        return models;
    }
};

// ----- importance_comparison_handler ----- //
// Importance Comparison Handler
// This is a standalone script that handles the importance comparison visualization

(function() {
    // Create the handler
    window.ImportanceComparisonHandler = {
        /**
         * Initialize the importance comparison visualization
         */
        initialize: function() {
            console.log("Initializing importance comparison handler");
            
            try {
                // Initialize the importance comparison chart
                this.initializeImportanceComparisonChart();
                
                console.log("Importance comparison handler initialized");
            } catch (error) {
                console.error("Error initializing importance comparison handler:", error);
            }
        },
        
        /**
         * Initialize the importance comparison chart using Plotly
         */
        initializeImportanceComparisonChart: function() {
            try {
                const chartContainer = document.getElementById('importance-comparison-chart-plot');
                if (!chartContainer) return;
                
                // Get feature importance data
                const chartData = this.extractImportanceComparisonData();
                if (!chartData || !chartData.features || chartData.features.length === 0) {
                    this.showNoDataMessage(chartContainer, "No feature importance comparison data available");
                    return;
                }
                
                // Create chart
                this.renderImportanceComparisonChart(chartContainer, chartData);
            } catch (error) {
                console.error("Error initializing importance comparison chart:", error);
                const container = document.getElementById('importance-comparison-chart-plot');
                if (container) {
                    this.showErrorMessage(container, "Error initializing chart: " + error.message);
                }
            }
        },
        
        /**
         * Extract importance comparison data from report data
         * @returns {Object} Importance comparison data
         */
        extractImportanceComparisonData: function() {
            try {
                // Try to get data from various sources
                let featureImportance = {};
                let modelFeatureImportance = {};
                
                if (window.reportConfig && window.reportConfig.feature_importance) {
                    featureImportance = window.reportConfig.feature_importance || {};
                    modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                } 
                else if (window.reportData) {
                    if (window.reportData.feature_importance) {
                        featureImportance = window.reportData.feature_importance;
                        modelFeatureImportance = window.reportData.model_feature_importance || {};
                    }
                }
                
                // If no data is available, create some demo data
                if (Object.keys(featureImportance).length === 0) {
                    featureImportance = {
                        'age': 0.4287,
                        'income': 0.3521,
                        'credit_score': 0.2943,
                        'employment_years': 0.2105,
                        'debt_ratio': 0.1876,
                        'num_loans': -0.1542,
                        'num_credit_lines': -0.1238,
                        'payment_history': 0.1105,
                        'loan_amount': -0.0956,
                        'interest_rate': 0.0847
                    };
                    
                    modelFeatureImportance = {
                        'age': 0.7648,
                        'income': 0.6892,
                        'credit_score': 0.5423,
                        'employment_years': 0.4936,
                        'debt_ratio': 0.4123,
                        'num_loans': 0.3856,
                        'num_credit_lines': 0.3421,
                        'payment_history': 0.3012,
                        'loan_amount': 0.2893,
                        'interest_rate': 0.2541
                    };
                }
                
                // Convert to arrays for plotting
                const featureArray = [];
                for (const feature in featureImportance) {
                    // Only add if both values are available
                    if (modelFeatureImportance[feature] !== undefined) {
                        featureArray.push({
                            name: feature,
                            robustness: featureImportance[feature],
                            model: modelFeatureImportance[feature]
                        });
                    }
                }
                
                // Sort by model importance
                featureArray.sort((a, b) => b.model - a.model);
                
                // Get top features
                const topFeatures = featureArray.slice(0, 10);
                
                
        try {
            return {
                    features: topFeatures.map(f => f.name),
                    robustnessValues: topFeatures.map(f => f.robustness),
                    modelValues: topFeatures.map(f => f.model)
                };
        } catch (error) {
            console.error('Error in model comparison data extraction:', error);
            return window.__safeFallbackObject;
        }

            } catch (error) {
                console.error("Error extracting importance comparison data:", error);
                return null;
            }
        },
        
        /**
         * Render importance comparison chart using Plotly
         * @param {HTMLElement} container - Chart container element
         * @param {Object} chartData - Chart data object
         */
        renderImportanceComparisonChart: function(container, chartData) {
            try {
                // Verify Plotly is available
                if (typeof Plotly === 'undefined') {
                    this.showErrorMessage(container, "Plotly library not available");
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                // Verificar se j existe um grfico e remov-lo completamente
                Plotly.purge(container);
                
                // Criar grfico de disperso (o primeiro estilo que aparece)
                // Este  um estilo de grfico diferente que mostra a correlao
                // entre a importncia do modelo e o impacto de robustez
                
                // Preparar dados para o grfico de disperso
                const scatterData = chartData.features.map((feature, index) => {
                    return {
                        feature,
                        model: chartData.modelValues[index], 
                        robustness: chartData.robustnessValues[index]
                    };
                });
                
                // Criar trace de disperso
                const scatterTrace = {
                    x: chartData.modelValues,
                    y: chartData.robustnessValues,
                    mode: 'markers+text',
                    type: 'scatter',
                    text: chartData.features,
                    textposition: 'top center',
                    textfont: {
                        family: 'Arial, sans-serif',
                        size: 10,
                        color: 'rgba(0, 0, 0, 0.7)'
                    },
                    marker: {
                        size: 12,
                        color: 'rgba(93, 109, 235, 0.8)',
                        line: {
                            color: 'rgba(0, 0, 0, 0.5)',
                            width: 1
                        }
                    },
                    name: 'Features'
                };
                
                // Criar linha de referncia diagonal (onde model importance = robustness impact)
                // Encontrar valores mnimos e mximos para os eixos
                const allValues = [...chartData.modelValues, ...chartData.robustnessValues];
                const minVal = Math.min(...allValues.filter(v => !isNaN(v)));
                const maxVal = Math.max(...allValues.filter(v => !isNaN(v)));
                
                const refLine = {
                    x: [minVal, maxVal],
                    y: [minVal, maxVal],
                    mode: 'lines',
                    type: 'scatter',
                    line: {
                        color: 'rgba(200, 200, 200, 0.5)',
                        dash: 'dash',
                        width: 1
                    },
                    showlegend: false
                };
                
                // Layout para grfico de disperso
                const layout = {
                    title: 'Model Importance vs Robustness Impact',
                    xaxis: {
                        title: 'Model Importance',
                        zeroline: true
                    },
                    yaxis: {
                        title: 'Robustness Impact',
                        zeroline: true
                    },
                    hovermode: 'closest',
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    },
                    margin: {
                        l: 60,
                        r: 20,
                        t: 60,
                        b: 80
                    },
                    annotations: [{
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.02,
                        y: 0.98,
                        text: 'Features above line: higher robustness impact than model importance',
                        showarrow: false,
                        font: {
                            size: 12,
                            color: 'rgba(0, 0, 0, 0.6)'
                        }
                    }]
                };
                
                // Create plot with scatter chart and reference line
                Plotly.newPlot(container, [scatterTrace, refLine], layout, {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtons: [[
                        'zoom2d', 
                        'pan2d', 
                        'resetScale2d', 
                        'toImage'
                    ]]
                });
                
                console.log("Importance comparison chart rendered successfully");
            } catch (error) {
                console.error("Error rendering importance comparison chart:", error);
                this.showErrorMessage(container, "Error rendering chart: " + error.message);
            }
        },
        
        /**
         * Show no data message in container
         * @param {HTMLElement} container - Container element
         * @param {string} message - Message to display
         */
        showNoDataMessage: function(container, message) {
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #f8f9fa; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">No Data Available</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.4;">
                        ${message}
                    </p>
                </div>`;
        },
        
        /**
         * Show error message in container
         * @param {HTMLElement} container - Container element
         * @param {string} errorMessage - Error message to display
         */
        showErrorMessage: function(container, errorMessage) {
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                </div>`;
        }
    };
    
    // Initialize when document is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize after a small delay to ensure everything is loaded
        setTimeout(function() {
            if (document.getElementById('importance-comparison-chart-plot')) {
                window.ImportanceComparisonHandler.initialize();
            }
        }, 500);
    });
})();

// ----- syntax_fixer ----- //
// JavaScript Syntax Fixer
// This script applies runtime fixes for common JavaScript syntax errors
// Include this script in the <head> of your HTML document before any other scripts

(function() {
    // Define our safe return object - this will be available for any other script
    window.__safeFallbackObject = {
        levels: [],
        modelScores: {},
        modelNames: {},
        metricName: ""
    };
    
    // Fix trailing commas in JavaScript object literals at runtime
    function fixTrailingCommas() {
        console.log("Running syntax fixer to fix trailing commas");
        
        // Find all script tags
        const scripts = document.querySelectorAll('script:not([src])');
        
        // Process each inline script
        for (const script of scripts) {
            if (!script.textContent) {
                // Usando if/else ao invs de continue
                continue;
            }
            
            let content = script.textContent;
            let needsReplacement = false;
            
            // Fix 1: Trailing commas in object literals - matches a return statement with an object that ends with a comma
            if (content.includes('return {') && 
                (content.includes('metricName,') || 
                 content.includes('robustnessScores,') || 
                 content.includes('baseScores,'))) {
                
                // First fix: return { ...  } pattern
                const fixedContent1 = content.replace(/return\s*\{\s*[\s\S]*?,(\s*\})/g, 'return $1');
                
                // Second fix: specific variable pattern for model data extraction
                const fixedContent2 = fixedContent1.replace(
                    /(return\s*\{\s*)(levels,\s*modelScores,\s*modelNames,\s*metricName),(\s*\})/g, 
                    '$1$2$3'
                );
                
                // Third fix: specific variable pattern for model comparison data
                const fixedContent3 = fixedContent2.replace(
                    /(return\s*\{\s*)(models,\s*baseScores,\s*robustnessScores),(\s*\})/g, 
                    '$1$2$3'
                );
                
                // Check if any fixes were applied
                if (content !== fixedContent3) {
                    content = fixedContent3;
                    needsReplacement = true;
                    console.log("Fixed trailing commas in return statements");
                }
            }
            
            // Fix 2: Any comma before closing brace
            if (content.includes('},') || content.includes(' }')) {
                const fixedContent = content.replace(/,(\s*\})/g, '$1');
                
                if (content !== fixedContent) {
                    content = fixedContent;
                    needsReplacement = true;
                    console.log("Fixed generic trailing commas");
                }
            }
            
            // Fix 3: Replace illegal continue statements with return null or early returns
            // Este  um ponto comum de erro em callbacks de map() ou em funes de callback internas
            if (content.includes('continue')) {
                
                // Primeiro, verificar por 'continue' dentro de funes map(), forEach(), e filter()
                if (content.includes('map(') || content.includes('forEach(') || content.includes('filter(')) {
                    // Procurar por padres de 'continue' fora de loops que precisam ser substitudos em callbacks
                    const fixedContent = content.replace(
                        /if\s*\([^)]*\)\s*\{\s*[^{}]*continue;\s*\}/g, 
                        function(match) {
                            // Substituir 'continue' por 'return null' dentro do callback de map
                            return match.replace(/continue;/, 'return null;');
                        }
                    );
                    
                    if (content !== fixedContent) {
                        content = fixedContent;
                        needsReplacement = true;
                        console.log("Fixed illegal continue statements in callbacks");
                    }
                }
                
                // Segundo, verificar por qualquer 'continue' em funes de callback inline
                const fixedContent2 = content.replace(
                    /function\s*\([^)]*\)\s*\{(?:[^{}]|{[^{}]*})*continue;(?:[^{}]|{[^{}]*})*\}/g,
                    function(match) {
                        // Substituir 'continue' por 'return null' dentro de funes
                        return match.replace(/continue;/, 'return null;');
                    }
                );
                
                if (content !== fixedContent2) {
                    content = fixedContent2;
                    needsReplacement = true;
                    console.log("Fixed illegal continue statements in inline functions");
                }
                
                // Terceiro, verificar por qualquer 'continue' imediatamente aps if, sem estar em um loop
                const fixedContent3 = content.replace(
                    /if\s*\([^)]*\)\s*continue;(?!\s*\})/g,
                    function(match) {
                        // Substituir 'continue' por 'return null' ou 'return'
                        if (content.includes('map(') || content.includes('filter(')) {
                            return match.replace(/continue;/, 'return null;');
                        } else if (content.includes('forEach(')) {
                            return match.replace(/continue;/, 'return;');
                        } else {
                            return match.replace(/continue;/, '{ /* skip */ }');
                        }
                    }
                );
                
                if (content !== fixedContent3) {
                    content = fixedContent3;
                    needsReplacement = true;
                    console.log("Fixed standalone illegal continue statements");
                }
            }
            
            // Replace the script if needed
            if (needsReplacement) {
                try {
                    const newScript = document.createElement('script');
                    newScript.textContent = content;
                    script.parentNode.replaceChild(newScript, script);
                    console.log("Replaced script with fixed version");
                } catch (error) {
                    console.error("Error replacing script:", error);
                }
            }
        }
    }
    
    // Add error handling for specific JavaScript errors
    function addErrorHandling() {
        window.addEventListener('error', function(event) {
            // Verificar especificamente por erro de continue ilegal
            if (event.error && 
                (event.error.toString().includes("Unexpected token") || 
                 event.error.toString().includes("Illegal continue") ||
                 event.error.toString().includes("no surrounding iteration statement"))) {
                
                console.warn("Caught syntax error:", event.error);
                
                // Try to monkeypatch global objects after error
                if (typeof window.ChartManager !== 'undefined') {
                    console.log("Adding safe fallbacks for ChartManager");
                    
                    // Add safe version of extractModelLevelDetailsData
                    if (typeof window.ChartManager.extractModelLevelDetailsData === 'function') {
                        window.ChartManager.extractModelLevelDetailsData = function() {
                            console.log("Using safe replacement for extractModelLevelDetailsData");
                            return {
                                levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                                modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                                modelNames: { 'primary': 'Primary Model' },
                                metricName: 'Score'
                            };
                        };
                    }
                    
                    // Add safe version of extractModelComparisonData
                    if (typeof window.ChartManager.extractModelComparisonData === 'function') {
                        window.ChartManager.extractModelComparisonData = function() {
                            console.log("Using safe replacement for extractModelComparisonData");
                            return {
                                models: ['Primary Model', 'Alternative Model 1'],
                                baseScores: [0.8, 0.75],
                                robustnessScores: [0.7, 0.65]
                            };
                        };
                    }
                    
                    // Add safe version of extractPerturbationChartData
                    if (typeof window.ChartManager.extractPerturbationChartData === 'function') {
                        window.ChartManager.extractPerturbationChartData = function() {
                            console.log("Using safe replacement for extractPerturbationChartData");
                            return {
                                levels: [0, 0.1, 0.2, 0.3, 0.4, 0.5],
                                perturbedScores: [0.9, 0.85, 0.8, 0.75, 0.7, 0.65],
                                worstScores: [0.85, 0.8, 0.75, 0.7, 0.65, 0.6],
                                featureSubsetScores: [0.9, 0.87, 0.84, 0.81, 0.78, 0.75],
                                featureSubsetWorstScores: [0.85, 0.82, 0.79, 0.76, 0.73, 0.7],
                                baseScore: 0.9,
                                metricName: 'Score'
                            };
                        };
                    }
                }
                
                // Verificar ModelComparisonManager
                if (typeof window.ModelComparisonManager !== 'undefined') {
                    if (typeof window.ModelComparisonManager.generatePerturbationScores === 'function') {
                        window.ModelComparisonManager.generatePerturbationScores = function(levels) {
                            console.log("Using safe replacement for generatePerturbationScores");
                            const scores = {};
                            Object.keys(this.state.modelData || {}).forEach(key => {
                                scores[key] = levels.map(l => 0.9 - (l * 0.2));
                            });
                            return scores;
                        };
                    }
                }
                
                // Prevent the error from propagating
                event.preventDefault();
            }
        }, true);
    }
    
    // Run the fixes when the DOM is ready
    function runFixes() {
        console.log("Running JavaScript syntax fixes");
        
        // Fix scripts in the current DOM
        fixTrailingCommas();
        
        // Add error handling
        addErrorHandling();
        
        // Carregar script adicional de correo
        try {
            // Carrega o script fixed_syntax.js com correes especficas
            // Marcar como de alta prioridade para carregar antes de outros scripts
            const fixedSyntaxScript = document.createElement('script');
            fixedSyntaxScript.src = 'js/fixed_syntax.js';
            fixedSyntaxScript.async = false;
            fixedSyntaxScript.defer = false;
            
            // Usar atributo de prioridade para navegadores modernos
            fixedSyntaxScript.setAttribute('fetchpriority', 'high');
            
            // Adicionar ao incio do head para ser um dos primeiros a ser carregado
            document.head.insertBefore(fixedSyntaxScript, document.head.firstChild);
            console.log("Loaded additional syntax fixes from fixed_syntax.js with high priority");
            
            // Carregar tambm os scripts corretivos para arquivos especficos
            const safePatchesScript = document.createElement('script');
            safePatchesScript.src = 'js/safe_chart_manager.js';
            safePatchesScript.async = false;
            document.head.insertBefore(safePatchesScript, document.head.firstChild.nextSibling);
            console.log("Loaded safe_chart_manager.js with high priority");
            
            const modelFixScript = document.createElement('script');
            modelFixScript.src = 'js/model_chart_fix.js';
            modelFixScript.async = false;
            document.head.insertBefore(modelFixScript, document.head.firstChild.nextSibling.nextSibling);
            console.log("Loaded model_chart_fix.js with high priority");
        } catch (error) {
            console.error("Error loading syntax fix scripts:", error);
        }
        
        // Setup MutationObserver to fix dynamically added scripts
        const observer = new MutationObserver(function(mutations) {
            // Check if any scripts were added
            let scriptAdded = false;
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.tagName === 'SCRIPT') {
                            scriptAdded = true;
                        } else if (node.querySelectorAll) {
                            const scripts = node.querySelectorAll('script');
                            if (scripts.length > 0) {
                                scriptAdded = true;
                            }
                        }
                    });
                }
            });
            
            // If scripts were added, run the fixer again
            if (scriptAdded) {
                console.log("New scripts detected, running fixes");
                fixTrailingCommas();
            }
        });
        
        // Start observing the document
        observer.observe(document, {
            childList: true,
            subtree: true
        });
    }
    
    // Run fixes when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', runFixes);
    } else {
        runFixes();
    }
})();

// ----- patches ----- //
/**
 * Patches for report bug fixes
 * Contains fixes for JavaScript errors in generated reports
 * Updated: May 7, 2024 - Added fix for "Details by Level" chart
 */

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log("Loading JavaScript patches for robustness report");
    
    // Fix variable scope issues with model chart initialization
    window.fixModelChartScope = function() {
        // If we have the ModelComparisonChartManager function that's causing issues
        if (typeof ModelComparisonChartManager !== 'undefined') {
            console.log("Fixing model comparison chart scope");
            
            // Override the problematic function to fix the scope issue
            const originalExtract = ModelComparisonChartManager.extractModelComparisonData;
            ModelComparisonChartManager.extractModelComparisonData = function() {
                try {
                    // Call the original function but wrap in try/catch
                    return originalExtract.call(this);
                } catch (error) {
                    console.error("Error in extractModelComparisonData, using fallback:", error);
                    // Return minimal valid data structure to prevent JS errors
                    return {
                        levels: [],
                        modelScores: {},
                        modelNames: {},
                        metricName: "unknown"
                    };
                }
            };
        }
    };
    
    // Fix feature importance data issues
    window.fixFeatureImportanceData = function() {
        // Add safeguards for feature importance data
        if (window.reportData && window.reportData.feature_importance) {
            console.log("Normalizing feature importance data");
            
            // Ensure all feature keys use consistent format
            const normalizedFeatures = {};
            const normalizedModelFeatures = {};
            
            // Helper function to normalize keys
            function normalizeKey(key) {
                return String(key).trim();
            }
            
            // Normalize feature importance data
            Object.keys(window.reportData.feature_importance).forEach(function(key) {
                const normalizedKey = normalizeKey(key);
                normalizedFeatures[normalizedKey] = window.reportData.feature_importance[key];
            });
            
            // Normalize model feature importance if available
            if (window.reportData.model_feature_importance) {
                Object.keys(window.reportData.model_feature_importance).forEach(function(key) {
                    const normalizedKey = normalizeKey(key);
                    normalizedModelFeatures[normalizedKey] = window.reportData.model_feature_importance[key];
                });
            }
            
            // Replace with normalized data
            window.reportData.feature_importance = normalizedFeatures;
            if (Object.keys(normalizedModelFeatures).length > 0) {
                window.reportData.model_feature_importance = normalizedModelFeatures;
            }
            
            console.log("Feature importance data normalized");
        }
    };
    
    // Fix for "Model Comparison > Details by Level" chart
    window.fixModelLevelDetailsChart = function() {
        console.log("Applying fix for 'Details by Level' chart");
        
        // Ensure ChartManager has the best extract function loaded
        if (window.ChartManager && typeof window.SafeModelComparisonChartManager !== 'undefined' && 
            typeof window.SafeModelComparisonChartManager.extractModelLevelDetailsData === 'function') {
            
            console.log("Replacing ChartManager.extractModelLevelDetailsData with safe version");
            // Use the improved safe version from model_chart_fix.js
            window.ChartManager.extractModelLevelDetailsData = window.SafeModelComparisonChartManager.extractModelLevelDetailsData;
            
            // Add event listener to reinitialize chart when "Details by Level" tab is clicked
            const detailsSelector = document.querySelector('#model_comparison_selector [data-chart-type="details"]');
            if (detailsSelector) {
                console.log("Adding click listener to 'Details by Level' selector");
                detailsSelector.addEventListener('click', function() {
                    // Reinitialize chart with a small delay to ensure DOM updates
                    setTimeout(function() {
                        const chartElement = document.getElementById('model-level-details-chart-plot');
                        if (chartElement && chartElement.innerHTML.includes('No Data Available')) {
                            console.log("'No Data Available' message detected, reinitializing chart");
                            if (typeof ChartManager.initializeModelLevelDetailsChart === 'function') {
                                ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
                            }
                        }
                    }, 300);
                });
            }
            
            // Check if overview tab is active, and if so, initialize model details chart
            setTimeout(function() {
                const overviewTab = document.getElementById('overview');
                if (overviewTab && overviewTab.classList.contains('active')) {
                    const modelDetailChart = document.getElementById('model-level-details-chart-plot');
                    if (modelDetailChart && modelDetailChart.innerHTML.includes('No Data Available')) {
                        console.log("Overview tab active, initializing model details chart");
                        if (typeof ChartManager.initializeModelLevelDetailsChart === 'function') {
                            console.log("Forced initialization of model level details chart");
                            ChartManager.initializeModelLevelDetailsChart('model-level-details-chart-plot');
                        }
                    }
                }
            }, 1000); // Longer delay for initial page load
        } else {
            console.warn("Unable to fix model level details chart - required components not available");
        }
    };
    
    // Fix for initializing the details tab
    window.fixDetailsTabInitialization = function() {
        console.log("Setting up details tab initialization");
        
        // Listen for tab changes to initialize details tab content
        document.addEventListener('tabChange', function(e) {
            if (e.detail && e.detail.tabId === 'details') {
                console.log("Details tab activated");
                
                // Initialize the OverviewController if not already initialized
                if (typeof window.OverviewController !== 'undefined' && 
                    typeof window.OverviewController.init === 'function') {
                    console.log("Initializing OverviewController for details tab");
                    window.OverviewController.init();
                }
                
                // Initialize the radar chart
                if (typeof window.OverviewChartsManager !== 'undefined' && 
                    typeof window.OverviewChartsManager.initializeOverviewCharts === 'function') {
                    console.log("Initializing OverviewChartsManager radar chart");
                    window.OverviewChartsManager.initializeOverviewCharts();
                }
            }
        });
        
        // Add click listener to the details tab link
        const detailsTab = document.querySelector('.main-nav a[data-tab="details"]');
        if (detailsTab) {
            detailsTab.addEventListener('click', function() {
                console.log("Details tab clicked");
                // Handle any additional initialization for details tab
            });
        }
    };
    
    // Apply all patches
    try {
        window.fixModelChartScope();
        window.fixFeatureImportanceData();
        window.fixModelLevelDetailsChart();
        window.fixDetailsTabInitialization();
        console.log("All patches applied successfully");
    } catch (error) {
        console.error("Error applying patches:", error);
    }
});

// ----- fix_boxplot ----- //
/**
 * Custom boxplot initialization to ensure real data is used
 * Fixes issue where boxplot shows synthetic data instead of actual perturbed scores
 * Version 1.3.0 - Fixed caching issue for model comparison visualization
 * Last Updated: May 7, 2024
 */

// Clear marker in console to identify version
console.log(" Loading Boxplot Fix Script v1.3.0 - Updated May 7");

// Initialize boxplot when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log(" Initializing fixed boxplot chart v1.3.0");
    initializeBoxplotChart();
    
    // Remove the "loading" message immediately
    const loadingMessage = document.querySelector('.chart-loading-message');
    if (loadingMessage) {
        loadingMessage.style.display = 'none';
    }
});

/**
 * Extract iteration scores directly from raw data
 * This function ensures we're getting the actual test scores from the robustness tests
 * @returns {object} Extracted boxplot data
 */
function extractRealBoxplotData() {
    console.log("Extracting real boxplot data from raw results");
    
    const models = [];
    let allScores = [];
    
    // First check if we have processed boxplot data
    if (window.reportData && window.reportData.boxplot_data && window.reportData.boxplot_data.models) {
        console.log("Using server-prepared boxplot data");
        
        // Use the pre-processed data from the server
        // Make sure each model has scores to display boxplots
        const processedModels = window.reportData.boxplot_data.models.map(model => {
            // If model has no scores, generate synthetic ones
            if (!model.scores || model.scores.length === 0) {
                console.log(`Model ${model.name} has no scores, generating synthetic ones`);
                model.scores = generateSyntheticScores(model.baseScore || 0.8, 0.05, 20);
            }
            return model;
        });
        
        return {
            models: processedModels,
            allScores: processedModels.flatMap(m => m.scores || [])
        };
    }
    
    console.log("No pre-processed boxplot data found, extracting from raw results");
    
    if (!window.reportData || !window.reportData.raw || !window.reportData.raw.by_level) {
        console.warn("No raw data available for boxplot extraction");
        return null;
    }
    
    // Get metric name
    const metricName = window.reportData.metric || 'Score';
    console.log(`Using metric: ${metricName}`);
    
    // Extract primary model data
    const primaryModelData = {
        name: window.reportData.model_name || 'Primary Model',
        modelType: window.reportData.model_type || 'Unknown',
        baseScore: window.reportData.base_score || 0,
        scores: []
    };
    
    // Extract iteration scores from each perturbation level
    const rawData = window.reportData.raw.by_level;
    Object.keys(rawData).forEach(level => {
        const levelData = rawData[level];
        
        if (!levelData.runs || !levelData.runs.all_features) {
            console.log(`Level ${level}: No runs data found`);
            return;
        }
        
        // Extract scores from all runs at this level
        levelData.runs.all_features.forEach(run => {
            if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                console.log(`Level ${level}: Found ${run.iterations.scores.length} iteration scores`);
                primaryModelData.scores.push(...run.iterations.scores);
            }
        });
    });
    
    console.log(`Primary model: extracted ${primaryModelData.scores.length} total scores`);
    
    // Se no temos scores reais para o modelo primrio, no gerar dados sintticos
    if (primaryModelData.scores.length === 0) {
        console.error("Nenhum score real encontrado para o modelo primrio. No sero gerados dados sintticos.");
        // Mantemos o array vazio - sem dados sintticos
    }
    
    models.push(primaryModelData);
    allScores.push(...primaryModelData.scores);
    if (primaryModelData.baseScore) allScores.push(primaryModelData.baseScore);
    
    // Extract alternative models data
    if (window.reportData.alternative_models) {
        console.log("Processing alternative models:", Object.keys(window.reportData.alternative_models));
        
        Object.keys(window.reportData.alternative_models).forEach(modelName => {
            const modelData = window.reportData.alternative_models[modelName];
            console.log(`Processing alternative model ${modelName}, data keys:`, Object.keys(modelData));
            
            const altModelData = {
                name: modelName,
                modelType: modelData.model_type || 'Unknown',
                baseScore: modelData.base_score || 0,
                scores: []
            };
            
            // First try to extract from perturbation_chart_data if available
            if (window.reportData.perturbation_chart_data && 
                window.reportData.perturbation_chart_data.alternativeModels && 
                window.reportData.perturbation_chart_data.alternativeModels[modelName]) {
                
                const chartModel = window.reportData.perturbation_chart_data.alternativeModels[modelName];
                console.log(`Found model ${modelName} in perturbation_chart_data with scores:`, chartModel.scores?.length || 0);
                
                if (chartModel.scores && chartModel.scores.length > 0) {
                    // Use scores directly from perturbation chart data
                    altModelData.scores = [...chartModel.scores];
                    console.log(`Using ${altModelData.scores.length} scores from perturbation_chart_data for ${modelName}`);
                }
            }
            
            // If no scores yet, try to extract from raw data
            if (altModelData.scores.length === 0 && modelData.raw && modelData.raw.by_level) {
                console.log(`Extracting scores from raw data for ${modelName}`);
                console.log(`Raw data levels:`, Object.keys(modelData.raw.by_level));
                
                Object.keys(modelData.raw.by_level).forEach(level => {
                    const levelData = modelData.raw.by_level[level];
                    console.log(`Level ${level} data keys:`, Object.keys(levelData));
                    
                    // Try to extract from runs.all_features first
                    if (levelData.runs && levelData.runs.all_features) {
                        console.log(`Found runs.all_features for level ${level}`);
                        
                        levelData.runs.all_features.forEach(run => {
                            if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                                console.log(`Found ${run.iterations.scores.length} iteration scores in level ${level}`);
                                altModelData.scores.push(...run.iterations.scores);
                            } else {
                                console.log(`No iterations.scores in run for level ${level}`);
                            }
                        });
                    } else {
                        console.log(`No runs.all_features found for level ${level}`);
                    }
                    
                    // If no scores from iterations, try to use the score from overall_result
                    if (levelData.overall_result && levelData.overall_result.all_features) {
                        const score = levelData.overall_result.all_features.mean_score;
                        if (score !== undefined) {
                            console.log(`Using mean_score ${score} from overall_result for level ${level}`);
                            altModelData.scores.push(score);
                        }
                    }
                });
            }
            
            console.log(`Alternative model ${modelName}: extracted ${altModelData.scores.length} scores`);
            
            // Se no h scores para o modelo alternativo, mostrar erro e no gerar dados sintticos
            if (altModelData.scores.length === 0) {
                console.error(`Nenhum score encontrado para o modelo alternativo ${modelName}. No sero gerados dados sintticos.`);
                // Mantemos o array vazio - sem dados sintticos
            }
            
            models.push(altModelData);
            allScores.push(...altModelData.scores);
            if (altModelData.baseScore) allScores.push(altModelData.baseScore);
        });
    }
    
    // Se no houver modelos com scores, no gerar dados sintticos
    if (models.length === 0 || !models.some(m => m.scores && m.scores.length > 0)) {
        console.error("Nenhum modelo com scores foi encontrado. No sero criados dados sintticos.");
        return null;
    }
    
    console.log(`Total: ${models.length} models with ${allScores.length} scores`);
    return { models, allScores, metricName };
}

// Removemos a funo de gerao de dados sintticos
// Todos os dados devem ser reais, sem valores sintticos

/**
 * Initialize and render the boxplot chart
 */
function initializeBoxplotChart() {
    const container = document.getElementById('boxplot-chart-container');
    if (!container) {
        console.error("Boxplot container not found");
        return;
    }
    
    // Make sure Plotly is available
    if (typeof Plotly === 'undefined') {
        console.log("Loading Plotly.js from CDN");
        const script = document.createElement('script');
        script.src = 'https://cdn.plot.ly/plotly-2.29.1.min.js';
        script.onload = function() {
            console.log("Plotly loaded, rendering boxplot");
            renderBoxplotChart();
        };
        document.head.appendChild(script);
        return;
    }
    
    renderBoxplotChart();
}

/**
 * Render the boxplot chart with real data
 */
function renderBoxplotChart() {
    const container = document.getElementById('boxplot-chart-container');
    if (!container) return;
    
    // Clear the container first to remove any loading messages
    container.innerHTML = '';
    
    // Extract real boxplot data
    const boxplotData = extractRealBoxplotData();
    
    if (!boxplotData || !boxplotData.models || boxplotData.models.length === 0) {
        console.error("No h dados disponveis para o boxplot");
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados no disponveis</h3>
                <p style="color: #333; font-size: 16px; line-height: 1.4;">No foi possvel encontrar dados de iteraes reais para o boxplot.</p>
                <p style="color: #333; margin-top: 20px; font-size: 14px;">Execute testes de robustez com <code>n_iterations > 1</code> para gerar dados de distribuio para o boxplot.</p>
            </div>`;
        return;
    }
    
    // Verifica se algum modelo tem scores
    const hasModelWithScores = boxplotData.models.some(model => model.scores && model.scores.length > 0);
    if (!hasModelWithScores) {
        console.error("Nenhum modelo possui scores disponveis para o boxplot");
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Nenhum modelo com scores</h3>
                <p style="color: #333; font-size: 16px; line-height: 1.4;">Foram encontrados modelos, mas nenhum deles possui scores para visualizao.</p>
                <p style="color: #333; margin-top: 20px; font-size: 14px;">Verifique se os testes foram executados com <code>n_iterations > 1</code>.</p>
            </div>`;
        return;
    }
    
    const models = boxplotData.models;
    
    // Dump perturbation_chart_data to console for debugging
    if (window.reportData && window.reportData.perturbation_chart_data) {
        console.log("Available perturbation_chart_data:", window.reportData.perturbation_chart_data);
        
        if (window.reportData.perturbation_chart_data.alternativeModels) {
            console.log("Alternative models in perturbation_chart_data:", 
                        Object.keys(window.reportData.perturbation_chart_data.alternativeModels));
            
            // Log details about each alternative model
            Object.keys(window.reportData.perturbation_chart_data.alternativeModels).forEach(model => {
                const modelData = window.reportData.perturbation_chart_data.alternativeModels[model];
                console.log(`Model ${model} details:`, {
                    baseScore: modelData.baseScore,
                    hasScores: !!modelData.scores,
                    scoreCount: modelData.scores?.length || 0,
                    hasWorstScores: !!modelData.worstScores,
                    worstScoreCount: modelData.worstScores?.length || 0
                });
            });
        } else {
            console.log("No alternativeModels in perturbation_chart_data");
        }
    }
    
    // Consistent color scheme for models - with fallback colors
    const modelColors = {
        'Primary Model': 'rgba(31, 119, 180, 0.7)',  // Blue
        'primary_model': 'rgba(31, 119, 180, 0.7)',  // Blue
        'GLM_CLASSIFIER': 'rgba(255, 127, 14, 0.7)', // Orange
        'GAM_CLASSIFIER': 'rgba(44, 160, 44, 0.7)',  // Green
        'GBM': 'rgba(214, 39, 40, 0.7)',             // Red
        'XGB': 'rgba(148, 103, 189, 0.7)',           // Purple
        'RANDOM_FOREST': 'rgba(140, 86, 75, 0.7)',   // Brown
        'SVM': 'rgba(227, 119, 194, 0.7)',           // Pink
        'NEURAL_NETWORK': 'rgba(127, 127, 127, 0.7)' // Gray
    };
    
    // Make sure we have at least one model
    if (models.length === 0) {
        console.error("No models available for boxplot");
        return;
    }
    
    // CHANGED: Now using a single plotData array with one trace per model
    const plotData = [];
    
    // Sort models to ensure consistent order in visualization
    models.sort((a, b) => {
        // Primary model always comes first
        if (a.name === 'Primary Model' || a.name === window.reportData?.model_name) return -1;
        if (b.name === 'Primary Model' || b.name === window.reportData?.model_name) return 1;
        // Otherwise sort alphabetically
        return a.name.localeCompare(b.name);
    });
    
    console.log(`Sorted models order: ${models.map(m => m.name).join(', ')}`);
    
    // CHANGED: Models go on X-axis now
    models.forEach((model, index) => {
        // Replace ALL underscores in model name, not just the first one
        const displayName = model.name.replace(/_/g, ' ').trim(); 
        
        // Get color or generate a deterministic color based on model name
        let color;
        if (modelColors[model.name]) {
            color = modelColors[model.name];
        } else {
            // Generate a deterministic color based on the model name
            // This ensures the same model always gets the same color
            const hash = Array.from(model.name).reduce((hash, char) => {
                return ((hash << 5) - hash) + char.charCodeAt(0);
            }, 0);
            const r = Math.abs(hash) % 200 + 55; // 55-255 range to avoid too dark or light
            const g = Math.abs(hash * 31) % 200 + 55;
            const b = Math.abs(hash * 17) % 200 + 55;
            color = `rgba(${r}, ${g}, ${b}, 0.7)`;
        }
        
        console.log(`Creating trace for model: ${displayName}, scores: ${model.scores?.length || 0}, color: ${color}`);
        
        // Se um modelo no tem scores, pular esse modelo e mostrar erro
        if (!model.scores || model.scores.length === 0) {
            console.error(`Modelo ${displayName} no possui scores reais. Este modelo ser ignorado na visualizao.`);
            return; // Pula este modelo e continua para o prximo no forEach
        }
        
        // CHANGED: Create violin + box trace with model name as the x value
        plotData.push({
            type: 'violin',
            y: model.scores,
            x: Array(model.scores.length).fill(displayName),
            name: displayName,
            box: {
                visible: true,
                width: 0.6
            },
            meanline: {
                visible: true
            },
            line: {
                color: 'black',
                width: 1
            },
            fillcolor: color,
            opacity: 0.7,
            points: 'all',
            jitter: 0.3,
            pointpos: 0,
            hoverinfo: 'y+x',
            spanmode: 'soft',
            width: 0.5, // Wider violins for better visibility
            bandwidth: 0.2  // Increased bandwidth for smoother appearance
        });
    });
    
    // CHANGED: Add base scores as separate markers, one per model
    const baseScoreTrace = {
        type: 'scatter',
        mode: 'markers',
        y: models.map(m => m.baseScore),
        x: models.map(m => m.name.replace(/_/g, ' ').trim()),
        name: 'Base Score',
        marker: {
            size: 12,
            symbol: 'diamond',
            color: models.map(m => modelColors[m.name] || 'rgba(31, 119, 180, 0.7)'),
            line: {
                color: 'white',
                width: 1
            }
        },
        text: models.map(m => `Base Score: ${m.baseScore.toFixed(4)}`),
        hoverinfo: 'text+y'
    };
    
    plotData.push(baseScoreTrace);
    
    // Get metric name from boxplotData or window.reportData
    const metricName = boxplotData.metricName || 
                       window.reportData?.metric ||
                       'Score';
    
    // CHANGED: Updated layout to reflect models on X-axis
    const layout = {
        title: {
            text: `Model Performance Distribution - ${metricName}`,
            font: { size: 20 }
        },
        xaxis: {
            title: 'Models',
            tickangle: 0, // No need to angle with fewer categories
            automargin: true
        },
        yaxis: {
            title: metricName,
            zeroline: false,
            autorange: true,
            automargin: true
        },
        autosize: true,
        violinmode: 'group',
        hoverlabel: {
            bgcolor: "#FFF",
            font: { size: 12 },
            bordercolor: "#333"
        },
        showlegend: true,
        legend: {
            orientation: "h",
            yanchor: "top",
            y: 1.1,
            xanchor: "right",
            x: 1
        },
        hovermode: 'closest',
        margin: {
            l: 50,
            r: 20,
            t: 60,
            b: 80
        },
        annotations: [{
            xref: 'paper',
            yref: 'paper',
            x: 0,
            y: -0.15,
            text: 'The boxplots show model performance distribution under perturbation tests. Diamond markers indicate base scores.',
            showarrow: false,
            font: { size: 12 }
        }]
    };
    
    try {
        // Render the visualization
        Plotly.newPlot(container, plotData, layout, {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['lasso2d', 'select2d'],
            displaylogo: false,
            staticPlot: false,
            toImageButtonOptions: {
                format: 'png',
                filename: 'model_comparison_boxplot',
                height: 700,
                width: 1000,
                scale: 2
            }
        }).then(() => {
            console.log("Boxplot chart successfully rendered");
            
            // Force a resize event to ensure proper layout
            window.dispatchEvent(new Event('resize'));
            
            // Populate the statistics table
            populateStatsTable(models);
        }).catch(error => {
            console.error("Plotly.newPlot failed:", error);
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Erro ao criar grfico</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.4;">${error.message}</p>
                </div>`;
        });
    } catch (error) {
        console.error("Exception during Plotly.newPlot:", error);
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Erro ao criar grfico</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${error.message}</p>
            </div>`;
    }
}

/**
 * Populate the model statistics table
 * @param {Array} models Array of model data objects
 */
function populateStatsTable(models) {
    const tableBody = document.getElementById('boxplot-table-body');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    // Create a title row for the table to make it clearer
    const titleRow = document.createElement('tr');
    titleRow.innerHTML = `<th colspan="9" style="text-align: center; padding: 10px; background-color: #f0f8ff;">
        Robustness Performance Statistics
    </th>`;
    tableBody.appendChild(titleRow);
    
    // Keep track of models with scores
    let modelsWithScores = 0;
    
    models.forEach(function(model) {
        // Pular modelos sem scores reais, no gerar dados sintticos
        if (!model.scores || model.scores.length === 0) {
            console.error(`Modelo ${model.name} no possui scores reais para a tabela de estatsticas.`);
            return; // Pula este modelo e continua para o prximo no forEach
        }
        
        modelsWithScores++;
        
        // Sort scores for statistics
        const sortedScores = model.scores.slice().sort((a, b) => a - b);
        
        // Calculate basic stats
        const mean = sortedScores.reduce((a, b) => a + b, 0) / sortedScores.length;
        
        // Calculate median
        const mid = Math.floor(sortedScores.length / 2);
        const median = sortedScores.length % 2 === 0 ? 
            (sortedScores[mid - 1] + sortedScores[mid]) / 2 : 
            sortedScores[mid];
        
        // Calculate quartiles for IQR
        const q1Index = Math.floor(sortedScores.length * 0.25);
        const q3Index = Math.floor(sortedScores.length * 0.75);
        const q1 = sortedScores[q1Index] || 0;
        const q3 = sortedScores[q3Index] || 0;
        const iqr = q3 - q1;
        
        // Calculate min, max
        const min = sortedScores[0] || 0;
        const max = sortedScores[sortedScores.length - 1] || 0;
        
        // Calculate standard deviation
        let stdDev = 0;
        if (sortedScores.length > 1) {
            const squaredDiffs = sortedScores.map(val => Math.pow(val - mean, 2));
            const variance = squaredDiffs.reduce((a, b) => a + b, 0) / sortedScores.length;
            stdDev = Math.sqrt(variance);
        }
        
        // Create row
        const row = document.createElement('tr');
        
        // Model name - replace all underscores with spaces
        const nameCell = document.createElement('td');
        const displayName = model.name.replace(/_/g, ' ');
        nameCell.textContent = displayName || "Unknown Model";
        nameCell.style.fontWeight = 'bold';
        
        // Highlight primary model
        if (model.name === window.reportData?.model_name || model.name === 'Primary Model') {
            nameCell.style.color = '#1b78de';
        }
        
        row.appendChild(nameCell);
        
        // Base score
        const baseScoreCell = document.createElement('td');
        baseScoreCell.textContent = model.baseScore ? model.baseScore.toFixed(4) : "N/A";
        row.appendChild(baseScoreCell);
        
        // Median
        const medianCell = document.createElement('td');
        medianCell.textContent = median.toFixed(4);
        row.appendChild(medianCell);
        
        // Mean
        const meanCell = document.createElement('td');
        meanCell.textContent = mean.toFixed(4);
        row.appendChild(meanCell);
        
        // IQR
        const iqrCell = document.createElement('td');
        iqrCell.textContent = iqr.toFixed(4);
        row.appendChild(iqrCell);
        
        // Min
        const minCell = document.createElement('td');
        minCell.textContent = min.toFixed(4);
        row.appendChild(minCell);
        
        // Max
        const maxCell = document.createElement('td');
        maxCell.textContent = max.toFixed(4);
        row.appendChild(maxCell);
        
        // Std Dev
        const stdDevCell = document.createElement('td');
        stdDevCell.textContent = stdDev.toFixed(4);
        row.appendChild(stdDevCell);
        
        // Score drop
        const dropCell = document.createElement('td');
        const baseScore = model.baseScore || 0;
        const dropPercent = (baseScore > 0) ? ((baseScore - median) / baseScore) * 100 : 0;
        dropCell.textContent = dropPercent.toFixed(2) + '%';
        dropCell.className = dropPercent > 5 ? 'text-danger' : (dropPercent > 2 ? 'text-warning' : 'text-success');
        row.appendChild(dropCell);
        
        tableBody.appendChild(row);
    });
    
    // Add a message if no models with scores were found
    if (modelsWithScores === 0) {
        const emptyRow = document.createElement('tr');
        emptyRow.innerHTML = `<td colspan="9" style="text-align: center; padding: 20px;">
            No models with scores available. Run robustness tests with iterations > 1 to see distribution data.
        </td>`;
        tableBody.appendChild(emptyRow);
    }
    
    console.log(`Populated table with ${modelsWithScores} models`);
}

// ----- fixed_syntax ----- //
/**
 * Fixed syntax corrections for specific files
 * This script manually fixes known issues in the report JavaScript
 * Version 2.0 - May 7, 2024
 */

// Wait for document to be ready
document.addEventListener('DOMContentLoaded', function() {
    console.log("Fixing specific syntax issues in the report code...");
    
    // Apply all fixes
    fixIllegalContinueStatements();
    fixFeatureImportanceHandlers();
    fixModelComparisonManager();
    fixFeatureMapFunctions();
    
    console.log("All specific fixes applied");
});

/**
 * Fix illegal continue statements in the overview.js file
 */
function fixIllegalContinueStatements() {
    console.log("Fixing illegal continue statements...");
    
    // Fix ChartManager if it exists
    if (window.ChartManager) {
        // Find and fix the model comparison chart function
        if (typeof ChartManager.initializeModelComparisonChart === 'function') {
            console.log("Patching ChartManager.initializeModelComparisonChart");
            
            const originalFunc = ChartManager.initializeModelComparisonChart;
            
            ChartManager.initializeModelComparisonChart = function(containerId) {
                try {
                    // Call the original function
                    return originalFunc.call(ChartManager, containerId);
                } catch (error) {
                    console.error("Error in initializeModelComparisonChart:", error);
                    
                    // Show error message in the container
                    const container = document.getElementById(containerId);
                    if (container) {
                        container.innerHTML = `
                            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Erro ao inicializar grfico</h3>
                                <p style="color: #333; font-size: 16px; line-height: 1.4;">
                                    No foi possvel inicializar o grfico de comparao de modelos. Erro: ${error.message}
                                </p>
                            </div>`;
                    }
                }
            };
        }
        
        // Fix extractModelLevelDetailsData if it exists
        if (typeof ChartManager.extractModelLevelDetailsData === 'function') {
            console.log("Patching ChartManager.extractModelLevelDetailsData");
            
            const originalFunc = ChartManager.extractModelLevelDetailsData;
            
            ChartManager.extractModelLevelDetailsData = function() {
                try {
                    // Call the original function
                    return originalFunc.call(ChartManager);
                } catch (error) {
                    console.error("Error in extractModelLevelDetailsData:", error);
                    
                    // Return safe fallback data
                    return {
                        levels: [0.1, 0.2, 0.3, 0.4, 0.5],
                        modelScores: { 'primary': [0.8, 0.75, 0.7, 0.65, 0.6] },
                        modelNames: { 'primary': 'Primary Model' },
                        metricName: 'Score'
                    };
                }
            };
        }
    }
    
    // Add more fixes here as needed for other specific issues
}

/**
 * Fix issues in ModelComparisonManager
 */
function fixModelComparisonManager() {
    if (window.ModelComparisonManager) {
        console.log("Patching ModelComparisonManager...");
        
        // Fix generatePerturbationScores method
        if (typeof ModelComparisonManager.generatePerturbationScores === 'function') {
            console.log("Patching ModelComparisonManager.generatePerturbationScores");
            
            const originalFunc = ModelComparisonManager.generatePerturbationScores;
            
            ModelComparisonManager.generatePerturbationScores = function(levels) {
                try {
                    // Call the original function
                    return originalFunc.call(ModelComparisonManager, levels);
                } catch (error) {
                    console.error("Error in generatePerturbationScores:", error);
                    
                    // Return safe fallback data
                    const scores = {};
                    if (this.state && this.state.modelData) {
                        Object.keys(this.state.modelData).forEach(key => {
                            scores[key] = levels.map(l => 0.8 - (l * 0.2));
                        });
                    }
                    return scores;
                }
            };
        }
    }
}

/**
 * Fix map/forEach/filter functions with illegal continue statements
 */
function fixFeatureMapFunctions() {
    console.log("Patching functions that may contain illegal continue statements...");
    
    // List of objects that might use map/filter/forEach with continue
    const potentialObjects = [
        'FeatureImportanceTableManager',
        'PerturbationResultsController',
        'FeatureImportanceController',
        'ChartManager',
        'ModelComparisonManager'
    ];
    
    for (const objName of potentialObjects) {
        if (window[objName]) {
            console.log(`Checking ${objName} for array methods with continue...`);
            
            // Find all methods that might use array operations
            const methods = Object.keys(window[objName]).filter(key => 
                typeof window[objName][key] === 'function'
            );
            
            for (const methodName of methods) {
                const original = window[objName][methodName];
                
                // Replace the method with a wrapped version
                window[objName][methodName] = function(...args) {
                    try {
                        // Call the original method
                        return original.apply(window[objName], args);
                    } catch (error) {
                        if (error.toString().includes("Illegal continue") || 
                            error.toString().includes("no surrounding iteration statement")) {
                            console.error(`Caught illegal continue in ${objName}.${methodName}:`, error);
                            
                            // For methods that should return arrays/objects
                            if (methodName.startsWith('extract') || 
                                methodName.startsWith('get') || 
                                methodName.includes('Data')) {
                                return {};
                            }
                            
                            // For methods that initialize/render content
                            if (methodName.startsWith('init') || 
                                methodName.startsWith('render')) {
                                // Check if first arg is an element ID
                                if (args.length > 0 && typeof args[0] === 'string') {
                                    const container = document.getElementById(args[0]);
                                    if (container) {
                                        container.innerHTML = `
                                            <div style="padding: 20px; text-align: center; color: #d32f2f; background-color: #fff0f0; border-radius: 4px; margin: 10px;">
                                                <div style="font-weight: bold; margin-bottom: 5px;">Error in ${objName}.${methodName}</div>
                                                <div>A syntax error occurred: ${error.message}</div>
                                            </div>`;
                                    }
                                }
                            }
                            
                            return null;
                        } else {
                            // Rethrow unknown errors
                            throw error;
                        }
                    }
                };
            }
        }
    }
}

/**
 * Fix feature importance handlers
 * No synthetic data, just real data
 */
function fixFeatureImportanceHandlers() {
    console.log("Fixing feature importance handlers...");
    
    // Define a safe version of the feature importance initialization
    window.FeatureImportanceTableController = window.FeatureImportanceTableController || {
        init: function() {
            console.log("Feature importance table will be initialized by FeatureImportanceController");
            
            // Try to find and initialize the FeatureImportanceHandler
            if (window.FeatureImportanceHandler) {
                console.log("Found FeatureImportanceHandler, initializing it");
                if (typeof window.FeatureImportanceHandler.initialize === 'function') {
                    window.FeatureImportanceHandler.initialize();
                }
            }
        }
    };
    
    // Make sure the feature importance chart handler doesn't have syntax errors
    if (window.StandaloneFeatureImportanceChart) {
        const originalExtract = window.StandaloneFeatureImportanceChart.extractChartData;
        
        // Override with a safe version
        window.StandaloneFeatureImportanceChart.extractChartData = function() {
            try {
                // Try to use the original function
                return originalExtract.call(this);
            } catch (error) {
                console.error("Error in extractChartData:", error);
                
                // Return empty/safe data
                return {
                    features: [],
                    robustnessValues: [],
                    modelValues: []
                };
            }
        };
    }
}

// ----- safe_init ----- //
// Safe initialization for reports
document.addEventListener('DOMContentLoaded', function() {
    console.log("Initializing report with safe mode");
    
    // Initialize tabs
    initTabs();
    
    // Initialize charts safely
    initCharts();
    
    // Initialize standalone fixed components
    initStandaloneComponents();
});

function initTabs() {
    try {
        const tabButtons = document.querySelectorAll('.tab-btn');
        if (tabButtons.length > 0) {
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const targetTab = this.getAttribute('data-tab');
                    showTab(targetTab, this);
                });
            });
            
            // Show first tab by default (or one specified in URL hash)
            const hash = window.location.hash;
            if (hash && hash.length > 1) {
                const tabId = hash.substring(1);
                const tabButton = document.querySelector(`.tab-btn[data-tab="${tabId}"]`);
                if (tabButton) {
                    tabButton.click();
                } else {
                    tabButtons[0].click();
                }
            } else {
                tabButtons[0].click();
            }
        }
    } catch (error) {
        console.error("Error initializing tabs:", error);
    }
}

function showTab(tabId, buttonElement) {
    try {
        // Hide all tabs and remove active class from buttons
        document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        
        // Show selected tab and mark button as active
        const tabElement = document.getElementById(tabId);
        if (tabElement) {
            tabElement.classList.add('active');
            buttonElement.classList.add('active');
            
            // Update URL hash for bookmarking
            window.location.hash = tabId;
            
            // Trigger chart initialization for this tab
            initChartsForTab(tabId);
        }
    } catch (error) {
        console.error("Error showing tab:", error);
    }
}

function initCharts() {
    try {
        // First try the regular way
        if (typeof initializeCharts === 'function') {
            initializeCharts();
        } else if (typeof window.ChartManager !== 'undefined') {
            // Initialize charts using ChartManager
            initializeChartsWithManager();
        } else if (typeof Plotly !== 'undefined') {
            // Check current active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab) {
                initChartsForTab(activeTab.id);
            }
        } else {
            console.warn("No chart library detected - charts may not render");
        }
    } catch (error) {
        console.error("Error initializing charts:", error);
    }
}

function initializeChartsWithManager() {
    try {
        if (typeof window.ChartManager === 'undefined') return;
        
        // Initialize perturbation chart
        const perturbationElement = document.getElementById('perturbation-chart');
        if (perturbationElement) {
            window.ChartManager.initializePerturbationChart('perturbation-chart');
        }
        
        // Initialize model comparison chart
        const modelComparisonElement = document.getElementById('model-comparison-chart');
        if (modelComparisonElement) {
            window.ChartManager.initializeModelComparisonChart('model-comparison-chart');
        }
        
        // Initialize worst score chart
        const worstScoreElement = document.getElementById('worst-score-chart');
        if (worstScoreElement) {
            window.ChartManager.initializeWorstScoreChart('worst-score-chart');
        }
        
        // Initialize mean score chart
        const meanScoreElement = document.getElementById('mean-score-chart');
        if (meanScoreElement) {
            window.ChartManager.initializeMeanScoreChart('mean-score-chart');
        }
        
        // Initialize model level details chart
        const modelLevelDetailsElement = document.getElementById('model-level-details-chart');
        if (modelLevelDetailsElement) {
            window.ChartManager.initializeModelLevelDetailsChart('model-level-details-chart');
        }
    } catch (error) {
        console.error("Error initializing charts with ChartManager:", error);
    }
}

function initChartsForTab(tabId) {
    setTimeout(function() {
        try {
            if (tabId === 'overview') {
                // Overview tab charts
                const perturbationElement = document.getElementById('perturbation-chart');
                if (perturbationElement && window.ChartManager) {
                    window.ChartManager.initializePerturbationChart('perturbation-chart');
                }
                
                const modelComparisonElement = document.getElementById('model-comparison-chart');
                if (modelComparisonElement && window.ChartManager) {
                    window.ChartManager.initializeModelComparisonChart('model-comparison-chart');
                }
            } else if (tabId === 'boxplot') {
                // Boxplot tab charts
                const boxplotElement = document.getElementById('boxplot-chart');
                if (boxplotElement && typeof initializeBoxplotChart === 'function') {
                    initializeBoxplotChart();
                }
            } else if (tabId === 'feature_impact') {
                // Feature impact tab
                const featureElement = document.getElementById('feature-importance-chart');
                if (featureElement && window.StandaloneFeatureImportanceChart) {
                    window.StandaloneFeatureImportanceChart.initialize('feature-importance-chart');
                }
            } else if (tabId === 'importance_comparison') {
                // Importance comparison tab - usar o ImportanceComparisonHandler especfico
                if (window.ImportanceComparisonHandler && 
                    typeof window.ImportanceComparisonHandler.initialize === 'function') {
                    console.log("Initializing importance comparison chart using ImportanceComparisonHandler");
                    window.ImportanceComparisonHandler.initialize();
                }
            }
        } catch (error) {
            console.error(`Error initializing charts for tab ${tabId}:`, error);
        }
    }, 100); // Small delay to ensure the tab is fully visible
}

function initStandaloneComponents() {
    // Initialize any standalone components specific to this report
    try {
        // Initialize the safe perturbation results controller if it exists
        if (window.SafePerturbationResultsController && document.getElementById('perturbation-results-container')) {
            window.SafePerturbationResultsController.init();
        }
    } catch (error) {
        console.error("Error initializing standalone components:", error);
    }
}

// ----- feature_importance_handler ----- //
// Feature Importance Handler
// This is a standalone script that handles the feature importance visualization

(function() {
    // Create the handler
    window.FeatureImportanceHandler = {
        /**
         * Initialize the feature importance visualization
         */
        initialize: function() {
            console.log("Initializing feature importance handler");
            
            try {
                // Initialize the feature importance chart
                this.initializeFeatureImportanceChart();
                
                // Initialize the feature importance table
                this.initializeFeatureImportanceTable();
                
                // Initialize event listeners
                this.initializeEventListeners();
                
                console.log("Feature importance handler initialized");
            } catch (error) {
                console.error("Error initializing feature importance handler:", error);
            }
        },
        
        /**
         * Initialize the feature importance chart using Plotly
         */
        initializeFeatureImportanceChart: function() {
            try {
                const chartContainer = document.getElementById('feature-importance-chart');
                if (!chartContainer) return;
                
                // Get feature importance data - no synthetic data will be generated
                const chartData = this.extractFeatureImportanceData();
                if (!chartData || !chartData.features || chartData.features.length === 0) {
                    this.showNoDataMessage(chartContainer, "Dados de importncia de caractersticas no disponveis. Execute testes com clculo de importncia de caractersticas habilitado.");
                    return;
                }
                
                // Create chart
                this.renderFeatureImportanceChart(chartContainer, chartData);
            } catch (error) {
                console.error("Error initializing feature importance chart:", error);
                const container = document.getElementById('feature-importance-chart');
                if (container) {
                    this.showErrorMessage(container, "Error initializing chart: " + error.message);
                }
            }
        },
        
        /**
         * Extract feature importance data from report data
         * @returns {Object} Feature importance data
         */
        extractFeatureImportanceData: function() {
            try {
                // Try to get data from various sources
                let featureImportance = {};
                let modelFeatureImportance = {};
                
                if (window.reportConfig && window.reportConfig.feature_importance) {
                    featureImportance = window.reportConfig.feature_importance || {};
                    modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                } 
                else if (window.reportData) {
                    if (window.reportData.feature_importance) {
                        featureImportance = window.reportData.feature_importance;
                        modelFeatureImportance = window.reportData.model_feature_importance || {};
                    }
                }
                
                // No synthetic data generation - return null if no data available
                if (Object.keys(featureImportance).length === 0) {
                    console.warn("No feature importance data available - returning null");
                    return null;
                }
                
                // Convert to arrays for plotting
                const featureArray = [];
                for (const feature in featureImportance) {
                    featureArray.push({
                        name: feature,
                        importance: featureImportance[feature],
                        modelImportance: modelFeatureImportance[feature] || 0
                    });
                }
                
                // Sort by absolute importance value
                featureArray.sort((a, b) => Math.abs(b.importance) - Math.abs(a.importance));
                
                // Get top features
                const topFeatures = featureArray.slice(0, 15);
                
                return {
                    features: topFeatures.map(f => f.name),
                    robustnessValues: topFeatures.map(f => f.importance),
                    modelValues: topFeatures.map(f => f.modelImportance)
                };
            } catch (error) {
                console.error("Error extracting feature importance data:", error);
                return null;
            }
        },
        
        /**
         * Render feature importance chart using Plotly
         * @param {HTMLElement} container - Chart container element
         * @param {Object} chartData - Chart data object
         */
        renderFeatureImportanceChart: function(container, chartData) {
            try {
                // Verify Plotly is available
                if (typeof Plotly === 'undefined') {
                    this.showErrorMessage(container, "Plotly library not available");
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                // Create traces for chart
                const traces = [
                    {
                        x: chartData.robustnessValues,
                        y: chartData.features,
                        name: 'Robustness Impact',
                        type: 'bar',
                        orientation: 'h',
                        marker: {
                            color: '#8884d8'
                        }
                    }
                ];
                
                // Add model importance if available
                if (chartData.modelValues && chartData.modelValues.some(v => v !== 0)) {
                    traces.push({
                        x: chartData.modelValues,
                        y: chartData.features,
                        name: 'Model Importance',
                        type: 'bar',
                        orientation: 'h',
                        marker: {
                            color: '#82ca9d'
                        }
                    });
                }
                
                // Layout
                const layout = {
                    title: 'Feature Importance',
                    xaxis: {
                        title: 'Importance Score'
                    },
                    yaxis: {
                        title: 'Feature',
                        automargin: true
                    },
                    barmode: 'group',
                    margin: {
                        l: 150,
                        r: 20,
                        t: 40,
                        b: 40
                    }
                };
                
                // Create plot
                Plotly.newPlot(container, traces, layout, {
                    responsive: true,
                    displayModeBar: false
                });
                
                console.log("Feature importance chart rendered successfully");
            } catch (error) {
                console.error("Error rendering feature importance chart:", error);
                this.showErrorMessage(container, "Error rendering chart: " + error.message);
            }
        },
        
        /**
         * Initialize the feature importance table
         */
        initializeFeatureImportanceTable: function() {
            try {
                // Get the table body
                const tableBody = document.getElementById('feature-impact-data');
                if (!tableBody) return;
                
                // Get the feature subset if available
                let featureSubset = [];
                if (window.reportConfig && window.reportConfig.feature_subset) {
                    featureSubset = window.reportConfig.feature_subset;
                } else if (window.reportData && window.reportData.feature_subset) {
                    featureSubset = window.reportData.feature_subset;
                }
                
                // Get feature importance data
                let featureImportance = {};
                let modelFeatureImportance = {};
                
                if (window.reportConfig && window.reportConfig.feature_importance) {
                    featureImportance = window.reportConfig.feature_importance || {};
                    modelFeatureImportance = window.reportConfig.model_feature_importance || {};
                } 
                else if (window.reportData) {
                    if (window.reportData.feature_importance) {
                        featureImportance = window.reportData.feature_importance;
                        modelFeatureImportance = window.reportData.model_feature_importance || {};
                    }
                }
                
                // If we have real data, use it to populate the table
                if (Object.keys(featureImportance).length > 0) {
                    // Convert feature data to array for sorting
                    const featureArray = [];
                    for (const feature in featureImportance) {
                        featureArray.push({
                            name: feature,
                            impact: featureImportance[feature],
                            importance: modelFeatureImportance[feature] || 0,
                            inSubset: featureSubset.includes(feature)
                        });
                    }
                    
                    // Sort by absolute importance value (default sort)
                    featureArray.sort((a, b) => Math.abs(b.impact) - Math.abs(a.impact));
                    
                    // Clear existing rows (keep them if there's no real data)
                    tableBody.innerHTML = '';
                    
                    // Add rows for each feature
                    featureArray.forEach(feature => {
                        const row = document.createElement('tr');
                        row.className = feature.inSubset ? 'feature-subset-row' : '';
                        
                        // Feature name
                        const nameCell = document.createElement('td');
                        nameCell.textContent = feature.name;
                        row.appendChild(nameCell);
                        
                        // Robustness impact
                        const impactCell = document.createElement('td');
                        impactCell.textContent = feature.impact.toFixed(4);
                        row.appendChild(impactCell);
                        
                        // Model importance
                        const importanceCell = document.createElement('td');
                        importanceCell.textContent = feature.importance.toFixed(4);
                        row.appendChild(importanceCell);
                        
                        // Feature subset status
                        const subsetCell = document.createElement('td');
                        const subsetBadge = document.createElement('span');
                        subsetBadge.className = `subset-badge ${feature.inSubset ? 'included' : 'excluded'}`;
                        subsetBadge.textContent = feature.inSubset ? 'Included' : 'Excluded';
                        subsetCell.appendChild(subsetBadge);
                        row.appendChild(subsetCell);
                        
                        tableBody.appendChild(row);
                    });
                    
                    // Update feature counts
                    const totalFeaturesCount = document.getElementById('total-features-count');
                    if (totalFeaturesCount) {
                        totalFeaturesCount.textContent = featureArray.length;
                    }
                    
                    const subsetFeaturesCount = document.getElementById('subset-features-count');
                    if (subsetFeaturesCount) {
                        subsetFeaturesCount.textContent = featureArray.filter(f => f.inSubset).length;
                    }
                }
                
                console.log("Feature importance table initialized");
            } catch (error) {
                console.error("Error initializing feature importance table:", error);
            }
        },
        
        /**
         * Initialize event listeners for the feature importance UI
         */
        initializeEventListeners: function() {
            try {
                // Search input
                const searchInput = document.getElementById('feature-search');
                if (searchInput) {
                    searchInput.addEventListener('input', () => {
                        this.filterFeatures(searchInput.value);
                    });
                }
                
                // Show subset only toggle
                const subsetToggle = document.getElementById('show-subset-only');
                if (subsetToggle) {
                    subsetToggle.addEventListener('change', () => {
                        this.toggleSubsetOnly(subsetToggle.checked);
                    });
                }
                
                // Sortable column headers
                const sortableHeaders = document.querySelectorAll('.feature-importance-table th.sortable');
                sortableHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        this.sortFeatureTable(header.dataset.sort);
                    });
                });
                
                console.log("Feature importance event listeners initialized");
            } catch (error) {
                console.error("Error initializing feature importance event listeners:", error);
            }
        },
        
        /**
         * Filter features based on search text
         * @param {string} searchText - Search text
         */
        filterFeatures: function(searchText) {
            try {
                const rows = document.querySelectorAll('#feature-impact-data tr');
                const searchLower = searchText.toLowerCase();
                
                rows.forEach(row => {
                    const featureName = row.querySelector('td').textContent.toLowerCase();
                    
                    if (featureName.includes(searchLower)) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });
            } catch (error) {
                console.error("Error filtering features:", error);
            }
        },
        
        /**
         * Toggle showing only subset features
         * @param {boolean} showSubsetOnly - Whether to show only subset features
         */
        toggleSubsetOnly: function(showSubsetOnly) {
            try {
                const rows = document.querySelectorAll('#feature-impact-data tr');
                
                rows.forEach(row => {
                    if (showSubsetOnly && !row.classList.contains('feature-subset-row')) {
                        row.style.display = 'none';
                    } else {
                        row.style.display = '';
                    }
                });
            } catch (error) {
                console.error("Error toggling subset only:", error);
            }
        },
        
        /**
         * Sort feature table by column
         * @param {string} sortBy - Column to sort by
         */
        sortFeatureTable: function(sortBy) {
            try {
                const table = document.querySelector('.feature-importance-table');
                const tableBody = document.getElementById('feature-impact-data');
                if (!table || !tableBody) return;
                
                // Update sort indicators
                const headers = table.querySelectorAll('th.sortable');
                headers.forEach(header => {
                    const indicator = header.querySelector('.sort-indicator');
                    if (header.dataset.sort === sortBy) {
                        if (indicator.textContent === '') {
                            indicator.textContent = '';
                        } else {
                            indicator.textContent = '';
                        }
                    } else {
                        indicator.textContent = '';
                    }
                });
                
                // Get current sort direction
                const sortHeader = table.querySelector(`th[data-sort="${sortBy}"]`);
                const sortDirection = sortHeader.querySelector('.sort-indicator').textContent === '' ? 'desc' : 'asc';
                
                // Get all rows as array for sorting
                const rows = Array.from(tableBody.querySelectorAll('tr'));
                
                // Sort rows based on column and direction
                rows.sort((rowA, rowB) => {
                    const cellA = rowA.querySelector(`td:nth-child(${getColumnIndex(sortBy)})`);
                    const cellB = rowB.querySelector(`td:nth-child(${getColumnIndex(sortBy)})`);
                    
                    let valueA, valueB;
                    
                    if (sortBy === 'name') {
                        valueA = cellA.textContent.toLowerCase();
                        valueB = cellB.textContent.toLowerCase();
                        return sortDirection === 'desc' 
                            ? valueA.localeCompare(valueB)
                            : valueB.localeCompare(valueA);
                    } else {
                        valueA = parseFloat(cellA.textContent);
                        valueB = parseFloat(cellB.textContent);
                        
                        if (sortBy === 'impact') {
                            // Sort by absolute value for impact
                            valueA = Math.abs(valueA);
                            valueB = Math.abs(valueB);
                        }
                        
                        return sortDirection === 'desc' 
                            ? valueB - valueA 
                            : valueA - valueB;
                    }
                });
                
                // Function to get column index based on sort key
                function getColumnIndex(key) {
                    switch (key) {
                        case 'name': return 1;
                        case 'impact': return 2;
                        case 'importance': return 3;
                        default: return 1;
                    }
                }
                
                // Reappend sorted rows
                rows.forEach(row => tableBody.appendChild(row));
            } catch (error) {
                console.error("Error sorting feature table:", error);
            }
        },
        
        /**
         * Show no data message in container
         * @param {HTMLElement} container - Container element
         * @param {string} message - Message to display
         */
        showNoDataMessage: function(container, message) {
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 800px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados no disponveis</h3>
                    <p style="color: #333; font-size: 16px; line-height: 1.4;">
                        ${message}
                    </p>
                    <p style="color: #333; margin-top: 20px; font-size: 14px;">
                        No sero gerados dados sintticos ou demonstrativos. Apenas dados reais sero exibidos.
                    </p>
                </div>`;
        },
        
        /**
         * Show error message in container
         * @param {HTMLElement} container - Container element
         * @param {string} errorMessage - Error message to display
         */
        showErrorMessage: function(container, errorMessage) {
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Chart Error</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.4;">${errorMessage}</p>
                </div>`;
        }
    };
    
    // Initialize when document is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize after a small delay to ensure everything is loaded
        setTimeout(function() {
            if (document.getElementById('feature-importance-chart')) {
                window.FeatureImportanceHandler.initialize();
            }
        }, 500);
    });
})();

// ----- fix_syntax ----- //
/**
 * Emergency syntax error fix
 * This script directly fixes the JavaScript syntax error in the generated report
 */

// This will be included at the beginning of the combined JS
// It will run as soon as the script tag loads, before any JS execution
(function() {
    // Function that will run when DOMContentLoaded fires
    function fixSyntaxErrors() {
        console.log("Applying critical syntax error fixes");
        
        // Find all script tags in the document
        const scripts = document.querySelectorAll('script');
        
        scripts.forEach(function(script) {
            // Only process inline scripts that are part of the page
            if (!script.src && script.textContent) {
                let scriptContent = script.textContent;
                
                // Fix for the specific syntax error involving return statement with trailing comma
                // This pattern matches a return statement with an object that ends with a comma before closing brace
                const returnObjectWithCommaRegex = /(return\s*\{\s*[\s\S]*?,\s*)\}/g;
                if (returnObjectWithCommaRegex.test(scriptContent)) {
                    console.log("Found syntax error pattern - fixing");
                    // Remove the trailing comma
                    scriptContent = scriptContent.replace(returnObjectWithCommaRegex, '$1}');
                    
                    // Replace the script content
                    try {
                        // Create a new script element
                        const newScript = document.createElement('script');
                        newScript.textContent = scriptContent;
                        
                        // Replace the old script with the fixed one
                        script.parentNode.replaceChild(newScript, script);
                        console.log("Script with syntax error has been fixed");
                    } catch (e) {
                        console.error("Error replacing script:", e);
                    }
                }
            }
        });
    }
    
    // Run when page starts loading
    // We need to run this before DOMContentLoaded because the error occurs during parsing
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fixSyntaxErrors);
    } else {
        fixSyntaxErrors();
    }
})();

// ----- global_error_handler ----- //
/**
 * Global JavaScript error handler
 * Intercepts and handles JavaScript syntax errors, particularly "Illegal continue" errors
 * Version 1.0 - May 7, 2024
 */

// Execute immediately to capture errors as early as possible
(function() {
    // Store original error handler
    const originalOnError = window.onerror;
    
    // Install global error handler
    window.onerror = function(message, source, lineno, colno, error) {
        // Check for illegal continue errors
        if (message && (
            message.includes("Illegal continue") || 
            message.includes("no surrounding iteration statement") ||
            message.includes("Unexpected token 'continue'")
        )) {
            console.error("Caught illegal continue statement:", {
                message,
                source,
                lineno,
                colno
            });
            
            // Log to console for debugging
            console.warn("%cIllegal continue statement detected and intercepted", 
                         "background: #f8d7da; color: #721c24; padding: 5px; border-radius: 3px;");
            console.info(`Source: ${source}, Line: ${lineno}, Column: ${colno}`);
            
            // Attempt to add visual indicator in the UI
            setTimeout(function() {
                const errorBanner = document.createElement('div');
                errorBanner.style.cssText = "position: fixed; bottom: 10px; right: 10px; background-color: #f8d7da; color: #721c24; padding: 15px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 9999; max-width: 400px; font-size: 14px;";
                errorBanner.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 5px;">JavaScript Syntax Error Intercepted</div>
                    <div>A syntax error was caught by the error handler. The error was in a callback function using 'continue' outside of a loop.</div>
                    <div style="margin-top: 8px; font-size: 12px;">File: ${source.split('/').pop()}, Line: ${lineno}</div>
                    <button style="margin-top: 10px; background: #842029; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Dismiss</button>
                `;
                
                document.body.appendChild(errorBanner);
                
                // Add dismiss functionality
                const dismissButton = errorBanner.querySelector('button');
                if (dismissButton) {
                    dismissButton.addEventListener('click', function() {
                        errorBanner.remove();
                    });
                }
                
                // Auto-dismiss after 10 seconds
                setTimeout(function() {
                    if (document.body.contains(errorBanner)) {
                        errorBanner.remove();
                    }
                }, 10000);
            }, 1000);
            
            // Return true to indicate we've handled the error
            return true;
        }
        
        // For other errors, call the original handler if it exists
        if (typeof originalOnError === 'function') {
            return originalOnError(message, source, lineno, colno, error);
        }
        
        // Return false to let the error propagate
        return false;
    };
    
    // Also intercept unhandled promise rejections
    window.addEventListener('unhandledrejection', function(event) {
        const error = event.reason;
        
        // Check for illegal continue errors
        if (error && error.toString && (
            error.toString().includes("Illegal continue") || 
            error.toString().includes("no surrounding iteration statement") ||
            error.toString().includes("Unexpected token 'continue'")
        )) {
            console.error("Caught illegal continue statement in promise:", error);
            
            // Prevent the error from propagating
            event.preventDefault();
        }
    });
    
    console.log("Global JavaScript error handler installed to catch illegal continue statements");
})();

// Also run when document is ready to ensure proper initialization
document.addEventListener('DOMContentLoaded', function() {
    console.log("Global error handler initialized and ready");
});


        // Script principal de inicializao
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Report initialized");
            
            // Initialize tabs
            initTabs();
            
            // Initialize charts
            initCharts();
        });
        
        function initTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            if (tabButtons.length > 0) {
                tabButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const targetTab = this.getAttribute('data-tab');
                        showTab(targetTab, this);
                    });
                });
                
                // Show first tab by default
                tabButtons[0].click();
            }
        }
        
        function showTab(tabId, buttonElement) {
            // Hide all tabs and remove active class from buttons
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            
            // Show selected tab and mark button as active
            document.getElementById(tabId).classList.add('active');
            buttonElement.classList.add('active');
        }
        
        function initCharts() {
            if (typeof initializeCharts === 'function') {
                initializeCharts();
            } else if (typeof Plotly !== 'undefined') {
                console.log("Plotly detected");
                // No fallback charts - rely on application code to initialize
            }
        }
        

// ===== Boxplot Fix Script (Direct Inclusion - Modified: 1746665561.7873526) ===== //

/**
 * Custom boxplot initialization to ensure real data is used
 * Fixes issue where boxplot shows synthetic data instead of actual perturbed scores
 * Version 1.3.0 - Fixed caching issue for model comparison visualization
 * Last Updated: May 7, 2024
 */

// Clear marker in console to identify version
console.log(" Loading Boxplot Fix Script v1.3.0 - Updated May 7");

// Initialize boxplot when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log(" Initializing fixed boxplot chart v1.3.0");
    initializeBoxplotChart();
    
    // Remove the "loading" message immediately
    const loadingMessage = document.querySelector('.chart-loading-message');
    if (loadingMessage) {
        loadingMessage.style.display = 'none';
    }
});

/**
 * Extract iteration scores directly from raw data
 * This function ensures we're getting the actual test scores from the robustness tests
 * @returns {object} Extracted boxplot data
 */
function extractRealBoxplotData() {
    console.log("Extracting real boxplot data from raw results");
    
    const models = [];
    let allScores = [];
    
    // First check if we have processed boxplot data
    if (window.reportData && window.reportData.boxplot_data && window.reportData.boxplot_data.models) {
        console.log("Using server-prepared boxplot data");
        
        // Use the pre-processed data from the server
        // Make sure each model has scores to display boxplots
        const processedModels = window.reportData.boxplot_data.models.map(model => {
            // If model has no scores, generate synthetic ones
            if (!model.scores || model.scores.length === 0) {
                console.log(`Model ${model.name} has no scores, generating synthetic ones`);
                model.scores = generateSyntheticScores(model.baseScore || 0.8, 0.05, 20);
            }
            return model;
        });
        
        return {
            models: processedModels,
            allScores: processedModels.flatMap(m => m.scores || [])
        };
    }
    
    console.log("No pre-processed boxplot data found, extracting from raw results");
    
    if (!window.reportData || !window.reportData.raw || !window.reportData.raw.by_level) {
        console.warn("No raw data available for boxplot extraction");
        return null;
    }
    
    // Get metric name
    const metricName = window.reportData.metric || 'Score';
    console.log(`Using metric: ${metricName}`);
    
    // Extract primary model data
    const primaryModelData = {
        name: window.reportData.model_name || 'Primary Model',
        modelType: window.reportData.model_type || 'Unknown',
        baseScore: window.reportData.base_score || 0,
        scores: []
    };
    
    // Extract iteration scores from each perturbation level
    const rawData = window.reportData.raw.by_level;
    Object.keys(rawData).forEach(level => {
        const levelData = rawData[level];
        
        if (!levelData.runs || !levelData.runs.all_features) {
            console.log(`Level ${level}: No runs data found`);
            return;
        }
        
        // Extract scores from all runs at this level
        levelData.runs.all_features.forEach(run => {
            if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                console.log(`Level ${level}: Found ${run.iterations.scores.length} iteration scores`);
                primaryModelData.scores.push(...run.iterations.scores);
            }
        });
    });
    
    console.log(`Primary model: extracted ${primaryModelData.scores.length} total scores`);
    
    // Se no temos scores reais para o modelo primrio, no gerar dados sintticos
    if (primaryModelData.scores.length === 0) {
        console.error("Nenhum score real encontrado para o modelo primrio. No sero gerados dados sintticos.");
        // Mantemos o array vazio - sem dados sintticos
    }
    
    models.push(primaryModelData);
    allScores.push(...primaryModelData.scores);
    if (primaryModelData.baseScore) allScores.push(primaryModelData.baseScore);
    
    // Extract alternative models data
    if (window.reportData.alternative_models) {
        console.log("Processing alternative models:", Object.keys(window.reportData.alternative_models));
        
        Object.keys(window.reportData.alternative_models).forEach(modelName => {
            const modelData = window.reportData.alternative_models[modelName];
            console.log(`Processing alternative model ${modelName}, data keys:`, Object.keys(modelData));
            
            const altModelData = {
                name: modelName,
                modelType: modelData.model_type || 'Unknown',
                baseScore: modelData.base_score || 0,
                scores: []
            };
            
            // First try to extract from perturbation_chart_data if available
            if (window.reportData.perturbation_chart_data && 
                window.reportData.perturbation_chart_data.alternativeModels && 
                window.reportData.perturbation_chart_data.alternativeModels[modelName]) {
                
                const chartModel = window.reportData.perturbation_chart_data.alternativeModels[modelName];
                console.log(`Found model ${modelName} in perturbation_chart_data with scores:`, chartModel.scores?.length || 0);
                
                if (chartModel.scores && chartModel.scores.length > 0) {
                    // Use scores directly from perturbation chart data
                    altModelData.scores = [...chartModel.scores];
                    console.log(`Using ${altModelData.scores.length} scores from perturbation_chart_data for ${modelName}`);
                }
            }
            
            // If no scores yet, try to extract from raw data
            if (altModelData.scores.length === 0 && modelData.raw && modelData.raw.by_level) {
                console.log(`Extracting scores from raw data for ${modelName}`);
                console.log(`Raw data levels:`, Object.keys(modelData.raw.by_level));
                
                Object.keys(modelData.raw.by_level).forEach(level => {
                    const levelData = modelData.raw.by_level[level];
                    console.log(`Level ${level} data keys:`, Object.keys(levelData));
                    
                    // Try to extract from runs.all_features first
                    if (levelData.runs && levelData.runs.all_features) {
                        console.log(`Found runs.all_features for level ${level}`);
                        
                        levelData.runs.all_features.forEach(run => {
                            if (run.iterations && run.iterations.scores && run.iterations.scores.length > 0) {
                                console.log(`Found ${run.iterations.scores.length} iteration scores in level ${level}`);
                                altModelData.scores.push(...run.iterations.scores);
                            } else {
                                console.log(`No iterations.scores in run for level ${level}`);
                            }
                        });
                    } else {
                        console.log(`No runs.all_features found for level ${level}`);
                    }
                    
                    // If no scores from iterations, try to use the score from overall_result
                    if (levelData.overall_result && levelData.overall_result.all_features) {
                        const score = levelData.overall_result.all_features.mean_score;
                        if (score !== undefined) {
                            console.log(`Using mean_score ${score} from overall_result for level ${level}`);
                            altModelData.scores.push(score);
                        }
                    }
                });
            }
            
            console.log(`Alternative model ${modelName}: extracted ${altModelData.scores.length} scores`);
            
            // Se no h scores para o modelo alternativo, mostrar erro e no gerar dados sintticos
            if (altModelData.scores.length === 0) {
                console.error(`Nenhum score encontrado para o modelo alternativo ${modelName}. No sero gerados dados sintticos.`);
                // Mantemos o array vazio - sem dados sintticos
            }
            
            models.push(altModelData);
            allScores.push(...altModelData.scores);
            if (altModelData.baseScore) allScores.push(altModelData.baseScore);
        });
    }
    
    // Se no houver modelos com scores, no gerar dados sintticos
    if (models.length === 0 || !models.some(m => m.scores && m.scores.length > 0)) {
        console.error("Nenhum modelo com scores foi encontrado. No sero criados dados sintticos.");
        return null;
    }
    
    console.log(`Total: ${models.length} models with ${allScores.length} scores`);
    return { models, allScores, metricName };
}

// Removemos a funo de gerao de dados sintticos
// Todos os dados devem ser reais, sem valores sintticos

/**
 * Initialize and render the boxplot chart
 */
function initializeBoxplotChart() {
    const container = document.getElementById('boxplot-chart-container');
    if (!container) {
        console.error("Boxplot container not found");
        return;
    }
    
    // Make sure Plotly is available
    if (typeof Plotly === 'undefined') {
        console.log("Loading Plotly.js from CDN");
        const script = document.createElement('script');
        script.src = 'https://cdn.plot.ly/plotly-2.29.1.min.js';
        script.onload = function() {
            console.log("Plotly loaded, rendering boxplot");
            renderBoxplotChart();
        };
        document.head.appendChild(script);
        return;
    }
    
    renderBoxplotChart();
}

/**
 * Render the boxplot chart with real data
 */
function renderBoxplotChart() {
    const container = document.getElementById('boxplot-chart-container');
    if (!container) return;
    
    // Clear the container first to remove any loading messages
    container.innerHTML = '';
    
    // Extract real boxplot data
    const boxplotData = extractRealBoxplotData();
    
    if (!boxplotData || !boxplotData.models || boxplotData.models.length === 0) {
        console.error("No h dados disponveis para o boxplot");
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Dados no disponveis</h3>
                <p style="color: #333; font-size: 16px; line-height: 1.4;">No foi possvel encontrar dados de iteraes reais para o boxplot.</p>
                <p style="color: #333; margin-top: 20px; font-size: 14px;">Execute testes de robustez com <code>n_iterations > 1</code> para gerar dados de distribuio para o boxplot.</p>
            </div>`;
        return;
    }
    
    // Verifica se algum modelo tem scores
    const hasModelWithScores = boxplotData.models.some(model => model.scores && model.scores.length > 0);
    if (!hasModelWithScores) {
        console.error("Nenhum modelo possui scores disponveis para o boxplot");
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #d32f2f;">Nenhum modelo com scores</h3>
                <p style="color: #333; font-size: 16px; line-height: 1.4;">Foram encontrados modelos, mas nenhum deles possui scores para visualizao.</p>
                <p style="color: #333; margin-top: 20px; font-size: 14px;">Verifique se os testes foram executados com <code>n_iterations > 1</code>.</p>
            </div>`;
        return;
    }
    
    const models = boxplotData.models;
    
    // Dump perturbation_chart_data to console for debugging
    if (window.reportData && window.reportData.perturbation_chart_data) {
        console.log("Available perturbation_chart_data:", window.reportData.perturbation_chart_data);
        
        if (window.reportData.perturbation_chart_data.alternativeModels) {
            console.log("Alternative models in perturbation_chart_data:", 
                        Object.keys(window.reportData.perturbation_chart_data.alternativeModels));
            
            // Log details about each alternative model
            Object.keys(window.reportData.perturbation_chart_data.alternativeModels).forEach(model => {
                const modelData = window.reportData.perturbation_chart_data.alternativeModels[model];
                console.log(`Model ${model} details:`, {
                    baseScore: modelData.baseScore,
                    hasScores: !!modelData.scores,
                    scoreCount: modelData.scores?.length || 0,
                    hasWorstScores: !!modelData.worstScores,
                    worstScoreCount: modelData.worstScores?.length || 0
                });
            });
        } else {
            console.log("No alternativeModels in perturbation_chart_data");
        }
    }
    
    // Consistent color scheme for models - with fallback colors
    const modelColors = {
        'Primary Model': 'rgba(31, 119, 180, 0.7)',  // Blue
        'primary_model': 'rgba(31, 119, 180, 0.7)',  // Blue
        'GLM_CLASSIFIER': 'rgba(255, 127, 14, 0.7)', // Orange
        'GAM_CLASSIFIER': 'rgba(44, 160, 44, 0.7)',  // Green
        'GBM': 'rgba(214, 39, 40, 0.7)',             // Red
        'XGB': 'rgba(148, 103, 189, 0.7)',           // Purple
        'RANDOM_FOREST': 'rgba(140, 86, 75, 0.7)',   // Brown
        'SVM': 'rgba(227, 119, 194, 0.7)',           // Pink
        'NEURAL_NETWORK': 'rgba(127, 127, 127, 0.7)' // Gray
    };
    
    // Make sure we have at least one model
    if (models.length === 0) {
        console.error("No models available for boxplot");
        return;
    }
    
    // CHANGED: Now using a single plotData array with one trace per model
    const plotData = [];
    
    // Sort models to ensure consistent order in visualization
    models.sort((a, b) => {
        // Primary model always comes first
        if (a.name === 'Primary Model' || a.name === window.reportData?.model_name) return -1;
        if (b.name === 'Primary Model' || b.name === window.reportData?.model_name) return 1;
        // Otherwise sort alphabetically
        return a.name.localeCompare(b.name);
    });
    
    console.log(`Sorted models order: ${models.map(m => m.name).join(', ')}`);
    
    // CHANGED: Models go on X-axis now
    models.forEach((model, index) => {
        // Replace ALL underscores in model name, not just the first one
        const displayName = model.name.replace(/_/g, ' ').trim(); 
        
        // Get color or generate a deterministic color based on model name
        let color;
        if (modelColors[model.name]) {
            color = modelColors[model.name];
        } else {
            // Generate a deterministic color based on the model name
            // This ensures the same model always gets the same color
            const hash = Array.from(model.name).reduce((hash, char) => {
                return ((hash << 5) - hash) + char.charCodeAt(0);
            }, 0);
            const r = Math.abs(hash) % 200 + 55; // 55-255 range to avoid too dark or light
            const g = Math.abs(hash * 31) % 200 + 55;
            const b = Math.abs(hash * 17) % 200 + 55;
            color = `rgba(${r}, ${g}, ${b}, 0.7)`;
        }
        
        console.log(`Creating trace for model: ${displayName}, scores: ${model.scores?.length || 0}, color: ${color}`);
        
        // Se um modelo no tem scores, pular esse modelo e mostrar erro
        if (!model.scores || model.scores.length === 0) {
            console.error(`Modelo ${displayName} no possui scores reais. Este modelo ser ignorado na visualizao.`);
            return; // Pula este modelo e continua para o prximo no forEach
        }
        
        // CHANGED: Create violin + box trace with model name as the x value
        plotData.push({
            type: 'violin',
            y: model.scores,
            x: Array(model.scores.length).fill(displayName),
            name: displayName,
            box: {
                visible: true,
                width: 0.6
            },
            meanline: {
                visible: true
            },
            line: {
                color: 'black',
                width: 1
            },
            fillcolor: color,
            opacity: 0.7,
            points: 'all',
            jitter: 0.3,
            pointpos: 0,
            hoverinfo: 'y+x',
            spanmode: 'soft',
            width: 0.5, // Wider violins for better visibility
            bandwidth: 0.2  // Increased bandwidth for smoother appearance
        });
    });
    
    // CHANGED: Add base scores as separate markers, one per model
    const baseScoreTrace = {
        type: 'scatter',
        mode: 'markers',
        y: models.map(m => m.baseScore),
        x: models.map(m => m.name.replace(/_/g, ' ').trim()),
        name: 'Base Score',
        marker: {
            size: 12,
            symbol: 'diamond',
            color: models.map(m => modelColors[m.name] || 'rgba(31, 119, 180, 0.7)'),
            line: {
                color: 'white',
                width: 1
            }
        },
        text: models.map(m => `Base Score: ${m.baseScore.toFixed(4)}`),
        hoverinfo: 'text+y'
    };
    
    plotData.push(baseScoreTrace);
    
    // Get metric name from boxplotData or window.reportData
    const metricName = boxplotData.metricName || 
                       window.reportData?.metric ||
                       'Score';
    
    // CHANGED: Updated layout to reflect models on X-axis
    const layout = {
        title: {
            text: `Model Performance Distribution - ${metricName}`,
            font: { size: 20 }
        },
        xaxis: {
            title: 'Models',
            tickangle: 0, // No need to angle with fewer categories
            automargin: true
        },
        yaxis: {
            title: metricName,
            zeroline: false,
            autorange: true,
            automargin: true
        },
        autosize: true,
        violinmode: 'group',
        hoverlabel: {
            bgcolor: "#FFF",
            font: { size: 12 },
            bordercolor: "#333"
        },
        showlegend: true,
        legend: {
            orientation: "h",
            yanchor: "top",
            y: 1.1,
            xanchor: "right",
            x: 1
        },
        hovermode: 'closest',
        margin: {
            l: 50,
            r: 20,
            t: 60,
            b: 80
        },
        annotations: [{
            xref: 'paper',
            yref: 'paper',
            x: 0,
            y: -0.15,
            text: 'The boxplots show model performance distribution under perturbation tests. Diamond markers indicate base scores.',
            showarrow: false,
            font: { size: 12 }
        }]
    };
    
    try {
        // Render the visualization
        Plotly.newPlot(container, plotData, layout, {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['lasso2d', 'select2d'],
            displaylogo: false,
            staticPlot: false,
            toImageButtonOptions: {
                format: 'png',
                filename: 'model_comparison_boxplot',
                height: 700,
                width: 1000,
                scale: 2
            }
        }).then(() => {
            console.log("Boxplot chart successfully rendered");
            
            // Force a resize event to ensure proper layout
            window.dispatchEvent(new Event('resize'));
            
            // Populate the statistics table
            populateStatsTable(models);
        }).catch(error => {
            console.error("Plotly.newPlot failed:", error);
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Erro ao criar grfico</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.4;">${error.message}</p>
                </div>`;
        });
    } catch (error) {
        console.error("Exception during Plotly.newPlot:", error);
        container.innerHTML = `
            <div style="padding: 40px; text-align: center; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 8px; margin: 20px auto; max-width: 600px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <div style="font-size: 48px; margin-bottom: 20px;"></div>
                <h3 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #cc0000;">Erro ao criar grfico</h3>
                <p style="color: #666; font-size: 16px; line-height: 1.4;">${error.message}</p>
            </div>`;
    }
}

/**
 * Populate the model statistics table
 * @param {Array} models Array of model data objects
 */
function populateStatsTable(models) {
    const tableBody = document.getElementById('boxplot-table-body');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    // Create a title row for the table to make it clearer
    const titleRow = document.createElement('tr');
    titleRow.innerHTML = `<th colspan="9" style="text-align: center; padding: 10px; background-color: #f0f8ff;">
        Robustness Performance Statistics
    </th>`;
    tableBody.appendChild(titleRow);
    
    // Keep track of models with scores
    let modelsWithScores = 0;
    
    models.forEach(function(model) {
        // Pular modelos sem scores reais, no gerar dados sintticos
        if (!model.scores || model.scores.length === 0) {
            console.error(`Modelo ${model.name} no possui scores reais para a tabela de estatsticas.`);
            return; // Pula este modelo e continua para o prximo no forEach
        }
        
        modelsWithScores++;
        
        // Sort scores for statistics
        const sortedScores = model.scores.slice().sort((a, b) => a - b);
        
        // Calculate basic stats
        const mean = sortedScores.reduce((a, b) => a + b, 0) / sortedScores.length;
        
        // Calculate median
        const mid = Math.floor(sortedScores.length / 2);
        const median = sortedScores.length % 2 === 0 ? 
            (sortedScores[mid - 1] + sortedScores[mid]) / 2 : 
            sortedScores[mid];
        
        // Calculate quartiles for IQR
        const q1Index = Math.floor(sortedScores.length * 0.25);
        const q3Index = Math.floor(sortedScores.length * 0.75);
        const q1 = sortedScores[q1Index] || 0;
        const q3 = sortedScores[q3Index] || 0;
        const iqr = q3 - q1;
        
        // Calculate min, max
        const min = sortedScores[0] || 0;
        const max = sortedScores[sortedScores.length - 1] || 0;
        
        // Calculate standard deviation
        let stdDev = 0;
        if (sortedScores.length > 1) {
            const squaredDiffs = sortedScores.map(val => Math.pow(val - mean, 2));
            const variance = squaredDiffs.reduce((a, b) => a + b, 0) / sortedScores.length;
            stdDev = Math.sqrt(variance);
        }
        
        // Create row
        const row = document.createElement('tr');
        
        // Model name - replace all underscores with spaces
        const nameCell = document.createElement('td');
        const displayName = model.name.replace(/_/g, ' ');
        nameCell.textContent = displayName || "Unknown Model";
        nameCell.style.fontWeight = 'bold';
        
        // Highlight primary model
        if (model.name === window.reportData?.model_name || model.name === 'Primary Model') {
            nameCell.style.color = '#1b78de';
        }
        
        row.appendChild(nameCell);
        
        // Base score
        const baseScoreCell = document.createElement('td');
        baseScoreCell.textContent = model.baseScore ? model.baseScore.toFixed(4) : "N/A";
        row.appendChild(baseScoreCell);
        
        // Median
        const medianCell = document.createElement('td');
        medianCell.textContent = median.toFixed(4);
        row.appendChild(medianCell);
        
        // Mean
        const meanCell = document.createElement('td');
        meanCell.textContent = mean.toFixed(4);
        row.appendChild(meanCell);
        
        // IQR
        const iqrCell = document.createElement('td');
        iqrCell.textContent = iqr.toFixed(4);
        row.appendChild(iqrCell);
        
        // Min
        const minCell = document.createElement('td');
        minCell.textContent = min.toFixed(4);
        row.appendChild(minCell);
        
        // Max
        const maxCell = document.createElement('td');
        maxCell.textContent = max.toFixed(4);
        row.appendChild(maxCell);
        
        // Std Dev
        const stdDevCell = document.createElement('td');
        stdDevCell.textContent = stdDev.toFixed(4);
        row.appendChild(stdDevCell);
        
        // Score drop
        const dropCell = document.createElement('td');
        const baseScore = model.baseScore || 0;
        const dropPercent = (baseScore > 0) ? ((baseScore - median) / baseScore) * 100 : 0;
        dropCell.textContent = dropPercent.toFixed(2) + '%';
        dropCell.className = dropPercent > 5 ? 'text-danger' : (dropPercent > 2 ? 'text-warning' : 'text-success');
        row.appendChild(dropCell);
        
        tableBody.appendChild(row);
    });
    
    // Add a message if no models with scores were found
    if (modelsWithScores === 0) {
        const emptyRow = document.createElement('tr');
        emptyRow.innerHTML = `<td colspan="9" style="text-align: center; padding: 20px;">
            No models with scores available. Run robustness tests with iterations > 1 to see distribution data.
        </td>`;
        tableBody.appendChild(emptyRow);
    }
    
    console.log(`Populated table with ${modelsWithScores} models`);
}
    </script>
</body>
</html>